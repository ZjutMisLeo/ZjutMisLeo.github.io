<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[left to right/right to left problems]]></title>
    <url>%2F2018%2F11%2F09%2Fleft%20to%20right%20%26%20right%20to%20left%20problems%2F</url>
    <content type="text"><![CDATA[都是一些需要从左扫一遍再从右扫一遍的题，或者是需要两个数组来maintain每个index对应的左右值。 53 Maximum Subarray121 Best Time to Buy and Sell Stock152 Maximum Product Subarray238 Product of Array Except Self739 Daily Temperatures768 Max Chunks to Make Sorted II要求1：将数组分割成不同的部分，将分割的部分各自排序后再拼接，能否得到一个排序后的原数组。 比如：21043，可以分割成210|43两个部分，各自排序后得到012|34。要求2：满足1的前提下，要尽量多的分割这个数组 基本思路：21043为例，如果我们能确保nums[index]左边的数都比它小，那么这一部分就可以被分割排序，因为他们的排序对后面的部分不影响。所以需要两个数组，一个记录当前index的左边的max最大值是多少，一个记录index的右边的最小值是多少。如果说leftmax &lt;= rightmin，那么就可以分割。123456789101112131415161718192021222324class Solution &#123; public int maxChunksToSorted(int[] arr) &#123; int len = arr.length; int[] l = new int[len]; l[0] = arr[0]; for (int i = 1; i &lt; len; i++) &#123; l[i] = Math.max(l[i - 1], arr[i]); &#125; int[] r = new int[len]; r[len - 1] = arr[len - 1]; for (int i = len - 2; i &gt;= 0; i--) &#123; r[i] = Math.min(arr[i], r[i + 1]); &#125; int res = 0; for (int i = 0; i &lt; len - 1; i++) &#123; if (l[i] &lt;= r[i + 1]) res++; &#125; return res + 1; &#125;&#125; 821 Shortest Distance to a Character基本思路：“loveleetcode” “e” put 0 at all position equals to e, and max at all other positionwe will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0] scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]),we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0] scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1])we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]解释的很清楚了第一遍从左到右扫描，记录当前character左边最近的字符C的距离，+1表示比之前的距离多了一格第一遍从右到左扫描，记录当前character右边最近的字符C的距离123456789101112131415161718192021222324class Solution &#123; public int[] shortestToChar(String S, char C) &#123; int len = S.length(); int[] nums = new int[len]; for (int i = 0; i &lt; len; i++) &#123; if (S.charAt(i) == C) &#123; nums[i] = 0; &#125;else &#123; nums[i] = Integer.MAX_VALUE; &#125; &#125; for (int i = 0; i &lt; len - 1; i++) &#123; if (nums[i] == Integer.MAX_VALUE) &#123; continue; &#125;else &#123; nums[i + 1] = Math.min(nums[i] + 1, nums[i + 1]); &#125; &#125; for (int i = len - 1; i &gt; 0; i--) &#123; nums[i - 1] = Math.min(nums[i - 1], nums[i] + 1); &#125; return nums; &#125;&#125; 845 Longest Mountain in Array基本思路：狗家面筋，找数组中的小山。基本思路就是用两个array，从左扫描找山的左半部分，存下来，从右扫描存山的右半部分，存下来。最后再用一个array，一边拼接一边找出最大的山峰。一共用了三个for loop，两个array。 follow up：one pass，no extra space用双指针，up和down分别代表之前的数组，up和down实时更新。当遇到一座山已经走完时，将up和down重置为0，新的一座山只有在前一座山走完之后才能遇到。山走完有两种情况： down指针不为0且遇到开始上升的part 前后两值相等时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int longestMountain(int[] A) &#123; if (A.length &lt; 3) return 0; int up = 0 , down = 0, res = 0; for (int i = 1; i &lt; A.length; i++) &#123; // down指针不为0且遇到开始上升的part &amp;&amp; 前后两值相等时。 if (down &gt; 0 &amp;&amp; A[i] &gt; A[i - 1] || A[i] == A[i - 1]) &#123; down = 0; up = 0; &#125; if (A[i] &gt; A[i - 1]) up++; if (A[i] &lt; A[i - 1]) down++; if (up &gt; 0 &amp;&amp; down &gt; 0 &amp;&amp; up + down + 1 &gt; res) &#123; res = up + down + 1; &#125; &#125; return res; &#125; public int threeloops(int[] A) &#123; int len = A.length; int[] l = new int[len]; Arrays.fill(l, 0); int[] r = new int[len]; Arrays.fill(r, 0); for (int i = 1; i &lt; len; i++) &#123; if (A[i] &gt; A[i - 1]) &#123; l[i] = l[i - 1] + 1; &#125; &#125; for (int i = len - 2; i &gt;= 0; i--) &#123; if (A[i + 1] &lt; A[i]) &#123; r[i] = r[i + 1] + 1; &#125; &#125; int res = 0; for (int i = 0; i &lt; len; i++) &#123; if (l[i] != 0 &amp;&amp; r[i] != 0) res = Math.max(res, l[i] + r[i]); &#125; return res != 0 ? res + 1 : 0; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学计算和一些数学问题]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结LC中出现的包括的数学计算问题，包括实现除法，实现pow(), 实现sqrt(), 实现计算器和一些偏数学的题 数学计算29. Divide Two Integers这题最近狗家出过，虽然是FB tag。实现除法基本思路： 处理corner case:除数为0，返回MAX_VALUE被除数为MIN_VALUE，除数为-1，会越界，所以人工返回MAX_VALUE，除数为1则返回原值 将除数被除数转为long，避免计算过程中越界 使用 &lt;&lt; 符号，A &lt;&lt; B 表示 A * 2的B次方 使用int signal表示结果的正负号，被除数和除数都先处理为整数，用signal表示结果的正负 举例：32 / 312345678910loop: 32 &gt; 3 * 2^0 -&gt; 32 &gt; 3 * 2^1 -&gt; 32 &gt; 3 * 2^2 - &gt; 32 &gt; 3 * 2^3until: 32 &lt; 3 * 2^4，目前一共使用了2^3个 3 将被除数减去目前已经计算好的部分，即32 - 3 * 2^3 = 32 - 24 = 8, 此时res = 8loop: 8 &gt; 3 * 2^0 -&gt; 8 &gt; 3 * 2^1until: 8 &gt; 3 * 2^2将被除数减去目前已经计算好的部分，即8 - 3 * 2^1 = 8 - 6 = 2, 此时res = 10此时被除数小雨除数，跳出循环。32 / 3 = 10 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 0) &#123; return Integer.MAX_VALUE; &#125; if (dividend == Integer.MIN_VALUE) &#123; if (divisor == -1) return Integer.MAX_VALUE; else if (divisor == 1) return Integer.MIN_VALUE; &#125; int signal = 1; long d1 = (long) dividend; long d2 = (long) divisor; if (d1 &lt; 0) &#123; d1 = -d1; signal = -signal; &#125; if (d2 &lt; 0) &#123; d2 = -d2; signal = -signal; &#125; int res = 0; while (d1 &gt;= d2) &#123; int count = 0; while (d1 &gt;= d2 &lt;&lt; count) &#123; count++; &#125; res += (1 &lt;&lt; (count - 1)); d1 -= (d2 &lt;&lt; (count - 1)); &#125; return res * signal; &#125;&#125; 69. Sqrt(x)基本思路:实现开更号， 通过二分实现 这题首先要避免越界。因此mid * mid &gt; x 应该写成 mid &gt; x / mid. 这时候就要避免mid = 0。当right - left = 1时，mid = left（right = 1, left = 0, mid = 0）所以left不能从0开始。所以搜索范围确定为1 ~ x（x的平方必定大于x） 接下来要处理的问题是，如果找不到target sqrt，该怎么返回值。用7举例搜索区间到达[2,3]时，mid = 2, left = mid + 1 = 3.搜索区间到达[3,3]时，mid = 3, left = 3, right = 3 - 1 = 2。跳出循环。可以发现mid其实是刚好平方后大于x的那个值，因此我们返回的right = mid - 1就是解。 这时候要考虑下Corner Case，比如input是0或者2147483647。逻辑走完发现没啥问题。 1234567891011121314151617class Solution &#123; public int mySqrt(int x) &#123; if(x == 0) return 0; int l = 1, r = x; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (mid &gt; x / mid) &#123; r = mid - 1; &#125; else if (mid == x / mid) &#123; return mid; &#125; else&#123; l = mid + 1; &#125; &#125; return r; &#125;&#125; 50. Pow(x, n)基本思路: 实现x^n，很不喜欢这题，因为conner case太烦了。用上了二分的想法 因为 x的n次方 = x的n/2次方 * x的n/2次方，所以recursion就出来了。odd就是拿一个出来再/2，很容易想到 然后是处理n &lt; 0的情况，就是进入递归前把n取反，x = 1/x 这里出现问题，if n = Inetegr.MIN_VALUE，取反就overflow，因此要做一个处理 注意处理n之后也不要忘了x;因为n从-2147483648 变成了 214748364747，正负会有影响：x = x &gt; 0 ? 1.0 / x : -(1.0 / x);12345678910111213141516171819202122class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; if (n &lt; 0) &#123; if (n == Integer.MIN_VALUE) &#123; n = -(n + 1); x = x &gt; 0 ? 1.0 / x : -(1.0 / x); &#125; else &#123; n = -n; x = 1.0 / x; &#125; &#125; if (n % 2 == 0) &#123; return myPow(x * x, n / 2); &#125; else &#123; return x * myPow(x * x, n /2); &#125; &#125;&#125; 数学问题## 31. Next Permutation基本思路：给你一个数比如158476531，让你找出一个Math.min(所有比它大的数)，这里的数只能是原数的permutation。step1. 从尾道头扫描，找到第一个不是递增的数 238. Product of Array Except Self（脸家tag）基本思路： 能用除法的话太简单了，直接进入不能的情况 先用一个res[]来存前缀积，从左往右，res[0] = 1, res[i] = res[i - 1] nums[i - 1]arr 1 2 3 4res 1 1 2 6因为4是没乘的那个数，所以此时res[3]就是4对应的值引入一个变量index，此时index = 1res[3] = 6 index = 6, index = 1 4res[2] = 2 index = 8, index = 4 3res[1] = 1 index = 12, index = 12 2res[0] = 1 index = 24, index = 24 * 1 123456789101112131415public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123;//pre product int[] res = new int[nums.length]; res[0] = 1; for (int i = 1; i &lt; nums.length; i++)&#123; res[i] = res[i - 1] * nums[i - 1]; &#125; int index = 1; for (int i = nums.length - 1; i &gt;= 0; i--)&#123;// 从右边再循环一次，res[n] = res[n] * the product of right numbers res[i] = res[i] * index; index = index * nums[i]; &#125; return res; &#125;&#125; 279. Perfect Squares基本思路: 狗家tag下的题，值得一做，完全平方数 247. Strobogrammatic Number II(狗家面筋题)基本思路：step1 选定一个center，然后在左右append对称的数。step2 如果是偶数，则center从 “” 开始，如果是奇数，center从0, 1, 8开始。step3 最后一次append时，要注意不能加0，这样是meaningless的。 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;String&gt; findStrobogrammatic(int n) &#123; return helper(n, n); &#125; public List&lt;String&gt; helper(int n, int m) &#123; // odd if (n == 0) return new ArrayList&lt;String&gt;(Arrays.asList("")); // even if (n == 1) return new ArrayList&lt;String&gt;(Arrays.asList("0", "1", "8")); List&lt;String&gt; center = helper(n - 2, m); List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; center.size(); i++) &#123; String cur = list.get(i); // avoid add 00 in the last step, becasue it's meaningless if (n != m) res.add("0" + cur + "0"); res.add("1" + cur + "1"); res.add("6" + cur + "9"); res.add("8" + cur + "8"); res.add("9" + cur + "6"); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode中的Word题]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode%E4%B8%AD%E7%9A%84Word%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多经典题，其实不难想，但是写起来有很多要注意的东西，把思路写一下，面试时候解释起来也更顺。 126. Word Ladder II基本思路：1.先用BFS进行构图，连接每个单词。使用两个HashMap：paths &amp; levels。 paths 用来存每个word和它的children的关系，是Map&lt;String, List&gt;, 用于之后DFS遍历 levels 用来存每个word和当前level，或者说step的关系，是Map&lt;String, Integer&gt; 2.使用levels的原因：1234567 hit level 1 / \hot lit level 2 \ / \ lot lid level 3 \ / lod level 4 当BFS到达hot（即queue中poll出hot）时，lot作为一个可选child已经被放入visited set 但lot也是lit的可选child，而因为此时lot has been visited，lot不会被加入lit的children list。所以我们需要levels Now levels contains key lot，and level of lot is 3（在hot那一步存的） so if level of lot == level of lit + 1，那么lot就可以被加入lit的children list 3.如果已经找到end（fount == true），不要把end放到visited中，用来避免其他的路径无法添加end到自己的list中。 4.DFS遍历paths，通过backtracking输出所有的可能答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String begin, String end, List&lt;String&gt; wordList) &#123; Map&lt;String, List&lt;String&gt;&gt; paths = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; levels = new HashMap&lt;&gt;(); HashSet&lt;String&gt; dic = new HashSet&lt;&gt;(wordList); HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); int level = 1; boolean found = false; q.offer(begin); visited.add(begin); levels.put(begin, level); while (!q.isEmpty() &amp;&amp; !found) &#123; int size = q.size(); for (int index = 0; index &lt; size; index++) &#123; String cur = q.poll(); for (int i = 0; i &lt; cur.length(); i++) &#123; char[] ch = cur.toCharArray(); for (char c = 'a'; c &lt;= 'z'; c++) &#123; ch[i] = c; String temp = new String(ch); if (!visited.contains(temp) &amp;&amp; dic.contains(temp)) &#123; if (temp.equals(end)) &#123; found = true; &#125; if (!paths.containsKey(cur)) &#123; paths.put(cur, new ArrayList&lt;String&gt;()); &#125; paths.get(cur).add(temp); q.offer(temp); // if we have found the shortest path, don't add end word to visited set // Because the next word still need to use this if condition to make path if (!found) visited.add(temp); levels.put(temp, level + 1); &#125;else if (levels.containsKey(temp))&#123; if (levels.get(temp) == levels.get(cur) + 1) &#123; // 之前的if中，可能没有把cur存到paths里，所以这里也要做一个判断 if (!paths.containsKey(cur)) &#123; paths.put(cur, new ArrayList&lt;String&gt;()); &#125; paths.get(cur).add(temp); &#125; &#125; &#125; &#125; &#125; level++; &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(begin); dfs(res, list, begin, end, paths, levels); return res; &#125; public void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, String cur, String end, Map&lt;String, List&lt;String&gt;&gt; paths, Map&lt;String, Integer&gt; levels) &#123; if (cur.equals(end)) &#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; // need check since somtimes we can't find path to reach the endWord if (!paths.containsKey(cur) || paths.get(cur).size() == 0) &#123; return; &#125; for (String next : paths.get(cur)) &#123; if (levels.get(cur) + 1 == levels.get(next)) &#123; list.add(next); dfs(res, list, next, end, paths, levels); list.remove(list.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swap相关的题]]></title>
    <url>%2F2018%2F10%2F23%2FSwap%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天和一个傻逼亚麻recruiter打电话，妈的问了三个问题直接叹了个气挂电话了。明明是个白皮口音还没上次的黑哥来的清楚。我问他你觉得我讲的清楚么，他说你自己清楚就行。？？？？？？？ 我真是醉了。刷题了刷题了。. 非LC的题。Minimum number of swaps required to sort an array基本思路：https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_r=internal-search出现在狗家的面试中。涉及到置换群。（用LC854的思路做BFS也能解大概）但是置换群的时空间复杂度都只要On。 Leetcode801. Minimum Swaps To Make Sequences Increasing基本思路：不看答案不会做的DP题。 首先明确题目保证必定有解，那么对于数组A和B，在 i-1 和 i 的位置上只有两种情况第一种：A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]第二种：A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]原因也很简单，如果原本的序列不是递增的，那么交换后必须递增。例如：3 5 4，发现4 &lt; 5， 不满足第一个condition，那么就得满足第二个condition，不然没法保证一定有答案。2 3 7注意这两个条件是可以同时满足的，因此必须用两个if来判断。 使用两个数组，swap 和 keep，swap表示当前位置交换，keep表示当前位置不交换。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int minSwap(int[] A, int[] B) &#123; int len = A.length; int[] swap = new int[len]; int[] keep = new int[len]; // 这儿有个小trick，就是condition 1 不满足的情况下，swap[i]的值其实就是keep[i - 1] + 1 // 所以得保证此时swap[i]是n，这样就能取到想要的值 // 所以这里的赋值是很有意义的 for (int i = 0; i &lt; len; i++) &#123; swap[i] = i; keep[i] = i; &#125; swap[0] = 1; // 已经交换了下标0的两个element，既然交换了就要 +1, 这里交换不影响 keep[0] = 0; // 没交换 for (int i = 1; i &lt; len; i++) &#123; // 这里其实判断的是都换和都不换 if (A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]) &#123; // i - 1那组换了，为了保证increasing，i这组也得换，因为换了所以 + 1 swap[i] = swap[i - 1] + 1; // i - 1那组没换，所以i这组也不用换 keep[i] = keep[i - 1]; &#125; if (A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]) &#123; // 决定换，因为i-1那组和i这组都换的情况在之前已经计算过了，所以和i - 1没换，但是i换的情况比较。 swap[i] = Math.min(swap[i], keep[i - 1] + 1); // 决定不换，因为i-1那组和i这组都不换的情况在之前已经计算过了，所以和i - 1换，但是不换的情况比较。 keep[i] = Math.min(swap[i - 1], keep[i]); &#125; &#125; return Math.min(swap[len - 1], keep[len - 1]); &#125;&#125; 854. K-Similar Strings基本思路：对于String A，最少交换几次可以得到String B。12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int kSimilarity(String A, String B) &#123; if (A.equals(B)) return 0; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(A); HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); visited.add(A); int step = 0; while (!q.isEmpty()) &#123; int len = q.size(); step++; for (int index = 0; index &lt; len; index++) &#123; String s = q.poll(); int i = 0; while (s.charAt(i) == B.charAt(i)) &#123; i++; &#125; for (int j = i + 1; j &lt; s.length(); j++) &#123; if (s.charAt(j) == B.charAt(j) || s.charAt(i) != B.charAt(j)) &#123; continue; &#125; String cur = swap(s, i, j); if (cur.equals(B)) return step; if (visited.add(cur)) &#123; q.offer(cur); &#125; &#125; &#125; &#125; return step; &#125; public String swap(String s, int i, int j) &#123; char[] ch = s.toCharArray(); char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp; return new String(ch); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map，Hash和Map的题]]></title>
    <url>%2F2018%2F09%2F06%2FJava%E4%B8%AD%E7%9A%84Map%2F</url>
    <content type="text"><![CDATA[算是一个上课总结吧，复习复习一下Map，等面试的日子有点难熬的。这个总结的比我自己到位，包括collision，double size，hash function，equals function等等https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E4%B8%80%E6%A6%82%E8%A7%88 常用的MapTreeMap：基于红黑树实现。查找删除O(logN) HashMap：基于哈希表实现。查找删除O(1) HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 HashMap和HashTable的区别HashTable 使用 synchronized 来进行同步。HashMap 可以插入键为 null 的 Entry。HashMap 迭代器是 fail-fast 迭代器。HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 如何实现hash方法A long time ago, I bought a data structures book off the bargain table for $1.25. In it, the explanation for a hashing function said that it should ultimately mod by a prime number because of “the nature of math”.What do you expect from a $1.25 book?Anyway, I’ve had years to think about the nature of math, and still can’t figure it out. 笑尿，但是确实有很多人和我一样疑惑为什么hash时候要选择prime number，是因为数学的本质么。 the size of buckets is a power of 2, so use prime number can reduce collision. Becasue people usually compute index of each bucket based on hashcode % size. It turns out that “because of the nature of maths”, if the constant used in the hash, and the number of buckets, are coprime, then collisions are minimised in some common cases. Leetcode的相关题目187. Repeated DNA Sequencesword pattern &amp; word pattern II560. Subarray Sum Equals K基本思路：用HashMap去maintain前缀和，if (map.containsKey(当前sum - k))，res加上对应的值要注意存在corner case：nums[0] == target此时需要现在map中放入一个(0, 1)123456789101112131415class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0, res = 0; map.put(0, 1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum - k)) &#123; res += map.get(sum - k); &#125; map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return res; &#125;&#125; 791. Custom Sort String（狗家面筋题）基本思路：先分类到HashMap，问题是对String A，根据String B的顺序排序。step1: 用一个map或者freq[]数组把需要排序的String的each character存进去。step2: 扫描String B，如果当前character不为空，则用一个while loop直接把存入的character全部append。step3: 根据字母表顺序扫描一遍freq[], 如果仍有character存在，同step2. follow up：String A 特别长，如何mapreduce。基本思路：分段处理。得到处理完的String list。对这个list进行merge，思路和merge k sorted list相同。12345678910111213141516171819202122class Solution &#123; public String customSortString(String S, String T) &#123; int[] freq = new int[26]; for (char c : T.toCharArray()) &#123; freq[c - 'a']++; &#125; StringBuilder sb = new StringBuilder(); for (char c : S.toCharArray()) &#123; while (freq[c - 'a'] &gt; 0) &#123; sb.append(c); freq[c - 'a']--; &#125; &#125; for (char c = 'a'; c &lt;= 'z'; c++) &#123; while (freq[c - 'a'] &gt; 0) &#123; sb.append(c); freq[c - 'a']--; &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2018%2F08%2F27%2FDynamic%20Programming%2F</url>
    <content type="text"><![CDATA[今天听了Casablanca，特别有触动。加上工卡也批了，还是蛮快乐的(最近最快乐的一天)。 上了课，复习一下。动态规划的核心就是状态的转移，而状态的转移通过状态转移方程和相对应的数据结构来表现。 通过题目应该更好理解。先从LC都没兴趣放的基本题目开始（有些题居然有，很恐怖）。 基本题LCS(Longest Common Subsequence)LCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3.LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4. 1234567891011121314151617181920212223public class LCS &#123; public static int lcs(String a, String b) &#123; int m = a.length(); int n = b.length(); char[] A = a.toCharArray(); char[] B = b.toCharArray(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 0; &#125; else &#123; if (A[i - 1] == B[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; Longest Increasing Subsequence基本思路：用DP解就是n2。follow up：能更快么？DP的过程中可以2分，达到nlogn。 Longest Bitonic Subsequencehttps://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/基本思路：找数组中最长的小山，这里小山不是subarray而是subsequence，所以用dp做。基本思路和LIS是一样的，只不过左右各来了一遍。 LC原题10. Regular Expression Matching基本思路：也是个高频面筋题吧，狗家的。感觉LC前300题都还挺经典的。 64. Minimum Path Sum基本思路：经典题，二维DP bottom-up，follow up的话就是如何不用extra space来作dp 91. Decode Ways（脸狗面筋）基本思路： 95. Unique Binary Search Trees II基本思路：还是从之前的分析出发，通过一个helper method, divide and conquer看代码的话很容易明白思路，但是go through test case不是很容易。背吧T T 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); if (n == 0) return list; return helper(1, n); &#125; public List&lt;TreeNode&gt; helper(int i, int j) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (i &gt; j) &#123; // 这一段if不能少，lsub和rsub在这部分被return res.add(null); return res; &#125; for (int k = i; k &lt;= j; k++) &#123; List&lt;TreeNode&gt; lsub = helper(i, k - 1); List&lt;TreeNode&gt; rsub = helper(k + 1, j); // 等于dp中的相乘 for (TreeNode l : lsub) &#123; for (TreeNode r : rsub) &#123; TreeNode cur = new TreeNode(k); cur.left = l; cur.right = r; res.add(cur); &#125; &#125; &#125; return res; &#125;&#125; 96. Unique Binary Search Trees基本思路：123456789101112situation of only 1 node f(1) = 1situation of 2 nodes f(2) = 2 2 1 / \ 1 2situation of 3 nodes f(3) = 5 1 2 3 / \ / \ / \f(0) f(2) f(1) f(1) f(2) f(0) 以此类推，不难发现其中的dp转移规律 1234f(2) = f(1) * f (0) + f(0) * f(1);f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0);f(4) = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0);...... f(0) = 1其实就表示root的左/右子树全空也是一种情况讲道理吧，这题我不看答案不太想得到。。 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125;&#125; 174. Dungeon Game304. Range Sum Query 2D - Immutable322. Coin Change基本思路：经典中的经典dp[amount] 表示凑成当前数额共需几枚硬币。在每一个数额下，对coins中的每一枚硬币都要尝试。 初始赋值：dp[0] = 0, dp[1] -&gt; dp[amount] = amount + 1 (一个大于amount的数字)状态转移方程：if (coin &lt;= curAmount) dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1); 手动过一遍test case。1234567891011121314151617when curAmount = 2, coin = 1, dp[2] = Math.min(amount + 1, dp[1] + 1) = 2; curAmount = 2, coin = 2, dp[2] = Math.min(2, dp[0] + 1) = 1;when curAmount = 3, coin = 1, dp[3] = Math.min(amount + 1, dp[2] + 1) = 2; curAmount = 3, coin = 2, dp[3] = Math.min(2, dp[1] + 1) = 2;when curAmount = 4, coin = 1, dp[4] = Math.min(amount + 1, dp[3] + 1) = 3; curAmount = 4, coin = 2, dp[4] = Math.min(3, dp[2] + 1) = 2;when curAmount = 5, coin = 1, dp[5] = Math.min(amount + 1, dp[4] + 1) = 3; curAmount = 5, coin = 2, dp[5] = Math.min(3, dp[3] + 1) = 3; curAmount = 5, coin = 5, dp[5] = Math.min(3, dp[0] + 1) = 1;......when curAmount = 11, coin = 1, dp[11] = Math.min(amount + 1, dp[10] + 1) = 3; curAmount = 11, coin = 2, dp[11] = Math.min(3, dp[9] + 1) = 3; curAmount = 11, coin = 5, dp[11] = Math.min(3, dp[6] + 1) = 3; 代码如下：1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; for (int i = 0; i &lt;= amount; i++) &#123; dp[i] = amount + 1; &#125; dp[0] = 0; for (int curAmount = 1; curAmount &lt;= amount; curAmount++) &#123; for (int coin : coins) &#123; if (coin &lt;= curAmount) &#123; dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1); &#125; &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount]; &#125;&#125; 338. Counting Bits对位运算一直没什么感觉。。还是找规律好了0-&gt;00000000 9 -&gt;000010011-&gt;00000001 10-&gt;000010102-&gt;00000010 11-&gt;000010113-&gt;00000011 12-&gt;000011004-&gt;00000100 13-&gt;000011015-&gt;00000101 14-&gt;000011106-&gt;00000110 15-&gt;000011117-&gt;00000111 16-&gt;000100008-&gt;00001000 416. Partition Equal Subset Sum基本思路：也很经典的一道题，判断数组能否被二等分。当然backtracking肯定能解，不过这里还是dp更好，更快其实就是一道背包问题，每个石头拿一次，问能否从石堆中取到刚好填满背包重量的石头。 576. Out of Boundary Paths（baidu）基本思路：和688其实是一样的，从棋改成了球，留在棋盘改成了踢出场外，三维DP代码如下：12345678910111213141516171819202122232425class Solution &#123; private int[][] dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; private final int MOD = 1000000007; public int findPaths(int m, int n, int N, int ri, int rj) &#123; int[][][] dp = new int[N + 1][m][n]; dp[0][ri][rj] = 1; int res = 0; for (int step = 1; step &lt;= N; step++) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; 4; k++) &#123; int row = i + dirs[k][0]; int col = j + dirs[k][1]; if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n) &#123; res = (res + dp[step - 1][i][j]) % MOD; &#125;else &#123; dp[step][row][col] = (dp[step][row][col] + dp[step - 1][i][j]) % MOD; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 688. Knight Probability in Chessboard(狗面筋题，骑士在棋盘中的概率)基本思路：使用三维数组maintain在当前步数下，棋盘上每一格都有多少种情况能存活。偷个花花的图，很清晰了Time Complexity: O(K * N^2), Space Complexity: O(N^3), 可优化到O(N^2)代码如下：12345678910111213141516171819202122232425262728293031class Solution &#123; private int[][] dirs = new int[][]&#123;&#123;1, 2&#125;, &#123;2, 1&#125;, &#123;2, -1&#125;, &#123;1, -2&#125;, &#123;-1, -2&#125;, &#123;-2, -1&#125;, &#123;-2, 1&#125;, &#123;-1, 2&#125;&#125;; public double knightProbability(int N, int K, int r, int c) &#123; double[][][] dp = new double[K + 1][N][N]; dp[0][r][c] = 1.0; for (int step = 1; step &lt;= K; step++) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; for (int k = 0; k &lt; 8; k++) &#123; int row = i + dirs[k][0]; int col = j + dirs[k][1]; if (row &lt; 0 || row &gt;= N || col &lt; 0 || col &gt;= N) &#123; continue; &#125; else &#123; dp[step][i][j] += dp[step - 1][row][col]; &#125; &#125; &#125; &#125; &#125; double res = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; res += dp[K][i][j]; &#125; &#125; return res / Math.pow(8, K); &#125;&#125; 764. Largest Plus Sign基本思路：找二维数组中最大的加号。 877. Stone Game这题是国内日企WAP的面试题之一，用DP没这么容易想。]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie Tree]]></title>
    <url>%2F2018%2F08%2F18%2FTrie%2F</url>
    <content type="text"><![CDATA[刷题刷到要用trie的题又写不出了。。把trie好好写一写。https://leetcode.com/articles/implement-trie-prefix-tree/This explanation is so fucking amazing. LC article is so qiang! ApplicationsTrie(prefix tree)会被用于： 自动补全 拼写检查 IP routing T9 predictive text（九宫格输入法文本预测） why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity could deteriorate to O(n), where nn is the number of keys inserted. Trie could use less space compared to Hash Table when storing many keys with the same prefix. In this case using trie has only O(m) time complexity, where mm is the key length. Searching for a key in a balanced tree costs O(mlog n) time complexity. TrieNode structure1234567891011121314151617181920212223242526272829class TrieNode&#123; private TrieNode[] child; private final int N = 26; private boolean isWord = false; public TrieNode() &#123; child = new TrieNode(N); &#125; public boolean containsKey(char c) &#123; return child[ch - 'a'] != null; &#125; public TrieNode get(char c) &#123; return child[ch - 'a']; &#125; public void put(char c, TrieNode node) &#123; child[c - 'a'] = node; &#125; public boolean isWord() &#123; return isWord; &#125; public void setWord() &#123; isWord = true; &#125;&#125; Insertion of a key to a trie1234567891011121314151617181920class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125;&#125; Complexity Analysis Time complexity : O(m), where m is the key length.In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only mm operations. Space complexity : O(m).In the worst case newly inserted key doesn’t share a prefix with the the keys already inserted in the trie. We have to add mm new nodes, which takes us O(m) space. Search for a key in a trie123456789101112131415161718192021222324class Trie &#123; ... // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125;&#125; Complexity Analysis Time complexity : O(m) In each step of the algorithm we search for the next key character. In the worst case the algorithm performs m operations. Space complexity : O(1) Search for a key prefix in a trie12345678910class Trie &#123; ... // Returns if there is any word in the trie // that starts with the given prefix. public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node != null; &#125;&#125; Complexity Analysis Time complexity : O(m) Space complexity : O(1)]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Back Tracking]]></title>
    <url>%2F2018%2F08%2F16%2FBack%20Tracking%2F</url>
    <content type="text"><![CDATA[他乡逢七夕,旅馆益羁愁。 不见穿针妇,空怀故国楼。 绪风初减热,新月始登秋。 谁忍窥河汉,迢迢问斗牛。 报班的讲了递归和回溯，我自己也来总结一下吧。OA两个题写了我好久。 A general approach to backtracking questions in Java.https://leetcode.com/problems/combination-sum/discuss/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioningLC discuss里这位老哥总结的很好。我自己再精简下。 Subsets I &amp; Subsets III和II只有一个不同，数组中如果有重复元素，如何避免出现重复的子集？ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 关键在于 排序 和 if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; 排序是确保后一句起作用的前提。举个例子 对于不含重复元素的input，比如123, 生成的子集为[], 1, 12, 13, 123, 2, 23, 3 对于含重复元素的input，比如122, 那生成的子集为[], 1, 12, 12, 122, 2, 22, 2 去重的原理：当前子集为12时，backtracking删除2，当加入index为2的元素2时，发现重复，因此不加。 i &gt; start的目的是为了保证第一个出现的重复的值会被加入subset中。 Permutationsuse boolean[], HashSet, or swap() is both ok.如果限制不允许使用额外的空间来check each element是不是被使用，那么swap是一个很好的选择。注意使用swap的话，for loop中i由index赋值，而不是每次从0开始。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length == 0) return res; Arrays.sort(nums); bt(nums, res, new ArrayList&lt;Integer&gt;(), 0); return res; &#125; public void bt(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int index) &#123; if (index == nums.length) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = index; i &lt; nums.length; i++) &#123; list.add(nums[i]); swap(nums, index, i); bt(nums, res, list, index + 1); swap(nums, index, i); list.remove(list.size() - 1); &#125; &#125; public void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 37. Sudoku Solver基本思路：最基本的回溯。对每一个空格子先判断1-9填这里是不是有效，有效的话进入下一步，无效的话将填入的值抹掉变为空值。12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public void solveSudoku(char[][] board) &#123; solve(board); &#125; public boolean solve(char[][] board) &#123; int row = board.length, col = board[0].length; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (board[i][j] == '.') &#123; for (char c = '1'; c &lt;= '9'; c++) &#123; if (isValid(board, i, j, c)) &#123; board[i][j] = c; if (solve(board)) &#123; return true; &#125;else &#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int row, int col, char c) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (board[i][col] != '.' &amp;&amp; board[i][col] == c) return false; if (board[row][i] != '.' &amp;&amp; board[row][i] == c) return false; &#125; int s1 = row / 3 * 3; int s2 = col / 3 * 3; for (int i = s1; i &lt; s1 + 3; i++) &#123; for (int j = s2; j &lt; s2 + 3; j++) &#123; if (board[i][j] != '.' &amp;&amp; board[i][j] == c) return false; &#125; &#125; return true; &#125;&#125; 698. Partition to K Equal Sum Subsets基本思路：和473是完全一样的问题。 先判断和能否被4整除，target = sum / 4;之后对Array排序，如果存在element &gt; target return false;通过一个while loop寻找nums中是否有element恰好等于target，如果存在，k–，相当于桶变少了，加快搜索进度。helper method相当于把剩下的元素分配到K个桶中，保证每次分配桶的sum + 分配进来的值小于等于target。如果所有元素全被分配了，说明可以K等分。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; if (sum % k != 0) return false; int target = sum / k; Arrays.sort(nums); int index = nums.length - 1; if (nums[index] &gt; target) return false; while (index &gt;= 0 &amp;&amp; nums[index] == target) &#123; index--; k--; &#125; int[] sub = new int[k]; return helper(nums, sub, target, index); &#125; public boolean helper(int[] nums, int[] sub, int target, int index) &#123; if (index &lt; 0) return true; int cur = nums[index--]; for (int i = 0; i &lt; sub.length; i++) &#123; if (sub[i] + cur &lt;= target) &#123; sub[i] += cur; if (helper(nums, sub, target, index)) return true; sub[i] -= cur; &#125; if (sub[i] == 0) break; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[287. Find Duplicate]]></title>
    <url>%2F2018%2F08%2F08%2FFind%20Duplicate%2F</url>
    <content type="text"><![CDATA[今天收了封FB内推据信，我和kisday都想不明白问题在哪。。感觉是真的要报班了。。至少保证我有个面试吧，不然题刷的再多有什么用 http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=176498&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D192%26sortid%3D192 在地里看了这个帖子，难受的一批。难受就对了，好走的都是下坡路。 但是题还是要刷。总结一下找重复的一些题。 287. Find the Duplicate Number基本思路：一般有三种方法：排序，用set，根据下标取负。 这题有要求，不能modify原数组，不能使用额外的空间，不能大于O(n) 利用duplicate num这个特点。在该数组中两个不同的index会指向同一个num。因此考虑做一个num -&gt; index的连接，那么该链表成环。问题转化为快慢指针链表找环。 12345678910111213141516171819public class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = 0, fast = 0; int len = nums.length; while (fast &lt; len &amp;&amp; nums[fast] &lt; len) &#123; slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) &#123; slow = 0; while (slow != fast) &#123; slow = nums[slow]; fast = nums[fast]; &#125; return slow; &#125; &#125; return -1; &#125;&#125; 652. Find Duplicate Subtrees]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sliding Window Problems]]></title>
    <url>%2F2018%2F08%2F06%2FSliding%20Window%20Problem%2F</url>
    <content type="text"><![CDATA[刷面经时候看到，正好总结一下这一类sliding window问题（滑窗）。discuss里的template给的很好，不过我觉得还是自己手写过一遍比较好。笨办法帮助理解，毕竟自己不是聪明人。 LC76. Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot; 开一个map（可以数组或者HashMap）用来check S中的字母是否存在于T中。 参数含义： count 用于判断是否找到了一组解。if (count == 0) 就说明T中的所有字母已在当前指针扫描范围被全部cover。 初始化为map.size(), 因为T中可能有重复元素，所以用map.size()。count的增加取决于map中value是否为0。 left 左指针 right 右指针 head 用来maintain每次找到合法解后左指针的位置。 min 当前的最小长度，初始化为Integer.MAX_VALUE 按照代码想法手动过一遍test case: “cabwefgewcwaefgcf”，”cae” round 1: substring is cabwe right = 4, 此时count == 0，left指针开始move，此时left = 0, min = 6, head = 0 之后left和right分别自增，right = 5, left = 1; round 2: 因为c在round 1中被重新加到map中，下一步当right扫到c时，count == 0, 扫描中还会扫到一个e，使其在map中的val - 1 substring is abwefgewc right = 9, 此时count == 0，left指针开始move，此时left = 1, right - left + 1 &gt; min。head和min不变。 之后left和right分别自增，right = 10, left = 2; round 3: substring is efgewcwa right = 11, 此时count == 0， left指针开始move，扫到第一个e，发现map.get(e) == -1, 遂val+1，但map.get(e) 并没有大于0，count不变仍为0。所以while loop中left指针继续向右move，直到发现第二个e为止。 substring is ewcwa right = 11, count == 0, left = 7, right - left + 1 &lt; min, min = 5, head = 7; round 4: substring is cwae right = 12, count == 0, left = 9, right - left + 1 &lt; min, min = 4, head = 9; 找到最优解。 round 5: sunstring is aefgc right - left + 1 &gt; min, pass 扫描完毕 code 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int min = Integer.MAX_VALUE; int left = 0, right = 0, count = map.size(), head = 0; while (right &lt; s.length()) &#123; char r = s.charAt(right); if (map.containsKey(r)) &#123; map.put(r, map.get(r) - 1); if (map.get(r) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; char l = s.charAt(left); if (map.containsKey(l)) &#123; map.put(l, map.get(l) + 1); if (map.get(l) &gt; 0) &#123; count++; &#125; &#125; if (right - left + 1 &lt; min) &#123; head = left; min = right - left + 1; &#125; left++; &#125; right++; &#125; return min == Integer.MAX_VALUE ? "" : s.substring(head, head + min); &#125;&#125; 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p&apos;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &quot;cbaebabacd&quot; p: &quot;abc&quot; Output: [0, 6] Explanation: The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;. The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. 上一题是找subsequence，但是通过check right - left + 1 == p.length()，就能把代码转化为找substring。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : p.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int left = 0, right = 0, head = 0, count = map.size(); while (right &lt; s.length()) &#123; char r = s.charAt(right); if (map.containsKey(r)) &#123; map.put(r, map.get(r) - 1); if (map.get(r) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; char l = s.charAt(left); if (map.containsKey(l)) &#123; map.put(l, map.get(l) + 1); if (map.get(l) &gt; 0) &#123; count++; &#125; &#125; if (right - left + 1 == p.length()) &#123; head = left; list.add(head); &#125; left++; &#125; right++; &#125; return list; &#125;&#125; 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 思路是一样的，右指针发现重复的那个数之后（map.get(r) &gt; 1），左指针开始扫描，直到找到和当前right指针对应的元素相同的元素。此时左指针左边的部分不会被用于之后的寻找最优解的过程中，在map中对应的val也为0.我在这里用了boolean found 来作为判断的条件是否进入左指针寻值的while loop，因为使用count会让人有点迷惑。1234567891011121314151617181920212223242526class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0, right = 0, len = 0; boolean found = false; while (right &lt; s.length()) &#123; char r = s.charAt(right); map.put(r, map.getOrDefault(r, 0) + 1); if (map.get(r) &gt; 1) &#123; found = true; &#125; while (found) &#123; char l = s.charAt(left); if (map.get(l) &gt; 1) &#123; found = false; &#125; map.put(l, map.get(l) - 1); left++; &#125; //System.out.println("right is " + right + " left is " + left); len = Math.max(right - left + 1, len); right++; &#125; return len; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search & Sort]]></title>
    <url>%2F2018%2F07%2F29%2FSearch%20%26%20Sort%2F</url>
    <content type="text"><![CDATA[最近看到FB有人被面了Kth smallest element，我也重新复习一下。// 白复习解法1: 开一个PriorityQueue，time complexity is Nlog(K). 解法2: quick select 思路和快排相同，但只需要对一边进行排序就行。 因为排序后pivot在整个list中的index是确定的，我们只需要比较K和index，如果K &lt; index，那么说明要找的target num在左半部分，反之亦然。 顺便也重新理一下一些基本的选择和排序算法。 高效的排序quick sortbinary searchJon Bentley说90%的程序员都写不对二分, 我个人觉得写二分最好就用一个模板。另外这个帖子真的讲的非常非常好。http://www.1point3acres.com/bbs/thread-432793-1-1.html 当搜索到达right - left == 1的时候，这时候mid是等于left的。 1234567891011121314public int binarySearch(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; //avoid overflow if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] == target) &#123; return mid; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; //dont find&#125; 33. Search in Rotated Sorted Arrays基本思路：最经典的题了。 34. Find First and Last Position of Element in Sorted Array基本思路：1.两个binary search，找到target后一个继续向左，一个继续向右。2.在当前搜索找到target后，记录index后继续向左/右搜索，。123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[2]; res[0] = left(nums, target); res[1] = right(nums, target); return res; &#125; public int left(int[] nums, int target) &#123; //5,7,7,8,8,10 int index = -1, l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &gt;= target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; if (nums[mid] == target) index = mid; &#125; return index; &#125; public int right(int[] nums, int target) &#123; //5,7,7,8,8,10 int index = -1, l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &lt;= target) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; if (nums[mid] == target) index = mid; &#125; return index; &#125;&#125; 153. Find Minimum in Rotated Sorted Array230. Kth Smallest Element in a BST基本思路：用inorder 遍历当然很快，不过这题最好的解法是给二分。 540. Single Element in a Sorted Array基本思路：利用了一个特性，就是多出的single number会影响数组中pair和index之间的规律。12345678910111213原始的array：1 1 3 3 4 4 8 80 1 2 3 4 5 6 7if index is odd, nums[index] = nums[index - 1]if index is even, nums[index] = nums[index + 1]插入一个single number 之后：1 1 2 3 3 4 4 8 80 1 2 3 4 5 6 7 8此时2（single number）之前的subarray还是符合这个规律，但是2之后的部分不符合。所以发现当前index不符合规律，则说明single number在index的左区，r = mid如果符合规律，则single number在index的右区，l = mid + 1代码12345678910111213141516class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int mid = l + (r - l) / 2; int n = mid % 2 == 0 ? mid + 1 : mid - 1; if (nums[mid] == nums[n]) &#123; l = mid + 1; &#125; else &#123; r = mid; &#125; System.out.println("l is: " + l + " " + "r is: " + r); &#125; return nums[l]; &#125;&#125; 658. Find K Closest Elements基本思路：找出最接近x的k个值。背吧，反正我想不到二分还能这么用的，神仙做题。1 Sort Problems179. Largest Number基本思路：这题很有意思，先将int 转为 String，之后开始排序，重写comparator; 排序的逻辑是，String A and String B，if A+B &gt; B+A, 则A在B的前面; for example: 930 &gt; 309, so [9, 30]. String的比较可以直接用compareTo(); 最后根据排序的String[] 拼接字符串输出即可。123456789101112131415161718192021222324252627class Solution &#123; public String largestNumber(int[] nums) &#123; if (nums.length == 0) return ""; if (nums.length == 1) return String.valueOf(nums[0]); int len = nums.length; String[] strs = new String[len]; for (int i = 0; i &lt; len; i++) &#123; strs[i] = String.valueOf(nums[i]); &#125; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; public int compare(String l, String r) &#123; String s1 = l + r; String s2 = r + l; return s2.compareTo(s1); &#125; &#125;); if (strs[0].equals("0")) return "0"; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; sb.append(str); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Spanning Tree & Union found]]></title>
    <url>%2F2018%2F07%2F22%2FMinimum%20Spanning%20Tree%2F</url>
    <content type="text"><![CDATA[今天老姐让我写最小生成树，憋了半天写不出来=，= 最骚的是kisday和我说他也不会写，我会信？ 现在认真学习了一遍，放个总结免得以后又忘了。虽然我隐隐觉得亚麻不会给我这个用的机会。// 确实没给我OA，我可透您马。 最小生成树：连通加权无向图中一棵权值最小的生成树。A. Kruskal算法 （摘自维基百科） 步骤： 1.新建图G，G中拥有原图中相同的节点，但没有边 2.将原图中所有的边按权值从小到大排序 3.从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中（说人话：如果成环就不选这条边），则添加这条边到图G中 4.重复3，直至图G中所有的节点都在同一个连通分量中（所有点都用完了） 证明： 反证法。如果这颗树不是最小生成树，那么一定有一条不在这个树中的边。这条边必定会和其中某些变成环，但环中别的边都是权值最小的，所以如果使用这条边而删去其他的边，那么整颗树的权值就不是minimum了。 注意： 判断连接的两点是否在联通分量中（会不会成环）需要使用并查集。 Union Find用法Find(x): find the root/cluster-id of x Union(x, y): merge two clusters Check whether two elements are in the same set or not in O(1). Find: O(ɑ(n)) ≈ O(1) Union: O(ɑ(n)) ≈ O(1) Space: O(n) Without optimization: Find: O(n)同时使用路径压缩、按秩（rank）合并优化的程序每个操作的平均时间仅为O(ɑ(n))，其中a(n)是n = f(x) = A(x,x)的反函数， A 是急速增加的阿克曼函数。因为a(n)是其反函数，故a(n)在n十分巨大时还是小于 5。因此，平均运行时间是一个极小的常数。实际上，这是渐近最优算法. Two key optimizations: 1.Path compression: make tree flat2.Union by rank: merge low rank tree to high rank one Implementations:12345678910111213141516171819202122232425262728293031323334353637class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; // pu is the parent of u, pv is the parent of v int pu = find(u); int pv = find(v); if (pu == pv) return false;// They are in the same clusterd already if (ranks[pu] &gt; ranks[pv]) &#123;// merge low rank tree to high rank tree parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; Leetcode721. Accounts Merge基本思路: 对于每一个email，赋予一个对应的ID，ID用于判断每个email是不是属于一个cluster 用两个map分别存 email -&gt; name，email -&gt; ID 因为一个email只对应一个ID，所以两个cluster包含相同的email会被merge。 根据cluster index将每个email放到一个新的HashMap中。 拿出这个新map的values(()，对其实的list进行排序，并且在头部插入这个list对应的人名。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; UnionFind uf = new UnionFind(10001); Map&lt;String, String&gt; emailToName = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; emailToId = new HashMap&lt;&gt;(); int id = 0; for (List&lt;String&gt; account : accounts) &#123; String name = account.get(0); for (int i = 1; i &lt; account.size(); i++) &#123; String email = account.get(i); // name和email是一对多的关系，不会出现不同的名字却有相同的email的情况。 emailToName.put(email, name); if (!emailToId.containsKey(email)) &#123; emailToId.put(email, id++); &#125; // 对每个email进行union，存在相同email就会merge // 含义为：拥有相同email的同名账号被认为是一个人（一个人就是一个cluster） uf.union(emailToId.get(account.get(1)), emailToId.get(email)); &#125; &#125; Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String email : emailToName.keySet()) &#123; int index = uf.find(emailToId.get(email)); // 根据 cluster index 将每个email归类 if (!map.containsKey(index)) &#123; map.put(index, new ArrayList&lt;String&gt;()); &#125; map.get(index).add(email); &#125; for (List&lt;String&gt; list : map.values()) &#123; // 排序后 根据email -&gt; name的映射将名字加入list Collections.sort(list); list.add(0, emailToName.get(list.get(0))); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125;class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; // pu is the parent of u, pv is the parent of v int pu = find(u); int pv = find(v); if (pu == pv) return false;// They are in the same clusterd already if (ranks[pu] &gt; ranks[pv]) &#123;// merge low rank tree to high rank tree parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; 684. Redundant Connection基本思路：如果两个点无法被union，说明他们已经在一个cluster中，此时连接这两点的edge会导致树中有环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; UnionFind uf = new UnionFind(1000); for (int[] edge : edges) &#123; if (!uf.union(edge[0], edge[1])) return edge; &#125; return new int[2]; &#125;&#125;class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt; parents.length; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125;&#125; 685. Redundant Connection II基本思路：graph的边从无向变成了有向。 547. Friend Circles基本思路：如果使用并查集，则在UnionFind class加一个参数count用来maintain当前cluster的个数。每次union都会使count - 1。 注意此时new UnionFind(n)时，n必须刚好是所有需要计算的元素的个数，此题中就是学生个数N。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int findCircleNum(int[][] M) &#123; int N = M.length; UnionFind u = new UnionFind(row); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (M[i][j] == 1) &#123; if (!u.union(i, j)) continue; &#125; &#125; &#125; return u.count; &#125;&#125;class UnionFind &#123; int[] parents; int[] ranks; int count; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; count = n; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; count--; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; 765. Couples Holding Hands基本思路：先明确一点，如何判断两个数是一对夫妻 -&gt; nums[i] / 2 == nums[j] / 2。比如2，3和4，5，除2之后为1，1和2，2;这样判断的好处在于不用考虑位置，like 0，1 和1，0; 并查集中的元素个数为 N = row.length / 2;使用并查集的话， 128. Longest Consecutive Sequence基本思路：1.使用并查集，将相差为1的元素放入一个cluster，最后统计每个element在unino find中对中的parent的个数，最多的那个就是答案2.[100, 4, 200, 1, 3, 2] 1234是一个cluster，100是一个，200是一个。1234的parent都是0，所以答案是43.使用一个hashmap在遍历中maintain nums[i], nums[i] + 1 and nums[i] - 1的关系4.注意！union的是每个相邻元素的index，元素本身可能会是负数，union的话会出错。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; UnionFind un = new UnionFind(nums.length + 1); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) continue; map.put(nums[i], i); if (map.containsKey(nums[i] + 1)) &#123; // union index of two elements here un.union(map.get(nums[i] + 1), i); &#125; if (map.containsKey(nums[i] - 1)) &#123; // union index of two elements here un.union(map.get(nums[i] - 1), i); &#125; &#125; // count freq of each parent id, return the max one map = new HashMap&lt;&gt;(); int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; int p = un.find(i); map.put(p, map.getOrDefault(p, 0) + 1); res = Math.max(map.get(p), res); &#125; return res; &#125;&#125;class UnionFind &#123; private int[] parents; private int[] ranks; int count; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; count = n; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; count--; return true; &#125; public int find(int u) &#123; while (u != parents[u]) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125; public int[] getParents() &#123; return parents; &#125;&#125; 399. Evaluate Division]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java lambda expressions]]></title>
    <url>%2F2018%2F07%2F15%2FJava%20lambda%20expressions%2F</url>
    <content type="text"><![CDATA[重写comparator:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Prime Number]]></title>
    <url>%2F2018%2F07%2F09%2FPrime%20Number%2F</url>
    <content type="text"></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万历和鱼]]></title>
    <url>%2F2018%2F07%2F08%2F%E4%B8%87%E5%8E%86%EF%BC%8C%E5%A7%9A%E8%B4%9D%E5%A8%9C%E5%92%8C%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[看了半本万历十五年，挺有意思的一本书。讲了一个被文官和儒家的规矩束缚的可怜皇帝。 昨天朋友深夜打电话给我，接起来就是一阵啜泣。电话那边一句我想回NB了，让我也感觉鼻头一酸。我好明白这种感觉。 我说实在不行就回家吧，其实我也好累，扛不住也正常。他却只是在另一边说，可回去就是承认自己失败了呀。 我突然说不出话来。因为自己内心无法描述出来的感受被人说出来了，被一个有同样感受的人。 其实他又帅又高，性格体贴，在多伦多买了房。饭也烧的好吃。怎么也算不上失败的。 只是还没有个稳定的工作，大概是觉得既然出来了，总得混出点名堂再回去吧。 我懂，因为这也是我的思量。 想显得体面一些，就会有很多顾虑和考量夹在在生活中，就很难用自己觉得舒服的姿势过日子了。但你得装作你其实还不错。 突然就感觉我们这些人有点可怜，还有更可怜的万历皇帝。 皇帝都身不由己，何况我们这些的普通人呢。 一边听着电话，电视里刚好放到姚贝娜在唱鱼，眼睛里闪烁着难以言明的光彩，光彩里涌动着渴望。 感觉我就像她歌声里的鱼，怎么逃都逃不出这个世界编的网，挣脱了一个网眼还有一个网眼。 网眼的种类还挺多：钱，关系，房子，车，人脉，还有乱七八糟的东西。 去你妈的。 我就想每天旱涝保收饿不死没事打打游戏偶尔吃顿好的。人活着怎么就得有这么多逼事儿呢，怎么就有这么多要求呢？ 最变态的是我自己也明白我得去努力追逐这些东西，不能当loser。到底为什么我会有这些跟自己过不去的想法并且用来要求自己？ 我小时候就一直在想，会不会我们的世界其实就是一本故事书，人生只是有个旁白在默默地读你的故事，一个个被写好的故事。 想来想去也没什么头绪，还是继续写会儿代码好了。算是明白文章憎命达了，失意的人才有闲心胡思乱想。 世界静下来了，想了想最近真的好累啊。其实就是在发牢骚吧，因为想逃却逃不了。]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree and BST]]></title>
    <url>%2F2018%2F07%2F05%2FBinary%20Tree%20and%20BST%2F</url>
    <content type="text"><![CDATA[总结了树的遍历方法和LC中的经典题目 树的遍历Preorder TraversalAlgorithm Preorder(tree) Visit the root. Traverse the left subtree, i.e., call Preorder(left-subtree) Traverse the right subtree, i.e., call Preorder(right-subtree) 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); recursion(root, list); return list; &#125; public void recursion(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; list.add(root.val); recursion(root.left, list); recursion(root.right, list); &#125; public List&lt;Integer&gt; iteration(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) return list; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(root); while (!s.isEmpty()) &#123; TreeNode cur = s.pop(); list.add(cur.val); if (cur.right != null) &#123; s.push(cur.right); &#125; if (cur.left != null) &#123; s.push(cur.left); &#125; &#125; return list; &#125;&#125; Inorder TraversalAlgorithm Inorder(tree) Traverse the left subtree, i.e., call Inorder(left-subtree) Visit the root. Traverse the right subtree, i.e., call Inorder(right-subtree) 1 Postorder TraversalAlgorithm Postorder(tree) Traverse the left subtree, i.e., call Postorder(left-subtree) Traverse the right subtree, i.e., call Postorder(right-subtree) Visit the root. 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); recursion(root, list); return list; &#125; public void recursion(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; recursion(root.left, list); recursion(root.right, list); list.add(root.val); &#125; public List&lt;Integer&gt; iteration(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) return list; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(root); while (!s.isEmpty()) &#123; TreeNode cur = s.pop(); list.add(0, cur.val); if (cur.left != null) &#123; s.push(cur.left); &#125; if (cur.right != null) &#123; s.push(cur.right); &#125; &#125; return list; &#125;&#125; 相关问题Tree Isomorphism Problemhttps://www.geeksforgeeks.org/tree-isomorphism-problem/基本思路：分别对树A，树B的左左，右右，左右，右左进行判断时间复杂度：若树是一颗满二叉树，树中一共有n个节点，那么就有n/2的leaf，每个leaf都会被访问n（2^logn）次，所以最坏就是O(n^2)follow up:如果是general的树怎么办？任意两个child都要像这里的left和right subtree一样进行比较。1234567891011121314151617181920212223class solution&#123; public boolean isIsomorphic(Node root1, Node root2) &#123; if (root1 == null &amp;&amp; root2 == null) &#123; return true; &#125;else if (root1 == null || root2 == null) &#123; return false; &#125; if (root1.data != root2.data) return false; //check 左左和右右 if (isIsomorphic(root1.left, root2.left) &amp;&amp; isIsomorphic(root1.right, root2.right)) &#123; return true; &#125; // check 左右和右左 if (isIsomorphic(root1.left, root2.right) &amp;&amp; isIsomorphic(root1.right, root2.left)) &#123; return true; &#125; return false; &#125;&#125; 106. Construct Binary Tree from Inorder and Postorder Traversal基本思路：根据中序和后序构树. 将中序数组的每一个元素和下标都存入map中 后序数组的最后一个数必定是root，在map中找到这个root在inorder数组中对应的下标 此时该index的左边是左子树，右边是有子树。 进行递归。右子树的新root为postIndex - 1左子树的新root为postIndex - (inEnd - index) - 1因为post的顺序是左右根，那么post数组倒着来看的话就是根右左。所以当前postIndex - 1就是右子树的root节点。从当前postIndex减去inorder数组中右子树部分的长度（inEnd - index），就是左子树的root节点 举例：12345678910111213141516 3 / \ 9 20 / \ 15 7 inorder [9,3,15,20,7] postorder [9,15,7,20,3]start inStart inEnd postIndex index 0 4 4 1right 2 4 3left 0 0 0 = 4 - (4 - 1) - 1 代码1234567891011121314151617181920212223class Solution &#123; public TreeNode buildTree(int[] in, int[] post) &#123; if (in == null || post == null || in.length != post.length) return null; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; in.length; i++) &#123; map.put(in[i], i); &#125; return helper(in, post, 0, in.length - 1, post.length - 1, map); &#125; public TreeNode helper(int[] in, int[] post, int inStart, int inEnd, int postIndex, HashMap&lt;Integer, Integer&gt; map) &#123; if (postIndex &lt; 0 || inStart &gt; inEnd) &#123; return null; &#125; int index = map.get(post[postIndex]); TreeNode root = new TreeNode(post[postIndex]); root.left = helper(in, post, inStart, index - 1, postIndex - (inEnd - index) - 1, map); root.right = helper(in, post, index + 1, inEnd, postIndex - 1, map); return root; &#125;&#125; Binary Tree经典题合并两棵二叉树 617. Merge Two Binary Trees基本思路：看代码就行了。12345678910111213141516171819class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null &amp;&amp; t2 == null) return null; int val = 0; if (t1 != null &amp;&amp; t2 != null) &#123; val = t1.val + t2.val; &#125; else if (t1 == null &amp;&amp; t2 != null) &#123; val = t2.val; &#125; else &#123; val = t1.val; &#125; TreeNode cur = new TreeNode(val); cur.left = mergeTrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left); cur.right = mergeTrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right); return cur; &#125;&#125; 742. Closest Leaf in a Binary Tree基本思路：1.先将树转化为图，在构图过程中将target node保存下来，再BFS从target node开始找最短路径。2.因为是树，对于每一个node需要存入的邻居包括了它的父亲节点和儿子节点3.如果一个节点不是root，并且它的邻居只有一个节点，那么他是一个leaf（叶子结点）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int findClosestLeaf(TreeNode root, int k) &#123; Map&lt;TreeNode, List&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); TreeNode node = null; while (!q.isEmpty()) &#123; int len = q.size(); for (int i = 0; i &lt; len; i++) &#123; TreeNode cur = q.poll(); if (!map.containsKey(cur)) &#123; map.put(cur, new ArrayList&lt;TreeNode&gt;()); &#125; if (cur.left != null) &#123; map.get(cur).add(cur.left); map.putIfAbsent(cur.left, new ArrayList&lt;TreeNode&gt;()); map.get(cur.left).add(cur); q.offer(cur.left); &#125; if (cur.right != null) &#123; map.get(cur).add(cur.right); map.putIfAbsent(cur.right, new ArrayList&lt;TreeNode&gt;()); map.get(cur.right).add(cur); q.offer(cur.right); &#125; if (k == cur.val) node = cur; &#125; &#125; q.clear(); q.offer(node); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); visited.add(node); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); System.out.println(cur.val); List&lt;TreeNode&gt; list = map.get(cur); if (list.size() == 1 &amp;&amp; cur != root) &#123; return cur.val; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (visited.contains(list.get(i))) &#123; continue; &#125; q.offer(list.get(i)); visited.add(list.get(i)); &#125; &#125; return root.val; &#125;&#125; BST经典题235. Lowest Common Ancestor of a Binary Search Trees基本思路：按照BST性质来1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else &#123; return root; &#125; &#125;&#125; 450. Delete Node in a BST基本思路：删除节点有三种情况：假定找到的需要删除的点为node node.left == null -&gt; return node.right; node.right == null -&gt; return node.left; node.left != null &amp;&amp; node.right != null找到右子树中最小的节点，替换当前node，然后递归调用函数删除右子树中最小的点 图示的话参考：https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/12345678910111213141516171819202122232425262728class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return null; if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125;else if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125;else &#123; if (root.left == null) &#123; return root.right; &#125;else if (root.right == null) &#123; return root.left; &#125; TreeNode cur = findMin(root.right); root.val = cur.val; root.right = deleteNode(root.right, cur.val); &#125; return root; &#125; public TreeNode findMin(TreeNode root) &#123; while (root.left != null) &#123; root = root.left; &#125; return root; &#125;&#125; 700. Search in a Binary Search Trees基本思路：根据BST性质找就是了。 12345678910111213141516171819class Solution &#123; public TreeNode iteration(TreeNode root, int val) &#123;// BST while (root != null &amp;&amp; root.val != val) &#123; root = root.val &gt; val ? root.left : root.right; &#125; return root; &#125; public TreeNode recursion(TreeNode root, int val) &#123; if (root == null) return null; if (root.val == val) &#123; //System.out.println(root.val); return root; &#125; else if (val &gt; root.val) return searchBST(root.right, val); else if (val &lt; root.val) return searchBST(root.left, val); return null; &#125;&#125; 776. Split BST]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2F2018%2F07%2F05%2F129.%20Sum%20Root%20to%20Leaf%20Numbers%2F</url>
    <content type="text"><![CDATA[A binary tree question. The general ieda is using preorder traversal in recursion way. Iterative solution is also accepted.1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; int sum; public int sumNumbers(TreeNode root) &#123; sum = 0; dfs(root, 0); return sum; &#125; public void dfs(TreeNode node, int cur) &#123; if (node == null) return; cur = cur * 10 + node.val; if (node.left == null &amp;&amp; node.right == null) &#123; sum += cur; return; &#125; if (node.left != null) dfs(node.left, cur); if (node.right != null) dfs(node.right, cur); &#125; public int iterative(TreeNode root) &#123;// use two stacks to keep nodes and current sum if (root == null) return 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sum = new Stack&lt;&gt;(); stack.push(root); sum.push(root.val); int res = 0; while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); int cur = sum.pop(); if (node.left == null &amp;&amp; node.right == null) &#123; res += cur; &#125; if (node.right != null) &#123; stack.push(node.right); sum.push(cur * 10 + node.right.val); &#125; if (node.left != null) &#123; stack.push(node.left); sum.push(cur * 10 + node.left.val); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[863. All Nodes Distance K in Binary Tree]]></title>
    <url>%2F2018%2F07%2F01%2F863.%20All%20Nodes%20Distance%20K%20in%20Binary%20Tree%2F</url>
    <content type="text"><![CDATA[Use HashMap，先用bfs或dfs将树变成一个图，之后根据target node的neighbors进行逐层搜索，直到distance == K。通过HashSet avoid visited nodes。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; Map&lt;TreeNode, HashSet&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; buildMap(root); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(target); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); visited.add(target); boolean found = false; int dis = 0; while (!q.isEmpty()) &#123; int len = q.size(); for (int size = 0; size &lt; len; size++) &#123; TreeNode cur = q.poll(); if (dis == K) &#123; list.add(cur.val); found = true; &#125;else &#123; if (!map.get(cur).isEmpty()) &#123; for (TreeNode t : map.get(cur)) &#123; if (!visited.contains(t)) &#123; q.offer(t); visited.add(t); &#125; &#125; &#125; &#125; &#125; if (found) return list; dis++; &#125; return list; &#125; public void buildMap(TreeNode node) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(node); map.put(node, new HashSet&lt;TreeNode&gt;()); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); if (cur.left != null) &#123; map.put(cur.left, new HashSet&lt;TreeNode&gt;()); map.get(cur).add(cur.left); map.get(cur.left).add(cur); q.offer(cur.left); &#125; if (cur.right != null) &#123; map.put(cur.right, new HashSet&lt;TreeNode&gt;()); map.get(cur).add(cur.right); map.get(cur.right).add(cur); q.offer(cur.right); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[133. Clone Graph]]></title>
    <url>%2F2018%2F07%2F01%2F133.%20Clone%20Graph%2F</url>
    <content type="text"><![CDATA[This is the BFS + Queue solution, use map to keep original nodes and copied nodes.Map can also avoid loop. 1234567891011121314151617181920212223242526272829303132/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */public class Solution &#123; public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return node; UndirectedGraphNode copy = new UndirectedGraphNode(node.label); HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); Queue&lt;UndirectedGraphNode&gt; q = new LinkedList&lt;&gt;(); map.put(node, copy); q.offer(node); while (!q.isEmpty()) &#123; UndirectedGraphNode cur = q.poll(); for (UndirectedGraphNode n : cur.neighbors) &#123; if (!map.containsKey(n)) &#123; map.put(n, new UndirectedGraphNode(n.label)); q.offer(n); &#125; // add neighbors to the copied node // map.get(cur) -&gt; copied node of cur // map.get(n) -&gt; neighbors of copied node map.get(cur).neighbors.add(map.get(n)); &#125; &#125; return copy; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听雨]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%90%AC%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[第一次知道竹山词，是高中时候许南翔一笔笔写在黑板上，说你们现在不懂，觉得这词很一般，将来就懂了。 虞美人这个词牌，历来最推崇不过李煜的“春花秋月何时了，往事知多少”。但我私心里还是更喜欢蒋捷的这首听雨。 我想许南翔当年给我们上课时，应该和我现在是差不多的年纪。过了弱冠之年，离而立却还有一点距离，对人生这个事刚刚有了一点自己的理解。这个世界的万般头绪铺开在我的面前，少年意气开始一点点消减。 开始有了一些却道天凉好个秋的滋味。 晚上一个人在bonsai的吧台吃冷饭团，一边感受着突然而至的阵雨。没有什么悲欢离合也无情。 只有特别深的孤独。 一个人走在回出租房的路上，穿过不同颜色的皮肤，感受到夹带着雨丝的冷风。 我突然开始怀念家乡闷热的雨季，那潮湿绵密的水汽将我包裹的感觉，那江南水乡特有的味道。 那味道是妈丢给我的毛巾的香味，是爸端出的来的饭菜的香味，是家里放久了的家具，在梅雨季节散发出来的一点点霉味。 雨声夹带着电视节目的人声，混合着小区外远远传来的几句咒骂。 而现在雨声里只参杂着键盘敲击的哒哒声。 十几岁的我不明白雨水滴落地面的声音怎么能用得上听，但现在知道了。原来只有生活并不一帆风顺的人，才能听到雨的声音。 我合上电脑，看着窗外的雨帘中渐渐显出远处方尖碑的轮廓，若隐若现，居然像极了鼓楼。]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
</search>
