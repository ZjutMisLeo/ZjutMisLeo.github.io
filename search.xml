<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tips]]></title>
    <url>%2F2020%2F11%2F22%2Ftips%2F</url>
    <content type="text"><![CDATA[åˆ·é¢˜æ—¶å€™é‡åˆ°çš„ä¸€äº›å°tips, ä¸»è¦æ˜¯ç”¨javaåˆ·é¢˜æ—¶å€™çš„ä¸€äº›tricks Array and List Listè½¬Array: 1list.toArray(new String[0]) list.toArray(new int[0][]); ä¸‹æ ‡çš„åˆ¤æ–­è¦ä¼˜å…ˆäºå–ä»¥ä¸‹æ ‡ä¸ºç´¢å¼•çš„å€¼ï¼Œä¸‹é¢è¿™ä¸ªä¾‹å­å°±æ˜¯ï¼Œå‰è€…èƒ½è¿‡åè€…å°±ä¸è¡Œ 12if(i &lt; grid.length - 1 &amp;&amp; grid[i+1][j] == 1) if(grid[i+1][j] == 1 &amp;&amp; i &lt; grid.length - 1) Map JDK 8æ–°ç‰¹æ€§ï¼Œé¿å…äº†å…ˆcheck keyæ˜¯å¦å­˜åœ¨ï¼Œåœ¨æŸäº›å¾ªç¯ç´¯ç§¯valueæ—¶å¯ä»¥ç”¨ 1map.put(key, map.getOrDefault(key, default_value) + 1) map.putIfAbsent entrysetçš„ä½¿ç”¨ for (Map.Entry&lt;String, Integer&gt; entry : HashMap.entrySet()) Integer åˆ†è£…ç±»ä¸­æœ‰å¾ˆå¤šæœ‰è¶£çš„æ–¹æ³• -&gt; Integer.bitCount() æ´»ç”¨+=å¯ä»¥å…å»è½¬å‹éº»çƒ¦ï¼Œå¦‚ I += Math.powï¼ˆ2ï¼Œjï¼‰// since Math.pow() will return an double data. String.toLowerCase(); Character.isLowerCase(char c);String.toUpperCase(); Character.isUpperCase(char c);Character.isLetterOrDigit(char c); // check the char is letter or digit å‡ ç§å¸¸è§çš„è½¬å‹ï¼šchar c = (char)(â€˜aâ€™ + int) // å¤šç”¨äºæ ¹æ®freq[] æ•°ç»„çš„ä¸‹æ ‡è¿”å›å¯¹åº”çš„character mid = low + (high - low) / 2; æ±‚midä¸€å®šè¦è¿™ä¹ˆå†™ï¼Œç›´æ¥åŠ å¾ˆæœ‰å¯èƒ½ä¼šè¶…å‡ºintèŒƒå›´âš ï¸ Leetcode 616 å¯¹äºfor loopæœ‰ä¸€ç§å¾ˆæœ‰æ„æ€çš„å†™æ³•ï¼Œå°†I++å†™åœ¨for loopé‡Œçš„while loopé‡Œ String.split( ), å°†è¯¥string æ ¹æ®input åˆ†å‰²æˆä¸€ä¸ªæ•°ç»„.String.indexOf(â€œâ€), è¿”å›è¯¥å­—å­—ç¬¦ä¸²åœ¨String ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½® BST ä¸­åºéå†çš„ç»“æœæ˜¯æ‰€æœ‰æ•°çš„é€’å¢åºåˆ—: å…ˆåºéå†ï¼šéå†é¡ºåºè§„åˆ™ä¸ºã€æ ¹å·¦å³ã€‘ ä¸­åºéå†ï¼šéå†é¡ºåºè§„åˆ™ä¸ºã€å·¦æ ¹å³ã€‘ ååºéå†ï¼šéå†é¡ºåºè§„åˆ™ä¸ºã€å·¦å³æ ¹ã€‘ backtracking å¾€Listä¸­æ·»åŠ subListæ—¶ï¼Œéœ€è¦List.add(new ArrayList(subList))ï¼Œå¦åˆ™æ·»åŠ çš„æ˜¯å¯¹äºsubListçš„referenceï¼Œå°±æ˜¯emptyçš„ æ±‚å›æ–‡ï¼ˆpalindromeï¼‰substringï¼Œå¯ä»¥ç”¨dpæ±‚ä¸€ä¸ªdp[i][j], è¡¨ç¤ºç¬¬iåˆ°jçš„substringæ˜¯å¦ä¸ºå›æ–‡çš„ï¼Œä¹‹åå¾ˆå¤šé—®é¢˜å°±å¾ˆè½»æ¾ã€‚å¦‚æœè¶…æ—¶(lc214, lc132)åˆ™è€ƒè™‘kmpï¼Œæ—¶é—´å¤æ‚åº¦O(m + n) 1234567for(int i = 0; i &lt; s.length(); i++) &#123; for(int j = 0; j &lt;= i; j++) &#123; if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])) &#123; dp[j][i] = true; &#125; &#125;&#125; å’Œ1 xor å¯ä»¥è®©äºŒè¿›åˆ¶çš„æ¯ä¸€ä½éƒ½å åœ¨sortå’Œpriority queueä¸­ä½¿ç”¨lambda: Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); Stack JavaScript &amp;&amp; TypeScriptBQ: ä»‹ç»ä¸€ä¸ªæœ€proud çš„é¡¹ç›®ï¼Œä»‹ç»ä¸€ä¸ªæœ€challengeçš„é¡¹ç›®, æœ‰å†²çªäº†æ€ä¹ˆåŠï¼Œå¦‚ä½•è·Ÿpoor performer åˆä½œ https://github.com/donnemartin/system-design-primer#how-to-approach-a-system-design-interview-question]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021 é¢è¯•å‡†å¤‡]]></title>
    <url>%2F2020%2F11%2F01%2Finterview%2F</url>
    <content type="text"><![CDATA[LinkedinåŸºç¡€çŸ¥è¯† Java final finally finalize Final is a keyword. Final is used to apply restrictions on class, method and variable. Final class canâ€™t be inherited, final method canâ€™t be overridden and final variable value canâ€™t be changed. Finally is a block. Final is used to apply restrictions on class, method and variable. Final class canâ€™t be inherited, final method canâ€™t be overridden and final variable value canâ€™t be changed. (try catch) Finalize is a method. Finalize is used to perform clean up processing just before object is garbage collected. mutex / semaphore / binary semaphore Process vs Threadï¼ŒContext switch in thread and process A program that is executing (under action) is called a process.When a program runs then it may contain various threads run accordingly è¿›ç¨‹/çº¿ç¨‹çš„çŠ¶æ€ What is thread safeï¼ŒInter-process communication / Java syncronized Thread safe means that different threads can access the same resources without exposing erroneous behavior or producing unpredictable results. Syncronized: only one thread to execute at any given time. Inter-process communication TCP vs HTTP heap, stack, Java virtual memoryç›¸å…³ å†…å­˜ï¼Œç¡¬ç›˜è¯»å†™ï¼Œlockï¼Œconditional variable ç®—æ³•LeetCodeæ ‘235. Lowest Common Ancestor of a Binary Search TreeBSTçš„LCA 1234567891011121314151617181920212223242526272829public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; // Time Complexity -&gt; O(h), h = logN å¦‚æœæ ‘æ˜¯balancedçš„ã€‚æœ€åæƒ…å†µä¸‹æ˜¯O(N) // Space Complexity : O(h) é€’å½’çš„æ ˆçš„æ·±åº¦å¹³å‡æ˜¯hï¼Œæœ€åæ˜¯N // case1: p, qåˆ†åˆ«åœ¨rootçš„ä¸¤è¾¹ï¼Œé‚£rootå°±æ˜¯LCA if ((root.val - p.val) * (root.val - q.val) &lt;= 0) &#123; return root; &#125; // case2: p, qåŒåœ¨rootçš„å·¦è¾¹æˆ–å³è¾¹ï¼Œé‚£ä¹ˆå°±è¦ç»§ç»­é¡ºç€æ ‘å¾€ä¸‹æ‰¾ if (p.val &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else &#123; return lowestCommonAncestor(root.right, p, q); &#125;&#125;// å¦‚æœé¢è¯•å®˜è¦æ±‚å‡å°Space Complexityï¼Œå°±ç”¨iteration// Space Complexity : O(1)public TreeNode iteration(TreeNode root, TreeNode p, TreeNode q) &#123; while ((root.val - p.val) * (root.val - q.val) &gt; 0) &#123; if (p.val &gt; root.val) &#123; root = root.right; &#125; else &#123; root = root.left; &#125; &#125; return root;&#125; 671. Second Minimum Node In a Binary TreeåŠ¨æ€è§„åˆ’361. Bomb Enemyhttps://leetcode.com/problems/valid-palindrome/ å›æ–‡516. Longest Palindromic Subsequence730. Count Different Palindromic Subsequences1312. Minimum Insertion Steps to Make a String PalindromeList All Palindromic Subsequencesç±»ä¼¼äºæ‰¾combination sum, backtracking + Setå»é‡ã€‚æš´åŠ›ç”Ÿæˆæ‰€æœ‰çš„è§£ https://www.1point3acres.com/bbs/thread-145933-1-1.html 12 not int the list464. Can I Win951. Flip Equivalent Binary Trees1611. Minimum One Bit Operations to Make Integers Zero/** 101011 -&gt; 000000 æ ¹æ®è§„åˆ™1å’Œè§„åˆ™2ï¼Œåªæœ‰è§„åˆ™2å¯ä»¥æ›´æ”¹æœ€é«˜ä½çš„å€¼ï¼Œä½¿å…¶ä»1 -&gt; 0 101011 -&gt; 1(10000) -&gt; 0(10000) -&gt; â€¦. -&gt; 000000 è¿™é‡Œå¼€å§‹ç»„è£…é€’å½’çš„æ¡ä»¶ã€‚ 1(01011) -&gt; 1(10000) helper(01011) 1(10000) -&gt; 0(10000) 1, è¡¨ç¤ºåªæ˜¯ä½¿ç”¨äº†è§„åˆ™2åšäº†ä¸€æ¬¡operation 0(10000) -&gt; 000000 minimumOneBitOperations(10000) ä½¿ç”¨åŸå‡½æ•°ï¼Œå› ä¸ºminimumOneBitOperationsçš„ç›®çš„å°±æ˜¯æŠŠè¿™ä¸ªtargetæ•°å˜æˆ0 æ¥ä¸‹æ¥define helper è¿™ä¸ªhelper() ä¼šæŠŠè¾“å…¥çš„XXXXX covertæˆ 10000 æˆ‘ä»¬å¯¹XXXXXåšåˆ¤æ–­ case1: XXXXX æœ€é«˜ä½æ˜¯1ï¼Œæ¯”å¦‚1XXXX, é—®é¢˜è¢«åˆ†è§£ä¸º minimumOneBitOperations(XXXX) å› ä¸ºè¦æŠŠåå››ä½å˜æˆ0 case2: 0XXXX æœ€é«˜ä½æ˜¯0ï¼Œæ¯”å¦‚0XXXXï¼Œé—®é¢˜è¢«åˆ†è§£ä¸º helper(XXXX), è¿™è¦XXXXè¢«convertæˆ1000 æœ€é«˜ä½çš„0æ‰èƒ½æ ¹æ®è§„åˆ™2è½¬åŒ–ä¸º1: 0XXXX -&gt; 0(1000) -&gt; 1(1000) -&gt; 1(0000) ç”±æ­¤å‘ç°caseå…¶å®æ˜¯åœ¨é‡å¤ helper() + 1 + minimumOneBitOperations() */ https://github.com/wisdompeak/LeetCode/blob/master/Recursion/1611.Minimum-One-Bit-Operations-to-Make-Integers-Zero/1611.Minimum-One-Bit-Operations-to-Make-Integers-Zero_Recursion.cpp Intersection of Two Linked ListsåŒºåˆ«äºLCä¸Šçš„åŸé¢˜ï¼Œè¿™é‡Œä¼šé—®é“¾è¡¨æœ‰ç¯çš„æƒ…å†µ ä¸¤è¡¨éƒ½æ— ç¯ï¼Œç›´æ¥ç”¨LCè§£æ³•ã€‚ ä¸€è¡¨æœ‰ç¯ä¸€è¡¨æ— ç¯ï¼Œä¸ä¼šç›¸äº¤ã€‚(éƒ½ç›¸äº¤äº†ï¼Œæ€ä¹ˆå¯èƒ½Aæœ‰ç¯Bæ²¡æœ‰) ä¸¤è¡¨éƒ½æœ‰ç¯ã€‚è¿™æ—¶å€™éœ€è¦å…ˆåˆ†åˆ«æ‰¾åˆ°ä¸¤ä¸ªé“¾è¡¨çš„å…¥ç¯èŠ‚ç‚¹ã€‚ å¦‚æœä¸¤èŠ‚ç‚¹ç›¸åŒï¼Œåˆ™è¿›å…¥case1ï¼Œè¯´æ˜ç›¸äº¤ç‚¹åœ¨ç¯ä¹‹å‰ï¼Œä¸¤è¡¨ç›¸äº¤ å¦‚æœä¸¤èŠ‚ç‚¹ä¸åŒï¼Œå¯èƒ½æ˜¯ç›¸äº¤ç‚¹åœ¨ç¯ä¸Šï¼Œéœ€è¦ä»ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹éå†ä¸€éç¯ï¼Œçœ‹ç¯ä¸Šæ˜¯å¦å­˜åœ¨å¦ä¸€ä¸ªé“¾è¡¨çš„å…¥ç¯ç‚¹ RetainBestCache1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class RetainBestCache&lt;K, T extends Rankable&gt; &#123; int capacity; Map&lt;K, T&gt; cache; PriorityQueue&lt;Node&gt; pq; DataSource&lt;K, T&gt; dataSource; Object lock; // ç­‰é—®é“äº†å†åŠ  public RetainBestCache(DataSource&lt;K, T&gt; dataSource, int entriesToRetain) &#123; this.capacity = entriesToRetain; this.cache = new HashMap&lt;&gt;(); this.pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Node&gt;() &#123; public int compare(Node n1, Node n2) &#123; return n1.t.getRank() - n2.t.getRank(); &#125; &#125;)ï¼› this.dataSource = dataSource; // this.lock = new Object(); &#125; public T get(K key) &#123; // sychronize(lock); if (cache.containsKey(key)) &#123; return cache.get(key); &#125; T t = dataSource.get(key); // lock.notifyAll(); if (cache.size() &lt; capacity) &#123; cache.put(key, t); pq.offer(new Node(key, t)); &#125; else &#123; T peek = pq.peek(); if (peek.getRank() &lt; t.getRank()) &#123; pq.poll(); cache.remove(peek.key); cache.put(key, t); pq.offer(new Node(key, t)); &#125; &#125; return t; &#125;&#125;class Node &#123; // The wrapper of K and T K key; T t; public Node(K k, T t) &#123; this.key = k; this.t = t; &#125;&#125; follow up: å¦‚æœæ¯ä¸ªå…ƒç´ çš„rankæ˜¯å¯ä»¥åŠ¨æ€è°ƒæ•´çš„ï¼ˆæ¯”å¦‚è¯´æ¯æ¬¡è¢«getä¹‹åï¼Œrankå°±è°ƒæ•´ï¼‰æ€ä¹ˆåŠã€‚ Host Manager æ¯”å¦‚å¦‚ä½•è§£å†³å‡Œé¹°é¡µé¢ä¸Šç”³è¯·æŸå·¥ä½œåå°±è¿›å…¥å…¶ä»–ç½‘ç«™çš„é—®é¢˜ è®¾è®¡ä¸€ä¸ªAPIè®©ç”¨æˆ·å»upload videos System DesignSystem design æ€»ç»“: https://www.1point3acres.com/bbs/thread-756608-1-1.html Design monitoring + alert system -&gt; è¦æ±‚è¿™ä¸ªsystemå¯ä»¥collect logs, æ”¶é›†metrics, ç»™ä¸€ä¸ªsequenceid + data çš„pairï¼Œè®©ä½ è®¾è®¡æ€æ ·å­˜å’Œæ€æ ·evictã€‚æœ‰memory limitçš„é™åˆ¶ã€‚è¿™è½®æ²¡ç­”å¥½ã€‚ DelayTask Scheduler designä¸€ä¸ªfrequent counter -&gt; æ¯ç‚¹å‡»ä¸€æ¬¡ï¼Œè®°å½•ä¸€ä¸‹è¿™ä¸ªç”¨æˆ·ï¼Œæä¾›æœ€è¿‘kä¸ªæœ€å¹³å‡¡çš„ç”¨æˆ·ã€‚(scalability)https://soulmachine.gitbooks.io/system-design/content/cn/bigdata/heavy-hitters.html TopK for last 24h design rate limitter ç”¨ä¸€ä¸ªappend-onlyçš„file system è®¾è®¡ä¸€ä¸ªkey value storage system è¿™ä¸€è½®åå‘äºè€ƒå¯Ÿconcurrency, è€ƒçš„æ˜¯åœ°é‡Œå¸¸è§é¢˜ç›®(1) implement a timer scheduler (2) åœ¨ä¸€ä¸ªqueueä¸Šå®ç°ç”Ÿäº§è€…æ¶ˆè´¹è€…é—®é¢˜ å®ç° store document, query words https://www.1point3acres.com/bbs/interview/linkedin-software-engineer-728645.htmlassuming you have a library to store lots of books, design a system to support two queries: â€œandâ€ to return the collection of book ids which contain word1 and word2; â€œnotâ€ to return the book ids which donâ€™t contain a specific word Delay Task Queue]]></content>
  </entry>
  <entry>
    <title><![CDATA[éš¾ä»¥ç†è§£çš„æ€ªé¢˜]]></title>
    <url>%2F2020%2F09%2F01%2F%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3%E7%9A%84%E6%80%AA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[leetcodeä¸Šæœ‰ä¸€äº›åäººç±»æ€ç»´çš„é¢˜ï¼Œåœ¨è¿™é‡Œæ€»ç»“ä¸€ä¸‹ï¼Œé¢è¯•å‰çœ‹åˆ°ä¹Ÿèƒ½æ–¹ä¾¿å¿«é€Ÿå›å¿†ã€‚ FB157. Read N Characters Given Read41234567891011121314151617181920212223public class LCS &#123; public static int lcs(String a, String b) &#123; int m = a.length(); int n = b.length(); char[] A = a.toCharArray(); char[] B = b.toCharArray(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 0; &#125; else &#123; if (A[i - 1] == B[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[System Design]]></title>
    <url>%2F2020%2F07%2F22%2FSystem%20Design%2F</url>
    <content type="text"><![CDATA[æ¯å¤©çœ‹ä¸€ç« Grokkingçš„ç³»ç»Ÿè®¾è®¡é—®é¢˜ï¼Œä¸ºäº†æ­»æµ·å››æµ·æ•ˆåº”è€ŒåŠªåŠ›ã€‚æŠŠç›æ°´ç•™ç»™å¥‹æ–—é€¼å–ã€‚ TinyURL]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSSçš„ä¸€äº›æŠ€å·§]]></title>
    <url>%2F2020%2F07%2F08%2FCSS%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[è‡ªå·±æ€»ç»“ä¸€äº›å¼€å‘ä¸­å¸¸ç”¨çš„CSSå¸ƒå±€å’Œå°æŠ€å·§ï¼Œé¡ºä¾¿æ”¾ä¸€äº›æˆ‘è§‰å¾—æœ‰ç‚¹å¸®åŠ©å¯å‘çš„cssç›¸å…³çš„ç½‘ç«™ã€‚ 1-Line Layouts* https://1linelayouts.glitch.me/ å·´é“çš„blogï¼Œä¸€çœ‹å°±æ˜¯æ²¡æœ‰PMå‚¬çš„ï¼Œå€¼å¾—å­¦ä¹ ä¸€ä¸ª https://ishadeed.com/ CSS å¸ƒå±€Flexå·¥ä½œä¸­å¸¸ç”¨çš„æ˜¯é€šè¿‡flexæ¥å®ç°childçš„å±…ä¸­ï¼Œä½†æ˜¯å¯¹flexç›’å­çš„æ€§è´¨å…¶å®æ˜¯ä¸€çŸ¥åŠè§£ã€‚ property flex-grow Grid12]]></content>
      <categories>
        <category>éšä¾¿å†™å†™</category>
      </categories>
      <tags>
        <tag>å‰ç«¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›´åŸ]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%9B%B4%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[å›´åœ¨åŸé‡Œçš„äººæƒ³é€ƒå‡ºæ¥ï¼ŒåŸå¤–çš„äººæƒ³å†²è¿›å»ï¼Œå¯¹å©šå§»ä¹Ÿç½¢ï¼ŒèŒä¸šä¹Ÿç½¢ï¼Œäººç”Ÿçš„æ„¿æœ›å¤§éƒ½å¦‚æ­¤ã€‚ â€”â€”â€”â€”æ¨ç»› åœ¨æ¹¾åŒºå†™ä»£ç çš„ç¬¬ä¸‰ä¸ªæœˆï¼Œæˆ‘å¼€å§‹æ˜ç™½ä»€ä¹ˆæ˜¯å›´åŸäº†ã€‚è¿™ç§æ„Ÿè§¦è¿œæ¯”ä»ä¹¦ä¸­è¯»åˆ°çš„æ›´çœŸåˆ‡ï¼Œå› ä¸ºå®ƒåƒæ˜¯ä¸€é“é“æ½œæµèˆ”èˆç€ä½ ï¼Œåœ¨ä½ å¹³é™ä¸”æ­»å¯‚çš„ç”Ÿæ´»é‡Œæ³›èµ·ä¸€ä¸ä¸çš„æ¶Ÿæ¼ªã€‚ç›´åˆ°æœ‰ä¸€å¤©è¿™æ¶Ÿæ¼ªæˆäº†æ³¢ï¼Œæˆäº†æµªï¼Œå°†ä½ æ‰“æ¹¿åœ¨æ¯ä¸€ä¸ªå­¤ç‹¬çš„å¤œé‡Œã€‚ åœ¨è¿™é‡Œç”Ÿæ´»çš„æ¯ä¸€å¤©ï¼Œéƒ½èƒ½æ„Ÿè§‰åˆ°è‡ªå·±å¥½åƒæ›´ç©ºæ´äº†ã€‚ä½œä¸ºâ€œæˆ‘â€çš„è±¡å¾å°‘äº†ï¼Œå´æ›´å¤šçš„è¢«å¡«å…¥äº†è¿™é‡Œæ¯ä¸ªäººéƒ½æœ‰çš„ç¬¦å·ã€‚å¦‚æœå°†è‡ªå·±èº«ä¸Šçš„é›¶ä»¶æ‹†è§£å‡ºæ¥ï¼Œä½ èƒ½ä»æ¹¾åŒºçš„ç»å¤§éƒ¨åˆ†äººèº«ä¸Šæ‰¾åˆ°è¿™äº›é›¶ä»¶ã€‚è¿™è®©æˆ‘æ„Ÿåˆ°æƒ¶æï¼Œä»¿ä½›è‡ªå·±æ­£åœ¨è¢«ä¸€ä¸ªå«åšæ¹¾åŒºçš„çŸ³ç£¨ç¢¾ç¢ï¼Œä»ç¢¾å­ä¸Šé›¶é›¶ç¢ç¢çš„æ‰è½å‡ºæ¥ä¸€äº›å®ƒä¸éœ€è¦çš„ä¸œè¥¿ï¼Œè€Œå‰©ä¸‹çš„éƒ¨åˆ†è¢«å¼ºè¡Œç»„åˆèµ·æ¥ï¼Œåœ¨ç©ºæ´å¤„æ³¨å…¥å·¥èµ„ï¼Œæˆ¿å­ï¼Œè‚¡ç¥¨ï¼Œå¯¹è±¡ç­‰å„å¼å„æ ·çš„ç²˜åˆå‰‚ã€‚ æ²¡æœ‰åŠæ³•é€ƒç¦»ã€‚]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>éšä¾¿å†™å†™</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®©ä¿ºæ¥çœ‹çœ‹æ¹¾åŒºæœ‰ä»€ä¹ˆå¥½åƒçš„]]></title>
    <url>%2F2019%2F01%2F13%2F%E8%AE%A9%E6%88%91%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%B9%BE%E5%8C%BA%E6%9C%89%E5%95%A5%E5%A5%BD%E5%90%83%E7%9A%84%2F</url>
    <content type="text"><![CDATA[è‡ªå·±åšä¸€ä¸ªæ¹¾åŒºå¥½åƒçš„åº—çš„æ€»ç»“ï¼Œå…ˆå†™ä¸€ä¸ªlistï¼Œç„¶ååƒå®Œäº†å†ç»™ä¸ªè¯„ä»·ï¼Œé˜²æ­¢è¸©é›·å“ˆå“ˆå“ˆã€‚ä¿ºæ˜¯ä¸ªå­¤ç‹¬çš„æ¹¾åŒºç¾é£Ÿå®¶ã€‚ ä¸­é¤çƒ§çƒ¤Hankow Cuisineï¼ˆä¸€å“é¦™ï¼Œæ±‰å£ï¼‰å®è¯„ï¼šè¿™å®¶åº—æ˜¯æˆ‘æ¥æ¹¾åŒºåƒçš„ç¬¬ä¸€å®¶çƒ§çƒ¤ï¼Œå½“æ—¶ç€å®æƒŠè‰³äº†å¾ˆä¹…æ²¡åƒè¿‡çƒ§çƒ¤çš„æˆ‘ã€‚ä»Šå¤©å’Œæ¨è€æ¿é‡å›æ•…åœ°ï¼Œæœ‰äº†æ–°çš„ä½“éªŒã€‚å–çš„æœ‰ç»¿è±†æ±¤ï¼Œå¯ä»¥çœ‹å‡ºæ¥æ˜¯è‡ªå·±åšçš„ï¼Œåƒçƒ§çƒ¤çš„æ—¶å€™æ¥ä¸€æ¯å¾ˆè¿‡ç˜¾ï¼Œç”œåº¦é€‚ä¸­ï¼Œè±†æ²™çš„å±‚æ¬¡ä¹Ÿåˆ†æ˜ï¼Œæ¨èã€‚æµ·é²œä¸Šç”Ÿèšå’Œæ‰‡è´ä¸ªå¤´æœ‰ç‚¹å°ï¼Œ8åˆ€6ä¸ªï¼Œå…¶ä¸­æœ‰ä¸¤ä¸ªæˆ‘éƒ½çœ‹ä¸åˆ°è‚‰äº†ã€‚ã€‚æ„Ÿè§‰ç”Ÿèšè¿™äº›è¿˜æ˜¯å»ç å¤´åƒæœ€è¿‡ç˜¾ã€‚éŸ­èœï¼Œç‰ç±³ï¼ŒåœŸè±†ç‰‡ï¼Œé‡‘é’ˆè‡ï¼Œä»½é‡è¿˜è¡Œï¼Œè¾¾åˆ°äº†å›½å†…å­¦æ ¡è¾¹ä¸Šçƒ§çƒ¤æ‘Šçš„ä¸€èˆ¬æ°´å‡†ï¼Œç‰›ç¾Šè‚‰ä¸²çš„åˆ†é‡æ¯”è¾ƒå¤§ï¼Œä½†æ˜¯è®²é“ç†ç¾Šè‚‰ä¸²å’Œç‰›è‚‰ä¸²ä½ åœ¨åƒçš„æ—¶å€™ä¸æ˜¯ç‰¹åˆ«èƒ½åˆ†è¾¨å‡ºæ¥ï¼Œç¾Šè‚‰çš„å«©å’Œé¦™è†»æ²¡èƒ½å¾ˆå¥½çš„ä¿ç•™ä¸‹æ¥ï¼Œè‚‰ä¸²æœ‰äº›è€äº†ã€‚æ­¦æ±‰çš„æœ‹å‹è¯´è¿™å®¶çš„çƒ­å¹²é¢å’Œè±†çš®è¿˜æ˜¯æ¯”è¾ƒæ­£å®—çš„ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“æ­£å®—ä¸æ­£å®—ã€‚ç¾Šè‚‰ç…²ä¸é”™ï¼Œæ„Ÿè§‰æ¹¾åŒºçš„åº—è€æ˜¯æŒ‚ç¾Šè‚‰å–ç‹—è‚‰ï¼Œå¥½åƒçš„ä¸œè¥¿å’Œåº—çš„æœ¬è¡Œéƒ½æ²¡å•¥å…³ç³»ã€‚ã€‚ è¯„åˆ†ï¼š7.0/10 ï¼ˆä¸ªäººè§‰å¾—ä¸å¦‚å¥‰å¤©ï¼‰ æ±¤å¸ä»¤ï¼ˆTLT BBQï¼‰å®è¯„ï¼š ace kingå®è¯„ï¼š å¥‰å¤©å®è¯„ï¼š é«˜çƒ¤å®è¯„ï¼š æ¹–å—èœå’Œå·èœé”…é¼ï¼ˆæ¹–å—ï¼‰ä¿ºè§‰å¾—ï¼š éŸ¶å±±å°è±¡ï¼ˆéŸ¶å±±å†²ï¼‰ä¿ºè§‰å¾—ï¼šé‡äº‹ä¸è§‰éŸ¶å±±å†²ã€‚ğŸ›å°±å®Œäº‹äº†ã€‚æ˜¯ç›®å‰æˆ‘åƒè¿‡çš„ä¸‹é™æœ€é«˜çš„ä¸€å®¶åº—ã€‚æœ‰å‡ é“èœçœŸçš„ğŸ‚ğŸºï¼Œæ— éª¨è¾£å­é¸¡ï¼Œé»„å–‰è‚šä¸ï¼Œå°ç‚’é»„ç‰›è‚‰ï¼Œå¹²é”…åŒ…èœï¼ŒåŠ ä¸Šä¸€ç“¶é‡‘æ¡”æŸ æª¬å°ç´«è‹ã€‚æ¯æ¬¡éƒ½ä¼šå› ä¸ºåƒå¤ªå¤šå›å®¶è‚šå­ç—›ã€‚ä½†æ˜¯çœŸçš„å¥½åƒã€‚å› ä¸ºå¾ˆå¤šèœæˆ‘éƒ½æ²¡æ³•è‡ªå·±åœ¨å®¶å¤ç°ã€‚æˆ‘å·å·è§‚å¯Ÿè¿‡ä»–ä»¬çš„å¨æˆ¿ï¼Œç¡®å®æ˜¯çŒ›ç«å¤§ç¶ï¼Œè‡ªå¸¦é”…æ°”ã€‚ è¯„åˆ†ï¼š9.0/10 ï¼ˆåœ¨å—æ¹¾èƒ½åƒåˆ°çš„é¡¶å³°äº†ï¼Œæ¢¦å¼€å§‹çš„åœ°æ–¹ï¼‰ æ±Ÿæµ™èœä¸Šæµ·ç§æˆ¿èœå®è¯„ï¼š é˜¿æ‹‰ä¸Šæµ·å®è¯„ï¼šæ’é˜Ÿç­‰äº†ä¸€å°æ—¶ã€‚æœåŠ¡å‘˜æ˜¯ä¸Šæµ·äººå’Œè€æ¿ç¡®å®æ˜¯ä¸Šæµ·äººã€‚èœå¼æ¯”è¾ƒå°‘ï¼Œæ›´æ¥è¿‘å°åƒé¦†å­ã€‚å°ç¬¼æ¯”æä¸€å­£çš„è¦å¥½ï¼Œç‚’èœä¸­è§„ä¸­çŸ©ï¼Œé³ä¸ä¸€èˆ¬ï¼Œè€æ²¹æ¡ä¸€èˆ¬ï¼Œæ²¹å¢©åƒä¸‡åˆ«ç‚¹ã€‚èœé¥­å°±æ˜¯æ™®é€šçš„èœç‚’é¥­ç­‰çº§ã€‚åƒè¿‡ä¸€æ¬¡å°±å†ä¹Ÿä¸ä¼šå»äº†ã€‚è¿˜è®©æˆ‘ç­‰1ä¸ªå°æ—¶ï¼Œè¿˜è¦æ‹¼æ¡Œã€‚è¯„åˆ†ï¼š6.0/10 å¼¯å¼¯èœå°å—é£å‘³é™ˆå¦ˆå¦ˆçœ·æ‘æ¢å¦ˆå¦ˆåŒ—æ–¹èœå¹¿å¼ç«é”…å°è‚¥ç¾Šå®è¯„ï¼šå»çš„è¿™å®¶åœ¨Hipotè¾¹ä¸Šï¼Œå‘¨æœ«æ’é˜Ÿç­‰äº†å¾ˆä¹…ã€‚å°è‚¥ç¾Šå°±æ˜¯ä¸€å®¶å¾ˆç¨³çš„åº—ï¼Œä½ å»é‚£é‡Œåƒç«é”…ä¸ä¼šå¤±æœ›ä¹Ÿä¸ä¼šæœ‰æƒŠå–œã€‚ç°åœ¨é…±æ–™ä¸è‡ªåŠ©äº†ï¼Œè‡ªå·±é€‰æ²¹ç¢Ÿï¼ŒèŠéº»é…±ï¼ŒéŸ­èœèŠ±é…±ï¼ˆä¸å–œæ¬¢çš„æ…ç‚¹ï¼‰ã€‚é¸³é¸¯é”…çš„è¾£é”…ä¸è¾£ï¼Œæˆ‘æ±Ÿæµ™å£å‘³ä¹Ÿå¯ä»¥æ¥å—ã€‚å†·èœçš„è¯ç¾Šè‚šä¸æ¯”è¾ƒè¾£ï¼Œè€Œä¸”ç¾Šè‚šæ„Ÿè§‰æ²¡æœ‰åš¼åŠ²ï¼Œæœ‰ç§æºäº†æ°´çš„æ„Ÿè§‰ã€‚è™¾æ»‘å¾ˆä¸€èˆ¬ï¼Œæ²¡æœ‰Qå¼¹çš„æ„Ÿè§‰ã€‚ç”œä¸è¾£å¾ˆå¥‡æ€ªï¼Œé¢ç²‰æœ‰ç‚¹å¤šï¼Œæ„Ÿè§‰å°±æ˜¯ä¸­è¶…é‡Œæ‰¹å‘çš„é‚£ç§ï¼Œå·®è¯„ã€‚ ç‚¹äº†æ–°è¥¿å…°ç¾”ç¾Šè‚‰ï¼Œè’œæ³¥ç‰›è‚‰å’Œä¸€äº›å¿˜äº†åå­—çš„è‚‰ï¼Œç¾Šè‚‰å’Œç‰›è‚‰æ˜¯æ¯”è¾ƒä¸€èˆ¬çš„æ°´å‡†ï¼Œæ²¡æœ‰ç‰¹åˆ«å«©æ»‘çš„æ„Ÿè§‰ï¼Œç•¥æœ‰ä¸€äº›æŸ´ã€‚å› ä¸ºçŸ¥é“æ¹¾åŒºçš„ç™¾å¶æ˜¯ç™½è‰²çš„ï¼Œæ‰€ä»¥ç‚¹äº†ç‰›è‚šï¼Œæ„Ÿè§‰è¿˜å¯ä»¥ï¼Œæ¯”å‰èœçš„ç¾Šè‚šä¸å¥½åƒã€‚ç‚¹äº†ä¸€ä¸ªç¾Šèå­ï¼Œé…åˆæ±¤æ±ç®—æ˜¯æ‰€æœ‰èœé‡Œæœ€å¥½åƒçš„äº†ã€‚ å°è‚¥ç¾Šå°±æ˜¯ä¸€å®¶å½“ä½ æƒ³åƒç«é”…çš„æ—¶å€™ï¼Œå´æ²¡æœ‰ç‰¹åˆ«æƒ³å»çš„åœ°æ–¹ï¼Œé‚£å°±å»å°è‚¥ç¾Šå§ã€‚ è¯„åˆ†ï¼š6.5/10 é”¦é‡Œç¼˜å®è¯„ï¼šè´µï¼Œéš¾åƒã€‚ä¹‹å‰åœ¨ç½‘ä¸Šçœ‹ï¼Œè¿™å®¶åº—å±äºæ¯èª‰å‚åŠçš„ã€‚ç°åœ¨æ˜ç™½äº†ï¼Œèª‰çš„éƒ½æ˜¯ç½‘ä¸Šçš„æ°´å†›ã€‚åƒä¸‡åˆ«æ¥ï¼Œæ¥äº†ç»å¯¹åæ‚”ã€‚ è¯„åˆ†ï¼š4.0/10 æ—¥æ–™æ‹‰é¢Maru Ichiå®è¯„ï¼šç‚¹äº†é…±æ²¹æ‹‰é¢å’Œç« é±¼å°ä¸¸å­ï¼Œé…äº†ä¸€å°ä»½é¥­ã€‚æ±¤åº•å¯èƒ½å› ä¸ºé…±æ²¹çš„å…³ç³»å¾ˆå’¸ï¼Œé¢æ²¡æœ‰ç‰¹åˆ«ç¡¬ï¼Œæ€»ä½“ä¸€èˆ¬ï¼Œé€‚åˆå¯¹æ‹‰é¢æ²¡ä¿¡ä»°çš„äººã€‚Donburiå’Œé…±æ±æ„Ÿè§‰ä¸­è§„ä¸­çŸ©ã€‚ç« é±¼å°ä¸¸å­å°±æ˜¯ç‹—å±ï¼Œè¿˜ä¸å¦‚å¤©ä¸€å¹¿åœºçš„å¥½åƒã€‚ï¼ˆæ®è¯´æ˜¯é»‘è’œæ‹‰é¢ç‰¹åˆ«å¥½åƒï¼Ÿï¼‰combo c å¯ä»¥å¸®ä½ è½»æ¾å¡«é¥±è‚šå­ã€‚ å°±æ˜¯ä¸€å®¶ä¸­åˆé¥¿äº†ï¼Œä¸æƒ³åœ¨å®¶åšé¥­ï¼Œäºæ˜¯å°±å¤–å‡ºæ‰¾çš„èƒ½è®©è‡ªå·±å¡«é¥±è‚šå­çš„åº—ã€‚ è¯„åˆ†ï¼š6.3/10 SeiyaSushiSawa SushiAmami Shima Sushiï¼ˆå°è‚¥ç¾Šå’ŒHipotè¾¹ä¸Šï¼‰å®è¯„ï¼šåƒå¯¿å¸çš„è¯æˆ‘è§‰å¾—ä¸€èˆ¬ï¼Œç‚¹äº†Omakaseï¼Œæ¥è¿‘40åˆ€çš„ä»·æ ¼ï¼Œä¸€å…±10ä¸ªï¼Œæ˜¯å½“å¤©çš„å¸ˆå‚…ç»™ä½ çš„special sushiã€‚æˆ‘åƒå®Œä»¥åæ²¡æœ‰ç‰¹åˆ«æƒŠè‰³çš„æ„Ÿè§‰ï¼Œä¸­è§„ä¸­çŸ©çš„salmonï¼Œwhite tunaï¼Œshrimpå’Œä¸€äº›åˆ«çš„è„‚è‚ªé±¼çš„ç»„åˆï¼Œå…¥å£èƒ½æ„Ÿè§‰åˆ°é±¼ï¼Œç±³é¥­å’Œsauceå¹¶æ²¡æœ‰èä¸ºä¸€ä½“ï¼Œç”šè‡³ä½ éœ€è¦èŠ¥æœ«é…±æ²¹å¸®ä½ è§£è…»ã€‚ä¸éš¾åƒï¼Œä½†æ˜¯å¯¹ä¸èµ·è¿™ä¸ªæ¥è¿‘40åˆ€çš„ä»·æ ¼ã€‚å‰èœç‚¹äº†é±¼ä¸‹å·´ï¼Œè¢«Tantoçš„ç§’æ€äº†ï¼Œè‚‰å¤ªåšæ²¹å¤ªå¤šï¼Œæ²¡æœ‰é±¼ä¸‹å·´çš„æ„Ÿè§‰ã€‚åƒå®Œè¿™ä¸¤ä¸ªæˆ‘å°±å¯¹è¿™å®¶åº—æ²¡ä»€ä¹ˆæœŸå¾…äº†ã€‚åŒæ¥çš„æœ‹å‹ç‚¹äº†é³—é±¼å·å’Œtiger rollï¼Œæˆ‘å°äº†ä¸€ä¸‹ï¼Œç”¨çš„é…±æ–™æœ‰äº›åç”œã€‚è¿™å®¶sushiæ¥ä½“éªŒä¸€æ¬¡å°±å¤Ÿäº†ï¼Œé™¤éä½ é’±å¤šçš„æ²¡å¤„èŠ±ï¼Œä¸ç„¶ä½ å¯ä»¥ç»å¸¸æ¥ï¼Œè€Œæˆ‘åº”è¯¥ä¼šåœ¨è¾¹ä¸Šçš„Hipotå’Œä½ ç›¸è§†ä¸€ç¬‘ã€‚ è¯„åˆ†ï¼š5.8/10 å±…é…’å±‹Tanto Japanese Restaurantï¼ˆé€‚åˆå’Œæœ‹å‹ä¸€èµ·å°é…Œï¼Œæ’é˜ŸåŠå°æ—¶å·¦å³ï¼‰å®è¯„ï¼šè¿™å®¶åº—çš„menuè®©äººæœ‰ç‚¹éœ‡æƒŠï¼Œçœ‹èµ·æ¥æœ‰è¶…è¿‡100+çš„èœå¼ã€‚çƒ¤é±¼ä¸‹å·´å’Œç‰›èˆŒå¼ºæ¨ï¼Œåˆºèº«ï¼Œç‰›æ’æ²™æ‹‰å’Œé²‘é±¼é¥­å›¢æ„Ÿè§‰ä¸€èˆ¬ï¼Œé³—é±¼ç‚’é¥­å¥½åƒã€‚æ•´ä½“æœ‰ç‚¹åå’¸ã€‚æ˜¯æˆ‘ç›®å‰å»è¿‡çš„å±…é…’å±‹é‡Œé¢æœ€å¥½çš„ã€‚ è¯„åˆ†ï¼š8.0/10 ç¾å¼ğŸ”å’Œå„ç§å˜ç§ğŸ”New England Lobster Market &amp; Eatery, 824 Cowan Rd, Burlingame, CA 94010]]></content>
  </entry>
  <entry>
    <title><![CDATA[å›å¤´çœ‹çœ‹]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%9B%9E%E5%A4%B4%E7%9C%8B%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[ç°åœ¨é™ä¸‹å¿ƒæ¥ï¼Œä¹Ÿä¼šæ€è€ƒä¸€äº›åˆ«çš„ï¼Œæ¯”å¦‚ä¸¤ä¸‰å¹´åçš„è‡ªå·±åˆä¼šæ˜¯æ€ä¹ˆæ ·çš„ã€‚å’ŒDavidèŠå¤©çœŸçš„ç»™äº†æˆ‘å¾ˆå¤§çš„è§¦åŠ¨ï¼Œä»–è¯´è‡ªå·±å¹´è½»çš„æ—¶å€™åˆšå»IBMï¼Œè§‰å¾—æœ‰ä¸€ä»½è–ªæ°´ä¸é”™çš„ä½“é¢å·¥ä½œï¼Œç”Ÿæ´»å®‰å®‰ç¨³ç¨³ï¼Œä½†æ˜¯å¹´çºªæ…¢æ…¢å¢é•¿ä¹‹åï¼Œä¼šå¼€å§‹æ€è€ƒè‡ªå·±åº”è¯¥å»åšäº›ä»€ä¹ˆï¼Œæˆ–è€…è‡ªå·±å†…å¿ƒæ·±å¤„æƒ³å»åšäº›ä»€ä¹ˆï¼Œé¢è¯•çš„æ—¶å€™ä»–é—®æˆ‘ï¼Œä½ å¯¹è‡ªå·±çš„æœªæ¥æœ‰è§„åˆ’ä¹ˆï¼Ÿ æˆ‘å¾ˆå®³æ€•è¿™ç§é—®é¢˜ï¼ŒåŸå› æ˜¯è¿™äº›é—®é¢˜ä¼šè®©äººå»è®¤è¯†è‡ªå·±ï¼Œç„¶åå¾ˆæ·±åœ°å‰–æè‡ªå·±ã€‚è¿™ä¼šæŠŠæˆ‘å†…å¿ƒçš„ç©ºæ´å’ŒèŒ«ç„¶ä¸€ä¸‹å­éƒ½æŒ–æ˜å‡ºæ¥ï¼Œå®ƒä»¬ä¸æƒ³çœ‹è§æˆ‘ï¼Œæˆ‘å…¶å®ä¹Ÿä¸ä¹æ„çœ‹è§å®ƒä»¬ã€‚ æˆ‘æ¯•äº†ä¸šï¼ŒåŠªåŠ›æ‰¾åˆ°äº†å·¥ä½œï¼Œåšèœå˜å¾—è¶Šæ¥è¶Šå¥½åƒï¼Œå¼€å§‹å­˜é’±ã€‚ç©ºæš‡æ—¶é—´ä¿æŒåˆ·é¢˜ï¼Œçœ‹ä¹¦ï¼Œå¬éŸ³ä¹ï¼ŒåšæŒæ¸¸æ³³ã€‚å¯æˆ‘ä¸èƒ½åœä¸‹æ¥ï¼Œå› ä¸ºä¸€åœä¸‹æ¥ç©ºè™šçš„æ„Ÿè§‰å°±ä¼šæ…¢æ…¢ä¾µèš€ä½ ï¼Œå¾ˆå¥‡å¦™çš„æ„Ÿè§‰ï¼Œä½ ä¼šè§‰å¾—è‡ªå·±çš„èº«ä½“ä¼¼ä¹æ…¢æ…¢è¢«æº¶è§£åœ¨äº†è¿™ä¸ªç¯å¢ƒé‡Œã€‚æœ‰æ—¶å€™æˆ‘ç”šè‡³ä¼šç¿»çœ‹å¾®ä¿¡çš„å¥½å‹åˆ—è¡¨çœ‹çœ‹è°ä¼šç°åœ¨æœ‰ç©ºå’Œæˆ‘èŠä¼šå„¿å¤©ï¼Ÿè€Œå½“æˆ‘æ§åˆ¶ä½è¿™ç§å¤æ€ªçš„å†²åŠ¨è½¬è€Œæ‰“å¼€å¾®åšçŸ¥ä¹ä¼å›¾æ€æ­»è¿™äº›ç©ºè™šåï¼Œæˆ‘å¾—åˆ°çš„æ˜¯ä¸€æ•´å¤œçš„æ— çœ å’ŒåŠ å·ç‰¹åˆ«åˆºçœ¼çš„é˜³å…‰ã€‚ æ¯”èµ·è¿™ç©ºè™šçš„æ„Ÿè§‰ï¼Œæœ€è®©æˆ‘æ„Ÿåˆ°å®³æ€•çš„æ˜¯ï¼Œæˆ‘æ¸æ¸çš„ä¸çˆ±ç©æ¸¸æˆäº†ã€‚å°å­¦çš„æˆ‘å·è€å¦ˆçš„é’±å»ä¹°å¡å¸¦ï¼Œåˆä¸­çš„æˆ‘ç¿˜äº†å®¶æ•™å»é»‘ç½‘å§ï¼Œé«˜ä¸­çš„æˆ‘å‚åŠ ç€War3çš„çº¿ä¸‹èµ›ï¼Œå¤è¯»çš„æˆ‘ä»åœ¨ç©ç€æ¶‚é¸¦è·³è·ƒï¼Œæœ¬ç§‘çš„æˆ‘æ‰“ç€lolçš„æ ¡èµ›ï¼Œè¯»ç ”çš„æˆ‘ä¹°äº†Pokemoné€Ÿé€šäº†äºŒå‘¨ç›®ã€‚ç°åœ¨ï¼Œæˆ‘æ„Ÿè§‰è‡ªå·±ä½“å†…æ„Ÿå—å¿«ä¹çš„å™¨å®˜å¥½åƒæ…¢æ…¢åœ°è¢«ä¸€äº›ä¸çŸ¥åçš„ä¸œè¥¿åˆ†è§£äº†ï¼Œç„¶åè¿™äº›ä¸çŸ¥åçš„ä¸œè¥¿ç”¨ä¸€äº›ç¬¨é‡çš„ï¼Œæƒ°æ€§çš„ï¼Œæ— æ€§è´¨çš„ç‰©è´¨å¡«å……äº†æˆ‘åŸæ¥å™¨å®˜æ‰€åœ¨çš„ä½ç½®ã€‚å¥½åƒæ²¡ä»€ä¹ˆä¸åŒï¼Œåªæ˜¯å½“æˆ‘æ‰“çˆ†å¯¹é¢æ°´æ™¶çš„æ—¶å€™ï¼Œæˆ‘è§‰å¾—è¿™ä¸ªæ¸¸æˆå˜å¾—å¥½æœºæ¢°ï¼Œç”šè‡³æœ‰äº›æ— èŠã€‚ æˆ‘æ³¡äº†ä¸€æ¯èŒ¶ï¼Œç„¶åæŒ‘ä¸€ä¸ªèˆ’æœçš„å§¿åŠ¿ï¼Œçœ¯ç€çœ¼å¬é‚»å±…å¤§å£°éª‚ä»–é‚£æ¡æ¯å¤©ç‹‚å çš„é»‘èƒŒï¼Œè„‘å­é‡Œæƒ³ç€10å²çš„æˆ‘ï¼Œå¤§å£°çš„å¯¹æˆ‘å¦ˆè¯´æˆ‘æ´»åˆ°100å²ä¹Ÿå–œæ¬¢æ‰“æ¸¸æˆï¼›æƒ³ç€è‡ªå·±æ›¾ç»å†™è¯ï¼Œå†™è¯—ï¼Œç ”ç©¶è¯ç‰Œåçš„æ ·å­ï¼›æƒ³ç€æˆ‘ä¸ºäº†é‚£ä¸ªå¥³å­©åšå••å¤§å“­çš„æ™šä¸Šã€‚æƒ³ç€æƒ³ç€ï¼Œè§‰å¾—è‡ªå·±åƒåªé£ç­ï¼Œéšé£æ‡’æ´‹æ´‹åœ°é£˜ç€ã€‚å¿ƒåº•å”¯ä¸€çš„ä¸€ä¸ä¸è¯‰æ±‚ï¼Œå°±æ˜¯æ¯”è¾¹ä¸Šä¸€èµ·é£˜ç€çš„é£ç­ä»¬ï¼Œé£˜çš„ç¨ç¨é«˜é‚£ä¹ˆä¸€ç‚¹ï¼Œæˆ‘ä¾¿çŸ¥è¶³äº†ã€‚æœ‰æ—¶å€™ä¹Ÿä¼šæœ‰ä¸€äº›çš„å›°æƒ‘ï¼Œä¸æ˜ç™½å¹ç€é£ç­çš„é£åˆ°åº•ä»å“ªé‡Œæ¥ã€‚ä¸è¿‡å½“é£å˜å¤§çš„æ—¶å€™ï¼Œä¸ºäº†é£˜çš„ç¨³ä¸€äº›ï¼Œä¹Ÿå°±æ²¡ç²¾åŠ›å»æƒ³é‚£äº›äº†ã€‚ æ€ç»ªé£˜åˆ°äº†æµ·å¯¹å²¸ï¼Œæœ‹å‹ä»¬å¯ä»¥ç”¨èˆæ± é‡Œçš„éŸ³ä¹ï¼Œç”¨é…’ç²¾ï¼Œç”¨è™šæƒ…å‡æ„ï¼Œç”¨åŸå§‹çš„è‚‰æ¬²æ¥å¡«å……è‡ªå·±çš„ç”Ÿæ´»ã€‚ç„¶è€Œæ¯ä¸€æ¬¡å¤šå·´èƒºçš„æ½®æ±è¤ªå»ï¼Œä»–ä»¬è¯¥æ€ä¹ˆå¤„ç†ä¸æ–­å‡é«˜çš„é˜ˆå€¼ï¼Ÿ æˆ‘æŠŠèŒ¶æ°´å–å¹²ï¼Œæ…¢æ…¢å’€åš¼å˜´é‡Œæ®‹ç•™çš„èŒ¶å¶ã€‚å¤§æ¦‚ä¸€è¾ˆå­å°±å’Œè¿™æ¯èŒ¶ä¸€æ ·ï¼ŒèŒ¶æ°´æ€»æœ‰å–å®Œçš„é‚£ä¸€åˆ»ï¼Œäººéƒ½å¾—å»é¢ä¸´å’€åš¼èŒ¶æ ¹çš„æ—¶å€™ã€‚åªæ˜¯æœ‰çš„äººèƒ½æƒ³åŠæ³•æŠŠè¿™æ¯èŒ¶å¤šæ³¡å‡ æ¬¡ï¼Œè€Œæœ‰çš„äººä¸€ç”Ÿå´åªæœ‰ä¸€æ¬¡å†²æ³¡çš„æœºä¼šã€‚ å¸Œæœ›ä¸‰å¹´åçš„è‡ªå·±èƒ½å‘Šè¯‰ç°åœ¨çš„æˆ‘ï¼Œä¸‰å¹´åçš„æˆ‘æ˜¯ä¸æ˜¯å·²ç»èƒ½ç¨ç¨é€è¿‡è¿™äº›å¦‚éœ²å¦‚ç”µçš„æ³¡å½±ï¼Œçœ‹åˆ°äº†ä¸€ä¸è‡ªå·±æƒ³è¿½é€çš„ä¸œè¥¿ã€‚]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>éšä¾¿å†™å†™</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Segment Tree]]></title>
    <url>%2F2018%2F11%2F26%2FSegment%20Tree%2F</url>
    <content type="text"></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>çº¿æ®µæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome]]></title>
    <url>%2F2018%2F11%2F24%2FPalindrome%2F</url>
    <content type="text"><![CDATA[Valid Palindrome125. Valid Palindromeæ€è·¯:æ¯”è¾ƒæœ‰æ„æ€çš„æ˜¯ï¼Œä¸€ä¸ªæœ€æ–°çš„discussionæå‡ºäº† *â€œ%^&amp; &amp;( &amp;^â€* è¿™ä¸ªtest caseä¼šè¢«è®¤ä¸ºå›æ–‡ã€‚ä½†æ˜¯ideä¼šæŠ¥é”™ is not a valid value of type string code: 1234567891011121314151617181920public boolean isPalindrome(String s) &#123; if (s == null || s == "") return true; int i = 0, j = s.length() - 1; s = s.toLowerCase(); while (i &lt; j) &#123; char head = s.charAt(i); char tail = s.charAt(j); if (!Character.isLetterOrDigit(head)) &#123; i++; &#125; else if (!Character.isLetterOrDigit(tail)) &#123; j--; &#125; else if (head != tail) &#123; return false; &#125; else &#123; i++; j--; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
      <tags>
        <tag>å›æ–‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularå­¦ä¹ å¿ƒå¾—]]></title>
    <url>%2F2018%2F11%2F20%2FAngular%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©è¿‡äº†ä¸€ä¸ªç”µé¢ï¼Œé¢æˆ‘çš„è€å“¥è®©æˆ‘å¤šå‡†å¤‡ä¸€ä¸‹Angularï¼Œé¢è¯•ç°åœºè¦å†™ã€‚blogä¸Šçš„ä¾‹å­éƒ½æºè‡ªå®˜æ–¹æ•™ç¨‹ã€‚ å­¦ä¹ çš„è¿‡ç¨‹ä¸­ï¼Œngæ˜¯ä¸€ä¸ªå¾ˆç¥å¥‡çš„æ¡†æ¶ï¼Œç»“åˆäº†è®¸å¤šåç«¯æ‰æœ‰çš„ä¸œè¥¿ï¼Œæ¯”å¦‚DIï¼Œæ¯”å¦‚classï¼Œæ¯”å¦‚æ³¨è§£ï¼ˆè£…é¥°å™¨ï¼‰ã€‚åŒæ—¶ngä¸­ä¹Ÿä½¿ç”¨äº†Typescriptå’ŒRxjsè¿™æ ·å¥½ç”¨çš„å·¥å…·ï¼Œè™½ç„¶å¾ˆé‡ï¼Ÿ è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤§è€Œå…¨çš„ä¸œè¥¿ï¼Œå½“ç„¶çº¦æŸä¹Ÿå¾ˆå¼ºï¼Œæ•´ä¸ªframeçš„è§„èŒƒæ˜¯ç»Ÿä¸€çš„ã€‚åœ¨å¤§å‹è¶…å¤§å‹å¼€å‘ä¸­ä¼šéå¸¸æ£’ï¼Œå› ä¸ºå¤§å®¶ä¸ä¼šå› ä¸ºä¸åŒçš„bersionè€Œå‡ºç°åˆ†æ­§ã€‚è€Œä¸”æœ‰googleçš„äººåœ¨å‰é¢åƒèƒèŸ¹ã€‚ ä½¿ç”¨ä¸€äº›ngè‡ªå·±çš„è¯­æ³•æ¥å¢å¼ºå¯¹HTMLå’ŒDOMçš„æ“ä½œï¼Œæ¯”å¦‚ng ifã€‚ ngè®©æˆ‘èƒ½çœ‹åˆ°ä¸€äº›å‰åç«¯å…±é€šçš„åœ°æ–¹ï¼Œå­¦ä¹ ngçš„è®¾è®¡ç†å¿µæ˜¯ä¸€ä»¶å¾ˆæœ‰æ„æ€çš„äº‹æƒ…ã€‚ â€”â€”â€”â€”-æˆ‘æ˜¯åˆ†å‰²çº¿â€”â€”â€”â€”â€”â€”â€”æ—¶éš”ä¸¤å¹´ï¼Œæˆ‘å¼€å§‹å¯¹è¿™äº›æœ‰æ–°çš„è®¤è¯†äº†ã€‚å¯¹è¿™ç¯‡blogæœ‰ä¸€äº›æ–°çš„ä½“ä¼šã€‚ ä¸€äº›ä½¿ç”¨å‰éœ€è¦çŸ¥é“çš„æ¦‚å¿µWhat is SPASingle Page Applicationï¼ˆå•é¡µåº”ç”¨)ã€‚åœ¨å®é™…çš„å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä¼šé‡åˆ°ä¸€äº›å¸Œæœ›è·³å‡ºå½“å‰pageçš„routing policy What is TypeScript and Why ng use itåŠ¨æ€ç±»å‹ä¸€æ—¶çˆ½ï¼Œä»£ç é‡æ„ç«è‘¬åœºï¼Œç¬‘ã€‚TypeScript is a superset(è¶…é›†) of JavaScript which primarily provides optional static typing, classes and interfaces. One of the big benefits is to enable IDEs to provide a richer environment for spotting common errors as you type the code. é™æ€ç±»å‹æ£€æŸ¥(Optionally static typing and type inference)é™æ€ç±»å‹æ£€æŸ¥å¯ä»¥é¿å…å¾ˆå¤šä¸å¿…è¦çš„é”™è¯¯, ä¸ç”¨åœ¨è°ƒè¯•çš„æ—¶å€™æ‰å‘ç°é—®é¢˜æ³¨æ„: optional static typingæ˜¯æœ‰åŸå› çš„ï¼Œå› ä¸ºTypescriptä¹Ÿå¯ä»¥å®šä¹‰å¯¹è±¡ä¸ºanyç±»ï¼Œè¿™æ ·ä¼šå¿½ç•¥æ‰€æœ‰çš„ç±»å‹æ£€æŸ¥ã€‚åŸå› : ä¿ç•™äº†å¼ºç±»å‹åœ¨æ£€æŸ¥ä¸Šçš„ä¼˜åŠ¿ï¼Œä¹Ÿä¿ç•™äº†å¼±ç±»å‹çš„çµæ´»ã€‚ IDEæ™ºèƒ½æç¤º(Enhanced IDE support)åœ¨ TypeScript è¿™ä¸€ç±»è¯­è¨€ä¹‹å‰, JavaScript çš„æ™ºèƒ½æç¤ºåŸºæœ¬å®Œå…¨ä¾èµ– IDE æä¾›çš„çŒœæµ‹Now the IDE is informed in real-time by the TypeScript compiler on its rich type information. ä»£ç é‡æ„æœ‰æ—¶å€™çš„ç¡®éœ€è¦ä¿®æ”¹ä¸€äº›å˜é‡/å±æ€§/æ–¹æ³•å, ç‰µæ¶‰åˆ°å±æ€§å’Œæ–¹æ³•çš„æ—¶å€™, å¾ˆå¤šæ”¹åŠ¨æ˜¯è·¨æ–‡ä»¶çš„, ä¸åƒæ™®é€šå˜é‡å¯ä»¥ç®€å•å®šä½ scope, å±æ€§æ–¹æ³•åçš„é‡å‘½åå¯¹äº JS æ¥è¯´å¼‚å¸¸ç—›è‹¦, ä¸€æ–¹é¢æ˜¯ä¿®æ”¹æœ¬èº«å°±ä¸æ–¹ä¾¿, å¦ä¸€æ–¹é¢æ˜¯æ”¹äº†è¿˜ä¸ç¡®å®šè¯¥æ”¹çš„æ˜¯ä¸æ˜¯æ”¹äº†, ä¸è¯¥æ”¹çš„æ˜¯ä¸æ˜¯ä¹Ÿæ”¹äº†. è€Œ TypeScript çš„é™æ€ç±»å‹ç³»ç»Ÿå°±å¯ä»¥è¾ƒä¸ºå®Œç¾çš„è§£å†³è¿™ä¸ªé—®é¢˜ (è¿™ä¸ªåœ°æ–¹è¿˜ç‰µæ¶‰åˆ°ä¸€äº›æœ€ä½³å®è·µ, å°±æš‚ä¸æ·±å…¥äº†). å¯è¯»æ€§TypeScriptæ˜¯JavaScriptçš„è¶…é›†ï¼Œæ‰€ä»¥æœ¬è´¨ä¸Šæ”¯æŒJSçš„æ‰€æœ‰è¯­æ³•ï¼Œæ­¤å¤–æ·»åŠ äº†ä¸€äº›OODè¯­è¨€çš„ç‰¹æ€§:class/interface/moduleåŒæ—¶å¼ºç±»å‹çš„è¯­è¨€ç”³æ˜äº†æ‰€æœ‰ç±»å‹ï¼Œç»“åˆOODç‰¹æ€§ï¼Œä»£ç å¯è¯»æ€§å¾ˆé«˜ ä»€ä¹ˆæ˜¯å¼ºï¼Œå¼±ï¼ŒåŠ¨æ€ï¼Œé™æ€ç±»å‹è½¬è‡ªçŸ¥ä¹è½®å­å“¥ï¼šå¼ºç±»å‹ï¼šåå‘äºä¸å®¹å¿éšå¼ç±»å‹è½¬æ¢ã€‚è­¬å¦‚è¯´haskellçš„intå°±ä¸èƒ½å˜æˆdouble (Java, C#)å¼±ç±»å‹ï¼šåå‘äºå®¹å¿éšå¼ç±»å‹è½¬æ¢ã€‚è­¬å¦‚è¯´Cè¯­è¨€çš„intå¯ä»¥å˜æˆdouble (C, C++)é™æ€ç±»å‹ï¼šç¼–è¯‘çš„æ—¶å€™å°±çŸ¥é“æ¯ä¸€ä¸ªå˜é‡çš„ç±»å‹ï¼Œå› ä¸ºç±»å‹é”™è¯¯è€Œä¸èƒ½åšçš„äº‹æƒ…æ˜¯è¯­æ³•é”™è¯¯ (Java, Scala)åŠ¨æ€ç±»å‹ï¼šç¼–è¯‘çš„æ—¶å€™ä¸çŸ¥é“æ¯ä¸€ä¸ªå˜é‡çš„ç±»å‹ï¼Œå› ä¸ºç±»å‹é”™è¯¯è€Œä¸èƒ½åšçš„äº‹æƒ…æ˜¯è¿è¡Œæ—¶é”™è¯¯ã€‚è­¬å¦‚è¯´ä½ ä¸èƒ½å¯¹ä¸€ä¸ªæ•°å­—aå†™a[10]å½“æ•°ç»„ç”¨ (JavaScript) Data Binding (2 years ago)æ•°æ®ç»‘å®šæ˜¯éå¸¸é‡è¦çš„ä¸€éƒ¨åˆ†ã€‚Ngå®ç°åŒå‘æ•°æ®ç»‘å®šçš„æ–¹æ³•å’Œå…¶ä»–çš„æ¡†æ¶ç›¸æ¯”æœ‰å¾ˆå¤šä¸åŒçš„åœ°æ–¹ã€‚ Interpolationç›´æ¥åœ¨htmlä¸­æ’å…¥, valueçš„å˜åŒ–ä¼šç›´æ¥æ›´æ–°åˆ°htmlä¸Š 1&lt;h2&gt;&#123;&#123;hero.name | uppercase&#125;&#125; Details&lt;/h2&gt; The easiest way to display a component property is to bind the property name through interpolationï¼ˆæ’å€¼è¡¨è¾¾å¼ï¼‰. With interpolation, you put the property name in the view template, enclosed in double curly braces: . The word uppercase in the interpolation binding, right after the pipe operator ( | ), activates the built-in UppercasePipe. Pipes are a good way to format strings, currency amounts, dates and other display data. Angular ships with several built-in pipes and you can create your own. Property Binding12@Input() hero: Hero;&lt;app-hero-detail [hero]="selectedHero"&gt;&lt;/app-hero-detail&gt; The hero property must be an Input property, annotated with the @Input() decorator.Because the external HeroesComponent will bind to it like this.æ¨¡æ¿è¯­æ³•æ˜¯[] Event BindingThis is an example of Angularâ€™s event binding syntax. 1&lt;li *ngFor="let hero of heroes" (click)="onSelect(hero)"&gt; Two-way binding [(ngModel)]step1. Import the FormsModule symbol from the @angular/forms library.step2. Then add FormsModule to the @NgModule metadataâ€™s imports array, which contains a list of external modules that the app needs.step3. Use [(ngModel)]=â€valueâ€ 12345&lt;div&gt; &lt;label&gt;name: &lt;input [(ngModel)]="hero.name" placeholder="name"&gt; &lt;/label&gt;&lt;/div&gt; Angularçš„detectioné€»è¾‘ä¸Šé¢æ˜¯ä¸¤å¹´å‰çš„æˆ‘ç½—åˆ—çš„ç®€å•ngè¯­æ³•å’Œdirectiveã€‚äº‹å®ä¸Šæ˜¯çŸ¥å…¶ç„¶ä¸çŸ¥å…¶æ‰€ä»¥ç„¶ã€‚Angularæ˜¯æ€ä¹ˆåšåˆ°å®æ—¶detectç»„ä»¶ä¸­çš„æ•°æ®å˜åŠ¨ï¼Œå¹¶ä¸”æ¸²æŸ“åˆ°viewå±‚çš„å‘¢ã€‚é¢è¯•æ—¶å€™é—®å°æœ‹å‹ï¼Œä¸€èˆ¬èƒ½æåˆ°Dirty checkï¼ŒDOMï¼ŒVirtual DOMå°±å¾ˆä¸é”™äº†ã€‚ä½†æ˜¯ä»€ä¹ˆæ˜¯è„æ£€æŸ¥ï¼Œä¸ºä»€ä¹ˆè¿™äº›è¯ç»„åˆåœ¨ä¸€èµ·ï¼Œèƒ½å®ç°Angularçš„detectionå‘¢ã€‚æˆ‘æ¥æ‰“ç ´ç ‚é”…é—®åˆ°åº•ã€‚ Dirty CheckZone.js (Zones - NG-Conf 2014https://www.youtube.com/watch?v=3IqtmUscE_U&amp;t=150)Zone.js is an execution context that helps developers intercept and keep track of async operations. éå¸¸ç®€å•æ˜äº†åœ°ç‚¹å‡ºäº†Zone.jsçš„æœ¬è´¨ã€‚äº‹å®ä¸Šå®ƒèƒ½å¸®åŠ©å¼€å‘äººå‘˜å¿«é€Ÿçš„trackæ¯ä¸ªzoneä¸­çš„å¼‚æ­¥æ“ä½œ(async operations)ä½•æ—¶ç»“æŸï¼Œäº†è§£ä¸€æ•´æ¡é“¾çš„æµç¨‹ã€‚å¯ä»¥å°†å®ƒç†è§£ä¸ºä¸€ç§Promise.allæˆ–è€…forkjoinã€‚Brian Fordåœ¨demoä¸­ç»™å‡ºäº†å‡ ä¸ªéå¸¸å¥½çš„ä¾‹å­ï¼Œä¸€çœ‹å°±æ˜ç™½ã€‚ Angularå®ç°äº†ä¸¤ç§ä¸åŒçš„æ£€æµ‹æ¨¡å¼: Default å’Œ OnPush. ServicesServices are a great way to share information among classes that donâ€™t know each other.Rely on Angular dependency injection to inject it into the component constructor. Servicesç”¨åˆ°äº†DI-ä¾èµ–æ³¨å…¥çš„æ€æƒ³ï¼Œå‚è€ƒSrpingã€‚ å¼•å…¥æœåŠ¡ï¼ˆservicesï¼‰çš„ç›®çš„æ˜¯ä¸ºäº†è®©ç»„ä»¶å°½é‡çš„è–„ï¼Œè®©ç»„ä»¶åªå¤„ç†å’Œtemplateç›¸å…³çš„æ•°æ®ç»‘å®šã€‚ Ideally, a componentâ€™s job is to enable the user experience and nothing more. A component should present properties and methods for data binding, in order to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model). ObservableWhy we use Observable1this.heroes = this.heroService.getHeroes(); HeroService.getHeroes() must have an asynchronous signature of some kind.ï¼ˆéœ€è¦å¼‚æ­¥äº¤äº’ï¼‰ Observable HeroServiceservice-in-service1constructor(private messageService: MessageService) &#123; &#125; Inject the MessageService into the HeroService which is injected into the HeroesComponent. Loosely-coupled communication between classes. DirectivesDirectives are instructions in the DOM! RouterDifference between Angular, VueDifference between Angular and Vue. Ngå¤§è€Œå…¨ï¼ŒVueå°è€Œç²¾è‡´ã€‚Ngçš„çº¦æŸæ€§å¾ˆå¼ºï¼Œæ›´é€‚åˆå›¢é˜Ÿå¼€å‘ ä¸¤è€…å¯¹äºtwo-way data bandingçš„å®ç°æ˜¯ä¸åŒçš„ã€‚ ä¸€äº›è½®å­çš„æ•´åˆå› ä¸ºngä½¿ç”¨äº†typescriptå¯¼è‡´ä¸€äº›æ²¡æ³•ç›´æ¥require Js fileï¼Œéœ€è¦CLIçš„å¸®åŠ©ã€‚ Use bootstrap cd into current folder, and npm install â€“save bootstrap@3. This bootstrap is local, not global. open angular.json, import bootstrap.min.css into styles (acutally add address into styles). Use D3.jsD3 å’Œ Echartsçš„åŒºåˆ« D3åŸºäºSVG, EchartsåŸºäºCanvasã€‚SVG Canvas 1.ä¸ä¾èµ–åˆ†è¾¨ç‡(çŸ¢é‡å›¾ï¼Œæ”¾å¤§ç¼©å°ä¸å½±å“ç²¾åº¦) 1.2.æ”¯æŒäº‹ä»¶å¤„ç†å™¨(åŸºäºXMLçš„ç»˜å›¾ï¼Œèƒ½æ“ä½œåˆ°æ¯ä¸€ä¸ªDOM)3.æœ€é€‚åˆå¸¦æœ‰å¤§å‹æ¸²æŸ“åŒºåŸŸçš„åº”ç”¨ç¨‹åºï¼ˆæ¯”å¦‚è°·æ­Œåœ°å›¾ï¼‰4.å¤æ‚åº¦é«˜ä¼šå‡æ…¢æ¸²æŸ“é€Ÿåº¦ ä¸€äº›é¢è¯•ä¼šé‡åˆ°çš„é—®é¢˜let and const in Angular]]></content>
      <categories>
        <category>éšä¾¿å†™å†™</category>
      </categories>
      <tags>
        <tag>å‰ç«¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[left to right/right to left problems]]></title>
    <url>%2F2018%2F11%2F09%2Fleft%20to%20right%20%26%20right%20to%20left%20problems%2F</url>
    <content type="text"><![CDATA[éƒ½æ˜¯ä¸€äº›éœ€è¦ä»å·¦æ‰«ä¸€éå†ä»å³æ‰«ä¸€éçš„é¢˜ï¼Œæˆ–è€…æ˜¯éœ€è¦ä¸¤ä¸ªæ•°ç»„æ¥maintainæ¯ä¸ªindexå¯¹åº”çš„å·¦å³å€¼ã€‚ 53 Maximum Subarray121 Best Time to Buy and Sell Stock152 Maximum Product Subarray238 Product of Array Except SelfåŸºæœ¬æ€è·¯: èƒ½ç”¨é™¤æ³•çš„è¯å¤ªç®€å•äº†ï¼Œç›´æ¥è¿›å…¥ä¸èƒ½çš„æƒ…å†µ å…ˆç”¨ä¸€ä¸ªres[]æ¥å­˜å‰ç¼€ç§¯ï¼Œä»å·¦å¾€å³ï¼Œres[0] = 1, res[i] = res[i - 1] nums[i - 1]arr 1 2 3 4res 1 1 2 6å› ä¸º4æ˜¯æ²¡ä¹˜çš„é‚£ä¸ªæ•°ï¼Œæ‰€ä»¥æ­¤æ—¶res[3]å°±æ˜¯4å¯¹åº”çš„å€¼å¼•å…¥ä¸€ä¸ªå˜é‡indexï¼Œæ­¤æ—¶index = 1res[3] = 6 index = 6, index = 1 4res[2] = 2 index = 8, index = 4 3res[1] = 1 index = 12, index = 12 2res[0] = 1 index = 24, index = 24 *1 123456789101112131415public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123;//pre product int[] res = new int[nums.length]; res[0] = 1; for (int i = 1; i &lt; nums.length; i++)&#123; res[i] = res[i - 1] * nums[i - 1]; &#125; int index = 1; for (int i = nums.length - 1; i &gt;= 0; i--)&#123;// ä»å³è¾¹å†å¾ªç¯ä¸€æ¬¡ï¼Œres[n] = res[n] * the product of right numbers res[i] = res[i] * index; index = index * nums[i]; &#125; return res; &#125;&#125; 739 Daily Temperatures768 Max Chunks to Make Sorted IIè¦æ±‚1ï¼šå°†æ•°ç»„åˆ†å‰²æˆä¸åŒçš„éƒ¨åˆ†ï¼Œå°†åˆ†å‰²çš„éƒ¨åˆ†å„è‡ªæ’åºåå†æ‹¼æ¥ï¼Œèƒ½å¦å¾—åˆ°ä¸€ä¸ªæ’åºåçš„åŸæ•°ç»„ã€‚ æ¯”å¦‚ï¼š21043ï¼Œå¯ä»¥åˆ†å‰²æˆ210|43ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå„è‡ªæ’åºåå¾—åˆ°012|34ã€‚è¦æ±‚2ï¼šæ»¡è¶³1çš„å‰æä¸‹ï¼Œè¦å°½é‡å¤šçš„åˆ†å‰²è¿™ä¸ªæ•°ç»„ åŸºæœ¬æ€è·¯ï¼š21043ä¸ºä¾‹ï¼Œå¦‚æœæˆ‘ä»¬èƒ½ç¡®ä¿nums[index]å·¦è¾¹çš„æ•°éƒ½æ¯”å®ƒå°ï¼Œé‚£ä¹ˆè¿™ä¸€éƒ¨åˆ†å°±å¯ä»¥è¢«åˆ†å‰²æ’åºï¼Œå› ä¸ºä»–ä»¬çš„æ’åºå¯¹åé¢çš„éƒ¨åˆ†ä¸å½±å“ã€‚æ‰€ä»¥éœ€è¦ä¸¤ä¸ªæ•°ç»„ï¼Œä¸€ä¸ªè®°å½•å½“å‰indexçš„å·¦è¾¹çš„maxæœ€å¤§å€¼æ˜¯å¤šå°‘ï¼Œä¸€ä¸ªè®°å½•indexçš„å³è¾¹çš„æœ€å°å€¼æ˜¯å¤šå°‘ã€‚å¦‚æœè¯´leftmax &lt;= rightminï¼Œé‚£ä¹ˆå°±å¯ä»¥åˆ†å‰²ã€‚123456789101112131415161718192021222324class Solution &#123; public int maxChunksToSorted(int[] arr) &#123; int len = arr.length; int[] l = new int[len]; l[0] = arr[0]; for (int i = 1; i &lt; len; i++) &#123; l[i] = Math.max(l[i - 1], arr[i]); &#125; int[] r = new int[len]; r[len - 1] = arr[len - 1]; for (int i = len - 2; i &gt;= 0; i--) &#123; r[i] = Math.min(arr[i], r[i + 1]); &#125; int res = 0; for (int i = 0; i &lt; len - 1; i++) &#123; if (l[i] &lt;= r[i + 1]) res++; &#125; return res + 1; &#125;&#125; 821 Shortest Distance to a CharacteråŸºæœ¬æ€è·¯ï¼šâ€œloveleetcodeâ€ â€œeâ€step1. put 0 at all position equals to e, and max at all other position we will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0]step2. scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]), we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0]step3. scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1]) we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]è§£é‡Šçš„å¾ˆæ¸…æ¥šäº†ç¬¬ä¸€éä»å·¦åˆ°å³æ‰«æï¼Œè®°å½•å½“å‰characterå·¦è¾¹æœ€è¿‘çš„å­—ç¬¦Cçš„è·ç¦»ï¼Œ+1è¡¨ç¤ºæ¯”ä¹‹å‰çš„è·ç¦»å¤šäº†ä¸€æ ¼ç¬¬ä¸€éä»å³åˆ°å·¦æ‰«æï¼Œè®°å½•å½“å‰characterå³è¾¹æœ€è¿‘çš„å­—ç¬¦Cçš„è·ç¦»123456789101112131415161718192021222324class Solution &#123; public int[] shortestToChar(String S, char C) &#123; int len = S.length(); int[] nums = new int[len]; for (int i = 0; i &lt; len; i++) &#123; if (S.charAt(i) == C) &#123; nums[i] = 0; &#125;else &#123; nums[i] = Integer.MAX_VALUE; &#125; &#125; for (int i = 0; i &lt; len - 1; i++) &#123; if (nums[i] == Integer.MAX_VALUE) &#123; continue; &#125;else &#123; nums[i + 1] = Math.min(nums[i] + 1, nums[i + 1]); &#125; &#125; for (int i = len - 1; i &gt; 0; i--) &#123; nums[i - 1] = Math.min(nums[i - 1], nums[i] + 1); &#125; return nums; &#125;&#125; 838. Push DominoesåŸºæœ¬æ€è·¯ï¼šæ­¤é¢˜å…³é”®åœ¨äºï¼Œå¦‚ä½•å°†è¿™ä¸ªæŠ½è±¡çš„é—®é¢˜è½¬åŒ–æˆä¸€ä¸ªèƒ½ç”¨ä»£ç è§£å†³çš„é—®é¢˜ã€‚ç­”æ¡ˆæ˜¯ä½¿ç”¨ä¸€ä¸ªæ•°ç»„forceï¼Œforce[i]æ¥è¡¨ç¤ºå½“å‰è¿™å—å¤šç±³è¯ºç‰Œå—åˆ°çš„æ¥è‡ªå·¦è¾¹çš„åŠ›å’Œå³è¾¹çš„åŠ›çš„å’Œã€‚ä»å·¦å¾€å³scanæ—¶ï¼Œå¤„ç†çš„æ˜¯æ¥è‡ªå³è¾¹çš„åŠ›ï¼Œå‘å³çš„åŠ›ä¼šä»å·¦å‘å³è¡°å‡ï¼ŒåŒç†ä»å³å‘å·¦å¤„ç†æ¥è‡ªå·¦è¾¹çš„åŠ› ä¸¾ä¾‹è¯´æ˜ï¼š.L.Râ€¦LR..L..æ•´ä¸ªString é•¿åº¦ä¸º14ï¼Œæ­¤æ—¶æ¨ä¸€ä¸‹ï¼ŒåŠ›çš„å¤§å°ä¸º14.step1. è¿›è¡Œä»å·¦åˆ°å³çš„scanï¼Œå¦‚æœå½“å‰å¤šç±³è¯ºç‰Œä¸ºRï¼Œé‚£ä¹ˆå®ƒå—åˆ°çš„åŠ›ä¸º14ï¼Œå®ƒå³è¾¹çš„ç‰Œå—åˆ°çš„åŠ›ä¸º13ï¼Œä»¥æ­¤ç±»æ¨ å½“é‡åˆ°ä¸€å—å¤šç±³è¯ºç‰Œä¸ºLæ—¶ï¼Œå½“å‰çš„åŠ›è¢«é‡ç½®ä¸º0ï¼ˆå‘å·¦æ¨çš„ç‰Œä¸ä¼šè¢«æ¥è‡ªå³è¾¹çš„åŠ›å½±å“ï¼‰ã€‚éœ€è¦æ³¨æ„æ¯å—ç‰Œçš„å—åŠ›ä¸ä¼šå°äº0.12æ­¤æ—¶çš„forceæ•°ç»„ä¸ºï¼š. L . R . . . L R . . L . . 0 0 0 14 13 12 11 0 14 13 12 0 0 0 step2. æ ¹æ®å’Œç¬¬ä¸€æ­¥ç›¸åŒçš„åŸç†ï¼Œå¯¹æ¯å—ç‰Œå¤„ç†æ¥è‡ªå·¦è¾¹çš„åŠ›ã€‚12æ­¤æ—¶çš„forceæ•°ç»„ä¸ºï¼š . L . R . . . L R . . L . . -13 -14 0 0 -11 -12 -13 -14 0 -12 -13 -14 0 0 step3. ç›¸åŠ åæ ¹æ®force[i]çš„æ­£è´Ÿæ€§åˆ¤æ–­å·¦å³çš„åŠ›å“ªä¸ªå¼ºï¼Œå¾—åˆ°Læˆ–Rï¼Œ0çš„è¯è¡¨ç¤ºåŠ›æŒå¹³ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String pushDominoes(String dominoes) &#123; int len = dominoes.length(); int[] force = new int[len]; int f = 0; for (int i = 0; i &lt; len; i++) &#123; char c = dominoes.charAt(i); if (c == 'R') &#123; f = len; &#125;else if (c == 'L') &#123; f = 0; &#125;else &#123; f = Math.max(f - 1, 0); &#125; force[i] = f; &#125; f = 0; for (int i = len - 1; i &gt;= 0; i--) &#123; char c = dominoes.charAt(i); if (c == 'L') &#123; f = -len; &#125;else if (c == 'R') &#123; f = 0; &#125;else &#123; f = Math.min(f + 1, 0); &#125; force[i] += f; &#125; StringBuilder sb = new StringBuilder(); for (int i : force) &#123; if (i &gt; 0) &#123; sb.append("R"); &#125;else if (i &lt; 0) &#123; sb.append("L"); &#125;else&#123; sb.append("."); &#125; &#125; return sb.toString(); &#125;&#125; 845 Longest Mountain in ArrayåŸºæœ¬æ€è·¯ï¼šç‹—å®¶é¢ç­‹ï¼Œæ‰¾æ•°ç»„ä¸­çš„å°å±±ã€‚åŸºæœ¬æ€è·¯å°±æ˜¯ç”¨ä¸¤ä¸ªarrayï¼Œä»å·¦æ‰«ææ‰¾å±±çš„å·¦åŠéƒ¨åˆ†ï¼Œå­˜ä¸‹æ¥ï¼Œä»å³æ‰«æå­˜å±±çš„å³åŠéƒ¨åˆ†ï¼Œå­˜ä¸‹æ¥ã€‚æœ€åå†ç”¨ä¸€ä¸ªarrayï¼Œä¸€è¾¹æ‹¼æ¥ä¸€è¾¹æ‰¾å‡ºæœ€å¤§çš„å±±å³°ã€‚ä¸€å…±ç”¨äº†ä¸‰ä¸ªfor loopï¼Œä¸¤ä¸ªarrayã€‚ follow upï¼šone passï¼Œno extra spaceç”¨åŒæŒ‡é’ˆï¼Œupå’Œdownåˆ†åˆ«ä»£è¡¨ä¹‹å‰çš„æ•°ç»„ï¼Œupå’Œdownå®æ—¶æ›´æ–°ã€‚å½“é‡åˆ°ä¸€åº§å±±å·²ç»èµ°å®Œæ—¶ï¼Œå°†upå’Œdowné‡ç½®ä¸º0ï¼Œæ–°çš„ä¸€åº§å±±åªæœ‰åœ¨å‰ä¸€åº§å±±èµ°å®Œä¹‹åæ‰èƒ½é‡åˆ°ã€‚å±±èµ°å®Œæœ‰ä¸¤ç§æƒ…å†µï¼š downæŒ‡é’ˆä¸ä¸º0ä¸”é‡åˆ°å¼€å§‹ä¸Šå‡çš„part å‰åä¸¤å€¼ç›¸ç­‰æ—¶ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int longestMountain(int[] A) &#123; if (A.length &lt; 3) return 0; int up = 0 , down = 0, res = 0; for (int i = 1; i &lt; A.length; i++) &#123; // downæŒ‡é’ˆä¸ä¸º0ä¸”é‡åˆ°å¼€å§‹ä¸Šå‡çš„part &amp;&amp; å‰åä¸¤å€¼ç›¸ç­‰æ—¶ã€‚ if (down &gt; 0 &amp;&amp; A[i] &gt; A[i - 1] || A[i] == A[i - 1]) &#123; down = 0; up = 0; &#125; if (A[i] &gt; A[i - 1]) up++; if (A[i] &lt; A[i - 1]) down++; if (up &gt; 0 &amp;&amp; down &gt; 0 &amp;&amp; up + down + 1 &gt; res) &#123; res = up + down + 1; &#125; &#125; return res; &#125; public int threeloops(int[] A) &#123; int len = A.length; int[] l = new int[len]; Arrays.fill(l, 0); int[] r = new int[len]; Arrays.fill(r, 0); for (int i = 1; i &lt; len; i++) &#123; if (A[i] &gt; A[i - 1]) &#123; l[i] = l[i - 1] + 1; &#125; &#125; for (int i = len - 2; i &gt;= 0; i--) &#123; if (A[i + 1] &lt; A[i]) &#123; r[i] = r[i + 1] + 1; &#125; &#125; int res = 0; for (int i = 0; i &lt; len; i++) &#123; if (l[i] != 0 &amp;&amp; r[i] != 0) res = Math.max(res, l[i] + r[i]); &#125; return res != 0 ? res + 1 : 0; &#125;&#125;]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°å­¦è®¡ç®—å’Œä¸€äº›æ•°å­¦é—®é¢˜]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[æ€»ç»“LCä¸­å‡ºç°çš„åŒ…æ‹¬çš„æ•°å­¦è®¡ç®—é—®é¢˜ï¼ŒåŒ…æ‹¬å®ç°é™¤æ³•ï¼Œå®ç°pow(), å®ç°sqrt(), å®ç°è®¡ç®—å™¨å’Œä¸€äº›åæ•°å­¦çš„é¢˜ æ•°å­¦è®¡ç®—29. Divide Two Integersè¿™é¢˜æœ€è¿‘ç‹—å®¶å‡ºè¿‡ï¼Œè™½ç„¶æ˜¯FB tagã€‚å®ç°é™¤æ³•åŸºæœ¬æ€è·¯ï¼š å¤„ç†corner case:é™¤æ•°ä¸º0ï¼Œè¿”å›MAX_VALUEè¢«é™¤æ•°ä¸ºMIN_VALUEï¼Œé™¤æ•°ä¸º-1ï¼Œä¼šè¶Šç•Œï¼Œæ‰€ä»¥äººå·¥è¿”å›MAX_VALUEï¼Œé™¤æ•°ä¸º1åˆ™è¿”å›åŸå€¼ å°†é™¤æ•°è¢«é™¤æ•°è½¬ä¸ºlongï¼Œé¿å…è®¡ç®—è¿‡ç¨‹ä¸­è¶Šç•Œ ä½¿ç”¨ &lt;&lt; ç¬¦å·ï¼ŒA &lt;&lt; B è¡¨ç¤º A * 2çš„Bæ¬¡æ–¹ ä½¿ç”¨int signalè¡¨ç¤ºç»“æœçš„æ­£è´Ÿå·ï¼Œè¢«é™¤æ•°å’Œé™¤æ•°éƒ½å…ˆå¤„ç†ä¸ºæ•´æ•°ï¼Œç”¨signalè¡¨ç¤ºç»“æœçš„æ­£è´Ÿ ä¸¾ä¾‹ï¼š32 / 312345678910loop: 32 &gt; 3 * \2^0 -&gt; 32 &gt; 3 * 2^1 -&gt; 32 &gt; 3 * 2^2 - &gt; 32 &gt; 3 * 2^3until: 32 &lt; 3 * 2^4ï¼Œç›®å‰ä¸€å…±ä½¿ç”¨äº†2^3ä¸ª 3å°†è¢«é™¤æ•°å‡å»ç›®å‰å·²ç»è®¡ç®—å¥½çš„éƒ¨åˆ†ï¼Œå³32 - 3 * 2^3 = 32 - 24 = 8, æ­¤æ—¶res = 8loop: 8 &gt; 3 * 2^0 -&gt; 8 &gt; 3 * 2^1until: 8 &gt; 3 * 2^2å°†è¢«é™¤æ•°å‡å»ç›®å‰å·²ç»è®¡ç®—å¥½çš„éƒ¨åˆ†ï¼Œå³8 - 3 * 2^1 = 8 - 6 = 2, æ­¤æ—¶res = 10æ­¤æ—¶è¢«é™¤æ•°å°äºé™¤æ•°ï¼Œè·³å‡ºå¾ªç¯ã€‚32 / 3 = 10 ä»£ç 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 0) &#123; return Integer.MAX_VALUE; &#125; if (dividend == Integer.MIN_VALUE) &#123; if (divisor == -1) return Integer.MAX_VALUE; else if (divisor == 1) return Integer.MIN_VALUE; &#125; int signal = 1; long d1 = (long) dividend; long d2 = (long) divisor; if (d1 &lt; 0) &#123; d1 = -d1; signal = -signal; &#125; if (d2 &lt; 0) &#123; d2 = -d2; signal = -signal; &#125; int res = 0; while (d1 &gt;= d2) &#123; int count = 0; while (d1 &gt;= d2 &lt;&lt; count) &#123; count++; &#125; res += (1 &lt;&lt; (count - 1)); d1 -= (d2 &lt;&lt; (count - 1)); &#125; return res * signal; &#125;&#125; 69. Sqrt(x)åŸºæœ¬æ€è·¯:å®ç°å¼€æ›´å·ï¼Œ é€šè¿‡äºŒåˆ†å®ç° è¿™é¢˜é¦–å…ˆè¦é¿å…è¶Šç•Œã€‚å› æ­¤mid * mid &gt; x åº”è¯¥å†™æˆ mid &gt; x / mid. è¿™æ—¶å€™å°±è¦é¿å…mid = 0ã€‚å½“right - left = 1æ—¶ï¼Œmid = leftï¼ˆright = 1, left = 0, mid = 0ï¼‰æ‰€ä»¥leftä¸èƒ½ä»0å¼€å§‹ã€‚æ‰€ä»¥æœç´¢èŒƒå›´ç¡®å®šä¸º1 ~ xï¼ˆxçš„å¹³æ–¹å¿…å®šå¤§äºxï¼‰ æ¥ä¸‹æ¥è¦å¤„ç†çš„é—®é¢˜æ˜¯ï¼Œå¦‚æœæ‰¾ä¸åˆ°target sqrtï¼Œè¯¥æ€ä¹ˆè¿”å›å€¼ã€‚ç”¨7ä¸¾ä¾‹æœç´¢åŒºé—´åˆ°è¾¾[2,3]æ—¶ï¼Œmid = 2, left = mid + 1 = 3.æœç´¢åŒºé—´åˆ°è¾¾[3,3]æ—¶ï¼Œmid = 3, left = 3, right = 3 - 1 = 2ã€‚è·³å‡ºå¾ªç¯ã€‚å¯ä»¥å‘ç°midå…¶å®æ˜¯åˆšå¥½å¹³æ–¹åå¤§äºxçš„é‚£ä¸ªå€¼ï¼Œå› æ­¤æˆ‘ä»¬è¿”å›çš„right = mid - 1å°±æ˜¯è§£ã€‚ è¿™æ—¶å€™è¦è€ƒè™‘ä¸‹Corner Caseï¼Œæ¯”å¦‚inputæ˜¯0æˆ–è€…2147483647ã€‚é€»è¾‘èµ°å®Œå‘ç°æ²¡å•¥é—®é¢˜ã€‚ å¦‚æœé¢è¯•å®˜è¦æ±‚ç²¾åº¦ï¼Œé‚£ä¹ˆè¿™é¢˜æœ€å¥½ä½¿ç”¨ç‰›é¡¿æ³•æ¥å®ç°ã€‚ 1234567891011121314151617class Solution &#123; public int mySqrt(int x) &#123; if(x == 0) return 0; int l = 1, r = x; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (mid &gt; x / mid) &#123; r = mid - 1; &#125; else if (mid == x / mid) &#123; return mid; &#125; else&#123; l = mid + 1; &#125; &#125; return r; &#125;&#125; 50. Pow(x, n)åŸºæœ¬æ€è·¯: å®ç°x^nï¼Œå¾ˆä¸å–œæ¬¢è¿™é¢˜ï¼Œå› ä¸ºconner caseå¤ªçƒ¦äº†ã€‚åŸºäºé€’å½’å®ç° å› ä¸º x çš„næ¬¡æ–¹ = x çš„n/2æ¬¡æ–¹ * xçš„n/2æ¬¡æ–¹ï¼Œæ‰€ä»¥recursionå°±å‡ºæ¥äº†ã€‚oddå°±æ˜¯æ‹¿ä¸€ä¸ªå‡ºæ¥å†/2ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ° ç„¶åæ˜¯å¤„ç†n &lt; 0çš„æƒ…å†µï¼Œå°±æ˜¯è¿›å…¥é€’å½’å‰æŠŠnå–åï¼Œx = 1/x è¿™é‡Œå‡ºç°é—®é¢˜ï¼Œif n = Inetegr.MIN_VALUEï¼Œå–åå°±overflowï¼Œå› æ­¤è¦åšä¸€ä¸ªå¤„ç† æ³¨æ„å¤„ç†nä¹‹åä¹Ÿä¸è¦å¿˜äº†x;å› ä¸ºnä»-2147483648 å˜æˆäº† 214748364747ï¼Œæ­£è´Ÿä¼šæœ‰å½±å“ï¼šx = x &gt; 0 ? 1.0 / x : -(1.0 / x);12345678910111213141516171819202122class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; if (n &lt; 0) &#123; if (n == Integer.MIN_VALUE) &#123; n = -(n + 1); x = x &gt; 0 ? 1.0 / x : -(1.0 / x); &#125; else &#123; n = -n; x = 1.0 / x; &#125; &#125; if (n % 2 == 0) &#123; return myPow(x * x, n / 2); &#125; else &#123; return x * myPow(x * x, n /2); &#125; &#125;&#125; 224. Basic CalculatoråŸºæœ¬æ€è·¯ï¼šå®ç°ä¸€ä¸ªè®¡ç®—å™¨ï¼Œè¿ç®—ç¬¦å·åŒ…æ‹¬+, -, ()ã€‚ æ•°å­¦é—®é¢˜31. Next Permutationé¢˜æ„ï¼šç»™ä½ ä¸€ä¸ªæ•°æ¯”å¦‚158476531ï¼Œè®©ä½ æ‰¾å‡ºä¸€ä¸ªMath.min(æ‰€æœ‰æ¯”å®ƒå¤§çš„æ•°)ï¼Œè¿™é‡Œçš„æ•°åªèƒ½æ˜¯åŸæ•°çš„permutationã€‚åŸºæœ¬æ€è·¯ï¼šdecreasingçš„éƒ¨åˆ†æ˜¯æ²¡æœ‰æ¯”å®ƒå¤§çš„permutationï¼Œreverseè¿‡åèƒ½ä¿è¯è¿™æ®µæ˜¯æœ€å°çš„è¿™ä¸ªsolutionçš„å›¾è§£åšçš„å¾ˆæ£’ï¼Œå¯ä»¥çœ‹çœ‹å¸®åŠ©åŠ æ·±å°è±¡ã€‚https://leetcode.com/problems/next-permutation/solution/step1. ä»å°¾é“å¤´æ‰«æï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤„äºä¸æ˜¯decreasingåºåˆ—çš„æ•°numï¼Œæ¯”å¦‚158476531å°±æ˜¯4.step2. å¯¹äºnumï¼Œä»numå¼€å§‹å‘å³æ‰«æï¼Œæ‰¾åˆ°almost larger than numçš„æ•°ï¼Œä¾‹å­ä¸­å°±æ˜¯5step3. äº¤æ¢4ï¼Œ5çš„ä½ç½®ï¼Œå¾—åˆ°158576431step4. reverse decreasing çš„é‚£éƒ¨åˆ†ï¼Œå¾—åˆ°1585134671234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length, index = -1; for (int i = len - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; index = i; break; &#125; &#125; if (index == -1) &#123; reverse(nums, 0, len - 1); return; &#125; int index1 = len - 1; for (int i = index + 1; i &lt; len; i++) &#123; if (nums[i] &lt;= nums[index]) &#123; index1 = i - 1; break; &#125; &#125; swap(nums, index, index1); reverse(nums, index + 1, len - 1); &#125; public void reverse(int[] nums, int i, int j) &#123; while (i &lt; j) &#123; swap(nums, i ,j); i++; j--; &#125; &#125; public void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] =temp; &#125;&#125; 238. Product of Array Except Selfï¼ˆè„¸å®¶tagï¼‰åŸºæœ¬æ€è·¯ï¼š èƒ½ç”¨é™¤æ³•çš„è¯å¤ªç®€å•äº†ï¼Œç›´æ¥è¿›å…¥ä¸èƒ½çš„æƒ…å†µ å…ˆç”¨ä¸€ä¸ªres[]æ¥å­˜å‰ç¼€ç§¯ï¼Œä»å·¦å¾€å³ï¼Œres[0] = 1, res[i] = res[i - 1] nums[i - 1]arr 1 2 3 4res 1 1 2 6å› ä¸º4æ˜¯æ²¡ä¹˜çš„é‚£ä¸ªæ•°ï¼Œæ‰€ä»¥æ­¤æ—¶res[3]å°±æ˜¯4å¯¹åº”çš„å€¼å¼•å…¥ä¸€ä¸ªå˜é‡indexï¼Œæ­¤æ—¶index = 1res[3] = 6 index = 6, index = 1 4res[2] = 2 index = 8, index = 4 3res[1] = 1 index = 12, index = 12 2res[0] = 1 index = 24, index = 24 * 1 123456789101112131415public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123;//pre product int[] res = new int[nums.length]; res[0] = 1; for (int i = 1; i &lt; nums.length; i++)&#123; res[i] = res[i - 1] * nums[i - 1]; &#125; int index = 1; for (int i = nums.length - 1; i &gt;= 0; i--)&#123;// ä»å³è¾¹å†å¾ªç¯ä¸€æ¬¡ï¼Œres[n] = res[n] * the product of right numbers res[i] = res[i] * index; index = index * nums[i]; &#125; return res; &#125;&#125; 279. Perfect SquaresåŸºæœ¬æ€è·¯: ç‹—å®¶tagä¸‹çš„é¢˜ï¼Œå€¼å¾—ä¸€åšï¼Œå®Œå…¨å¹³æ–¹æ•° 247. Strobogrammatic Number II(ç‹—å®¶é¢ç­‹é¢˜)åŸºæœ¬æ€è·¯ï¼šstep1 é€‰å®šä¸€ä¸ªcenterï¼Œç„¶ååœ¨å·¦å³appendå¯¹ç§°çš„æ•°ã€‚step2 å¦‚æœæ˜¯å¶æ•°ï¼Œåˆ™centerä» â€œâ€ å¼€å§‹ï¼Œå¦‚æœæ˜¯å¥‡æ•°ï¼Œcenterä»0, 1, 8å¼€å§‹ã€‚step3 æœ€åä¸€æ¬¡appendæ—¶ï¼Œè¦æ³¨æ„ä¸èƒ½åŠ 0ï¼Œè¿™æ ·æ˜¯meaninglessçš„ã€‚ 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;String&gt; findStrobogrammatic(int n) &#123; return helper(n, n); &#125; public List&lt;String&gt; helper(int n, int m) &#123; // odd if (n == 0) return new ArrayList&lt;String&gt;(Arrays.asList("")); // even if (n == 1) return new ArrayList&lt;String&gt;(Arrays.asList("0", "1", "8")); List&lt;String&gt; center = helper(n - 2, m); List&lt;String&gt; res = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; center.size(); i++) &#123; String cur = list.get(i); // avoid add 00 in the last step, becasue it's meaningless if (n != m) res.add("0" + cur + "0"); res.add("1" + cur + "1"); res.add("6" + cur + "9"); res.add("8" + cur + "8"); res.add("9" + cur + "6"); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>æ•°å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeä¸­çš„Word,Stringé¢˜]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode%E4%B8%AD%E7%9A%84Word%E9%A2%98%2F</url>
    <content type="text"><![CDATA[å¾ˆå¤šç»å…¸é¢˜ï¼Œå…¶å®ä¸éš¾æƒ³ï¼Œä½†æ˜¯å†™èµ·æ¥æœ‰å¾ˆå¤šè¦æ³¨æ„çš„ä¸œè¥¿ï¼ŒæŠŠæ€è·¯å†™ä¸€ä¸‹ï¼Œé¢è¯•æ—¶å€™è§£é‡Šèµ·æ¥ä¹Ÿæ›´é¡ºã€‚ 126. Word Ladder IIåŸºæœ¬æ€è·¯ï¼š1.å…ˆç”¨BFSè¿›è¡Œæ„å›¾ï¼Œè¿æ¥æ¯ä¸ªå•è¯ã€‚ä½¿ç”¨ä¸¤ä¸ªHashMapï¼špaths &amp; levelsã€‚ paths ç”¨æ¥å­˜æ¯ä¸ªwordå’Œå®ƒçš„childrençš„å…³ç³»ï¼Œæ˜¯Map&lt;String, List&gt;, ç”¨äºä¹‹åDFSéå† levels ç”¨æ¥å­˜æ¯ä¸ªwordå’Œå½“å‰levelï¼Œæˆ–è€…è¯´stepçš„å…³ç³»ï¼Œæ˜¯Map&lt;String, Integer&gt; 2.ä½¿ç”¨levelsçš„åŸå› ï¼š1234567 hit level 1 / \hot lit level 2 \ / \ lot lid level 3 \ / lod level 4 å½“BFSåˆ°è¾¾hotï¼ˆå³queueä¸­pollå‡ºhotï¼‰æ—¶ï¼Œlotä½œä¸ºä¸€ä¸ªå¯é€‰childå·²ç»è¢«æ”¾å…¥visited set ä½†lotä¹Ÿæ˜¯litçš„å¯é€‰childï¼Œè€Œå› ä¸ºæ­¤æ—¶lot has been visitedï¼Œlotä¸ä¼šè¢«åŠ å…¥litçš„children listã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦levels Now levels contains key lotï¼Œand level of lot is 3ï¼ˆåœ¨hoté‚£ä¸€æ­¥å­˜çš„ï¼‰ so if level of lot == level of lit + 1ï¼Œé‚£ä¹ˆlotå°±å¯ä»¥è¢«åŠ å…¥litçš„children list 3.å¦‚æœå·²ç»æ‰¾åˆ°endï¼ˆfount == trueï¼‰ï¼Œä¸è¦æŠŠendæ”¾åˆ°visitedä¸­ï¼Œç”¨æ¥é¿å…å…¶ä»–çš„è·¯å¾„æ— æ³•æ·»åŠ endåˆ°è‡ªå·±çš„listä¸­ã€‚ 4.DFSéå†pathsï¼Œé€šè¿‡backtrackingè¾“å‡ºæ‰€æœ‰çš„å¯èƒ½ç­”æ¡ˆã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String begin, String end, List&lt;String&gt; wordList) &#123; Map&lt;String, List&lt;String&gt; paths = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; levels = new HashMap&lt;&gt;(); HashSet&lt;String&gt; dic = new HashSet&lt;&gt;(wordList); HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); int level = 1; boolean found = false; q.offer(begin); visited.add(begin); levels.put(begin, level); while (!q.isEmpty() &amp;&amp; !found) &#123; int size = q.size(); for (int index = 0; index &lt; size; index++) &#123; String cur = q.poll(); for (int i = 0; i &lt; cur.length(); i++) &#123; char[] ch = cur.toCharArray(); for (char c = 'a'; c &lt;= 'z'; c++) &#123; ch[i] = c; String temp = new String(ch); if (!visited.contains(temp) &amp;&amp; dic.contains(temp)) &#123; if (temp.equals(end)) &#123; found = true; &#125; if (!paths.containsKey(cur)) &#123; paths.put(cur, new ArrayList&lt;String&gt;()); &#125; paths.get(cur).add(temp); q.offer(temp); // if we have found the shortest path, don't add end word to visited set // Because the next word still need to use this if condition to make path if (!found) visited.add(temp); levels.put(temp, level + 1); &#125;else if (levels.containsKey(temp))&#123; if (levels.get(temp) == levels.get(cur) + 1) &#123; // ä¹‹å‰çš„ifä¸­ï¼Œå¯èƒ½æ²¡æœ‰æŠŠcurå­˜åˆ°pathsé‡Œï¼Œæ‰€ä»¥è¿™é‡Œä¹Ÿè¦åšä¸€ä¸ªåˆ¤æ–­ if (!paths.containsKey(cur)) &#123; paths.put(cur, new ArrayList&lt;String&gt;()); &#125; paths.get(cur).add(temp); &#125; &#125; &#125; &#125; &#125; level++; &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(begin); dfs(res, list, begin, end, paths, levels); return res; &#125; public void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, String cur, String end, Map&lt;String, List&lt;String&gt;&gt; paths, Map&lt;String, Integer&gt; levels) &#123; if (cur.equals(end)) &#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; // need check since somtimes we can't find path to reach the endWord if (!paths.containsKey(cur) || paths.get(cur).size() == 0) &#123; return; &#125; for (String next : paths.get(cur)) &#123; if (levels.get(cur) + 1 == levels.get(next)) &#123; list.add(next); dfs(res, list, next, end, paths, levels); list.remove(list.size() - 1); &#125; &#125; &#125;&#125; 140. Word Break IIä»¥ä¸ºè‡ªå·±åšè¿‡ï¼Œå±…ç„¶æ²¡åšè¿‡ã€‚ã€‚ã€‚ã€‚]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
      <tags>
        <tag>å­—ç¬¦ä¸²å¤„ç†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swapç›¸å…³çš„é¢˜]]></title>
    <url>%2F2018%2F10%2F23%2FSwap%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©å’Œä¸€ä¸ªå‚»é€¼äºšéº»recruiteræ‰“ç”µè¯ï¼Œå¦ˆçš„é—®äº†ä¸‰ä¸ªé—®é¢˜ç›´æ¥å¹äº†ä¸ªæ°”æŒ‚ç”µè¯äº†ã€‚æ˜æ˜æ˜¯ä¸ªç™½çš®å£éŸ³è¿˜æ²¡ä¸Šæ¬¡çš„é»‘å“¥æ¥çš„æ¸…æ¥šã€‚æˆ‘é—®ä»–ä½ è§‰å¾—æˆ‘è®²çš„æ¸…æ¥šä¹ˆï¼Œä»–è¯´ä½ è‡ªå·±æ¸…æ¥šå°±è¡Œã€‚ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ æˆ‘çœŸæ˜¯é†‰äº†ã€‚åˆ·é¢˜äº†åˆ·é¢˜äº†ã€‚. éLCçš„é¢˜Minimum number of swaps required to sort an arrayåŸºæœ¬æ€è·¯ï¼šhttps://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_r=internal-searchå‡ºç°åœ¨ç‹—å®¶çš„é¢è¯•ä¸­ã€‚æ¶‰åŠåˆ°ç½®æ¢ç¾¤ã€‚ï¼ˆç”¨LC854çš„æ€è·¯åšBFSä¹Ÿèƒ½è§£å¤§æ¦‚ï¼‰ä½†æ˜¯ç½®æ¢ç¾¤çš„æ—¶ç©ºé—´å¤æ‚åº¦éƒ½åªè¦Onã€‚ Leetcode801. Minimum Swaps To Make Sequences IncreasingåŸºæœ¬æ€è·¯ï¼šä¸çœ‹ç­”æ¡ˆä¸ä¼šåšçš„DPé¢˜ã€‚ é¦–å…ˆæ˜ç¡®é¢˜ç›®ä¿è¯å¿…å®šæœ‰è§£ï¼Œé‚£ä¹ˆå¯¹äºæ•°ç»„Aå’ŒBï¼Œåœ¨ i-1 å’Œ i çš„ä½ç½®ä¸Šåªæœ‰ä¸¤ç§æƒ…å†µç¬¬ä¸€ç§ï¼šA[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]ç¬¬äºŒç§ï¼šA[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]åŸå› ä¹Ÿå¾ˆç®€å•ï¼Œå¦‚æœåŸæœ¬çš„åºåˆ—ä¸æ˜¯é€’å¢çš„ï¼Œé‚£ä¹ˆäº¤æ¢åå¿…é¡»é€’å¢ã€‚ä¾‹å¦‚ï¼š3 5 4ï¼Œå‘ç°4 &lt; 5ï¼Œ ä¸æ»¡è¶³ç¬¬ä¸€ä¸ªconditionï¼Œé‚£ä¹ˆå°±å¾—æ»¡è¶³ç¬¬äºŒä¸ªconditionï¼Œä¸ç„¶æ²¡æ³•ä¿è¯ä¸€å®šæœ‰ç­”æ¡ˆã€‚2 3 7æ³¨æ„è¿™ä¸¤ä¸ªæ¡ä»¶æ˜¯å¯ä»¥åŒæ—¶æ»¡è¶³çš„ï¼Œå› æ­¤å¿…é¡»ç”¨ä¸¤ä¸ªifæ¥åˆ¤æ–­ã€‚ ä½¿ç”¨ä¸¤ä¸ªæ•°ç»„ï¼Œswap å’Œ keepï¼Œswapè¡¨ç¤ºå½“å‰ä½ç½®äº¤æ¢ï¼Œkeepè¡¨ç¤ºå½“å‰ä½ç½®ä¸äº¤æ¢ã€‚1234567891011121314151617181920212223242526272829303132class Solution &#123; public int minSwap(int[] A, int[] B) &#123; int len = A.length; int[] swap = new int[len]; int[] keep = new int[len]; // è¿™å„¿æœ‰ä¸ªå°trickï¼Œå°±æ˜¯condition 1 ä¸æ»¡è¶³çš„æƒ…å†µä¸‹ï¼Œswap[i]çš„å€¼å…¶å®å°±æ˜¯keep[i - 1] + 1 // æ‰€ä»¥å¾—ä¿è¯æ­¤æ—¶swap[i]æ˜¯nï¼Œè¿™æ ·å°±èƒ½å–åˆ°æƒ³è¦çš„å€¼ // æ‰€ä»¥è¿™é‡Œçš„èµ‹å€¼æ˜¯å¾ˆæœ‰æ„ä¹‰çš„ for (int i = 0; i &lt; len; i++) &#123; swap[i] = i; keep[i] = i; &#125; swap[0] = 1; // å·²ç»äº¤æ¢äº†ä¸‹æ ‡0çš„ä¸¤ä¸ªelementï¼Œæ—¢ç„¶äº¤æ¢äº†å°±è¦ +1, è¿™é‡Œäº¤æ¢ä¸å½±å“ keep[0] = 0; // æ²¡äº¤æ¢ for (int i = 1; i &lt; len; i++) &#123; // è¿™é‡Œå…¶å®åˆ¤æ–­çš„æ˜¯éƒ½æ¢å’Œéƒ½ä¸æ¢ if (A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]) &#123; // i - 1é‚£ç»„æ¢äº†ï¼Œä¸ºäº†ä¿è¯increasingï¼Œiè¿™ç»„ä¹Ÿå¾—æ¢ï¼Œå› ä¸ºæ¢äº†æ‰€ä»¥ + 1 swap[i] = swap[i - 1] + 1; // i - 1é‚£ç»„æ²¡æ¢ï¼Œæ‰€ä»¥iè¿™ç»„ä¹Ÿä¸ç”¨æ¢ keep[i] = keep[i - 1]; &#125; if (A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]) &#123; // å†³å®šæ¢ï¼Œå› ä¸ºi-1é‚£ç»„å’Œiè¿™ç»„éƒ½æ¢çš„æƒ…å†µåœ¨ä¹‹å‰å·²ç»è®¡ç®—è¿‡äº†ï¼Œæ‰€ä»¥å’Œi - 1æ²¡æ¢ï¼Œä½†æ˜¯iæ¢çš„æƒ…å†µæ¯”è¾ƒã€‚ swap[i] = Math.min(swap[i], keep[i - 1] + 1); // å†³å®šä¸æ¢ï¼Œå› ä¸ºi-1é‚£ç»„å’Œiè¿™ç»„éƒ½ä¸æ¢çš„æƒ…å†µåœ¨ä¹‹å‰å·²ç»è®¡ç®—è¿‡äº†ï¼Œæ‰€ä»¥å’Œi - 1æ¢ï¼Œä½†æ˜¯ä¸æ¢çš„æƒ…å†µæ¯”è¾ƒã€‚ keep[i] = Math.min(swap[i - 1], keep[i]); &#125; &#125; return Math.min(swap[len - 1], keep[len - 1]); &#125;&#125; 854. K-Similar StringsåŸºæœ¬æ€è·¯ï¼šå¯¹äºString Aï¼Œæœ€å°‘äº¤æ¢å‡ æ¬¡å¯ä»¥å¾—åˆ°String Bã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int kSimilarity(String A, String B) &#123; if (A.equals(B)) return 0; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.offer(A); HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); visited.add(A); int step = 0; while (!q.isEmpty()) &#123; int len = q.size(); step++; for (int index = 0; index &lt; len; index++) &#123; String s = q.poll(); int i = 0; while (s.charAt(i) == B.charAt(i)) &#123; i++; &#125; for (int j = i + 1; j &lt; s.length(); j++) &#123; if (s.charAt(j) == B.charAt(j) || s.charAt(i) != B.charAt(j)) &#123; continue; &#125; String cur = swap(s, i, j); if (cur.equals(B)) return step; if (visited.add(cur)) &#123; q.offer(cur); &#125; &#125; &#125; &#125; return step; &#125; public String swap(String s, int i, int j) &#123; char[] ch = s.toCharArray(); char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp; return new String(ch); &#125;&#125; 670. Maximum Swap]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mapï¼ŒHashå’ŒMapçš„é¢˜]]></title>
    <url>%2F2018%2F09%2F06%2FJava%E4%B8%AD%E7%9A%84Map%2F</url>
    <content type="text"><![CDATA[ç®—æ˜¯ä¸€ä¸ªä¸Šè¯¾æ€»ç»“å§ï¼Œå¤ä¹ å¤ä¹ ä¸€ä¸‹Mapï¼Œç­‰é¢è¯•çš„æ—¥å­æœ‰ç‚¹éš¾ç†¬çš„ã€‚è¿™ä¸ªæ€»ç»“çš„æ¯”æˆ‘è‡ªå·±åˆ°ä½ï¼ŒåŒ…æ‹¬collisionï¼Œdouble sizeï¼Œhash functionï¼Œequals functionç­‰ç­‰https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E4%B8%80%E6%A6%82%E8%A7%88 å¸¸ç”¨çš„MapTreeMapï¼šåŸºäºçº¢é»‘æ ‘å®ç°ã€‚æŸ¥æ‰¾åˆ é™¤O(logN) HashMapï¼šåŸºäºå“ˆå¸Œè¡¨å®ç°ã€‚æŸ¥æ‰¾åˆ é™¤O(1) HashTableï¼šå’Œ HashMap ç±»ä¼¼ï¼Œä½†å®ƒæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œè¿™æ„å‘³ç€åŒä¸€æ—¶åˆ»å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶å†™å…¥ HashTable å¹¶ä¸”ä¸ä¼šå¯¼è‡´æ•°æ®ä¸ä¸€è‡´ã€‚å®ƒæ˜¯é—ç•™ç±»ï¼Œä¸åº”è¯¥å»ä½¿ç”¨å®ƒã€‚ç°åœ¨å¯ä»¥ä½¿ç”¨ ConcurrentHashMap æ¥æ”¯æŒçº¿ç¨‹å®‰å…¨ï¼Œå¹¶ä¸” ConcurrentHashMap çš„æ•ˆç‡ä¼šæ›´é«˜ï¼Œå› ä¸º ConcurrentHashMap å¼•å…¥äº†åˆ†æ®µé”ã€‚ LinkedHashMapï¼šä½¿ç”¨åŒå‘é“¾è¡¨æ¥ç»´æŠ¤å…ƒç´ çš„é¡ºåºï¼Œé¡ºåºä¸ºæ’å…¥é¡ºåºæˆ–è€…æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆLRUï¼‰é¡ºåºã€‚ HashMapå’ŒHashTableçš„åŒºåˆ«HashTable ä½¿ç”¨ synchronized æ¥è¿›è¡ŒåŒæ­¥ã€‚HashMap å¯ä»¥æ’å…¥é”®ä¸º null çš„ Entryã€‚HashMap è¿­ä»£å™¨æ˜¯ fail-fast è¿­ä»£å™¨ã€‚HashMap ä¸èƒ½ä¿è¯éšç€æ—¶é—´çš„æ¨ç§» Map ä¸­çš„å…ƒç´ æ¬¡åºæ˜¯ä¸å˜çš„ã€‚ å¦‚ä½•å®ç°hashæ–¹æ³•A long time ago, I bought a data structures book off the bargain table for $1.25. In it, the explanation for a hashing function said that it should ultimately mod by a prime number because of â€œthe nature of mathâ€.What do you expect from a $1.25 book?Anyway, Iâ€™ve had years to think about the nature of math, and still canâ€™t figure it out. ç¬‘å°¿ï¼Œä½†æ˜¯ç¡®å®æœ‰å¾ˆå¤šäººå’Œæˆ‘ä¸€æ ·ç–‘æƒ‘ä¸ºä»€ä¹ˆhashæ—¶å€™è¦é€‰æ‹©prime numberï¼Œæ˜¯å› ä¸ºæ•°å­¦çš„æœ¬è´¨ä¹ˆã€‚ the size of buckets is a power of 2, so use prime number can reduce collision. Becasue people usually compute index of each bucket based on hashcode % size. It turns out that â€œbecause of the nature of mathsâ€, if the constant used in the hash, and the number of buckets, are coprime, then collisions are minimised in some common cases. Leetcodeçš„ç›¸å…³é¢˜ç›®187. Repeated DNA Sequencesword pattern &amp; word pattern II560. Subarray Sum Equals KåŸºæœ¬æ€è·¯ï¼šç”¨HashMapå»maintainå‰ç¼€å’Œï¼Œif (map.containsKey(å½“å‰sum - k))ï¼ŒresåŠ ä¸Šå¯¹åº”çš„å€¼è¦æ³¨æ„å­˜åœ¨corner caseï¼šnums[0] == targetæ­¤æ—¶éœ€è¦ç°åœ¨mapä¸­æ”¾å…¥ä¸€ä¸ª(0, 1)123456789101112131415class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int sum = 0, res = 0; map.put(0, 1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum - k)) &#123; res += map.get(sum - k); &#125; map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return res; &#125;&#125; 791. Custom Sort Stringï¼ˆç‹—å®¶é¢ç­‹é¢˜ï¼‰åŸºæœ¬æ€è·¯ï¼šå…ˆåˆ†ç±»åˆ°HashMapï¼Œé—®é¢˜æ˜¯å¯¹String Aï¼Œæ ¹æ®String Bçš„é¡ºåºæ’åºã€‚step1: ç”¨ä¸€ä¸ªmapæˆ–è€…freq[]æ•°ç»„æŠŠéœ€è¦æ’åºçš„Stringçš„each characterå­˜è¿›å»ã€‚step2: æ‰«æString Bï¼Œå¦‚æœå½“å‰characterä¸ä¸ºç©ºï¼Œåˆ™ç”¨ä¸€ä¸ªwhile loopç›´æ¥æŠŠå­˜å…¥çš„characterå…¨éƒ¨appendã€‚step3: æ ¹æ®å­—æ¯è¡¨é¡ºåºæ‰«æä¸€éfreq[], å¦‚æœä»æœ‰characterå­˜åœ¨ï¼ŒåŒstep2. follow upï¼šString A ç‰¹åˆ«é•¿ï¼Œå¦‚ä½•mapreduceã€‚åŸºæœ¬æ€è·¯ï¼šåˆ†æ®µå¤„ç†ã€‚å¾—åˆ°å¤„ç†å®Œçš„String listã€‚å¯¹è¿™ä¸ªlistè¿›è¡Œmergeï¼Œæ€è·¯å’Œmerge k sorted listç›¸åŒã€‚12345678910111213141516171819202122class Solution &#123; public String customSortString(String S, String T) &#123; int[] freq = new int[26]; for (char c : T.toCharArray()) &#123; freq[c - 'a']++; &#125; StringBuilder sb = new StringBuilder(); for (char c : S.toCharArray()) &#123; while (freq[c - 'a'] &gt; 0) &#123; sb.append(c); freq[c - 'a']--; &#125; &#125; for (char c = 'a'; c &lt;= 'z'; c++) &#123; while (freq[c - 'a'] &gt; 0) &#123; sb.append(c); freq[c - 'a']--; &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2018%2F08%2F27%2FDynamic%20Programming%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©å¬äº†Casablancaï¼Œç‰¹åˆ«æœ‰è§¦åŠ¨ã€‚åŠ ä¸Šå·¥å¡ä¹Ÿæ‰¹äº†ï¼Œè¿˜æ˜¯è›®å¿«ä¹çš„(æœ€è¿‘æœ€å¿«ä¹çš„ä¸€å¤©)ã€‚ ä¸Šäº†è¯¾ï¼Œå¤ä¹ ä¸€ä¸‹ã€‚åŠ¨æ€è§„åˆ’çš„æ ¸å¿ƒå°±æ˜¯çŠ¶æ€çš„è½¬ç§»ï¼Œè€ŒçŠ¶æ€çš„è½¬ç§»é€šè¿‡çŠ¶æ€è½¬ç§»æ–¹ç¨‹å’Œç›¸å¯¹åº”çš„æ•°æ®ç»“æ„æ¥è¡¨ç°ã€‚ é€šè¿‡é¢˜ç›®åº”è¯¥æ›´å¥½ç†è§£ã€‚å…ˆä»LCéƒ½æ²¡å…´è¶£æ”¾çš„åŸºæœ¬é¢˜ç›®å¼€å§‹ï¼ˆæœ‰äº›é¢˜å±…ç„¶æœ‰ï¼Œå¾ˆææ€–ï¼‰ã€‚ åŸºæœ¬é¢˜LCS(Longest Common Subsequence)LCS for input Sequences â€œABCDGHâ€ and â€œAEDFHRâ€ is â€œADHâ€ of length 3.LCS for input Sequences â€œAGGTABâ€ and â€œGXTXAYBâ€ is â€œGTABâ€ of length 4. 1234567891011121314151617181920212223public class LCS &#123; public static int lcs(String a, String b) &#123; int m = a.length(); int n = b.length(); char[] A = a.toCharArray(); char[] B = b.toCharArray(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 0; &#125; else &#123; if (A[i - 1] == B[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; Longest Increasing Subsequence(LC300)åŸºæœ¬æ€è·¯ï¼šç”¨DPè§£å°±æ˜¯n2ã€‚follow upï¼šèƒ½æ›´å¿«ä¹ˆï¼ŸDPçš„è¿‡ç¨‹ä¸­å¯ä»¥2åˆ†ï¼Œè¾¾åˆ°nlognã€‚ Longest Bitonic Subsequencehttps://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/åŸºæœ¬æ€è·¯ï¼šæ‰¾æ•°ç»„ä¸­æœ€é•¿çš„å°å±±ï¼Œè¿™é‡Œå°å±±ä¸æ˜¯subarrayè€Œæ˜¯subsequenceï¼Œæ‰€ä»¥ç”¨dpåšã€‚ï¼ˆå°å±±æ˜¯subarrayçš„æƒ…å†µæ”¾åœ¨left to right &amp;&amp; right to lefté‚£ç¯‡ï¼‰åŸºæœ¬æ€è·¯å’ŒLISæ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡å·¦å³å„æ¥äº†ä¸€éã€‚ LCåŸé¢˜10. Regular Expression MatchingåŸºæœ¬æ€è·¯ï¼šä¹Ÿæ˜¯ä¸ªé«˜é¢‘é¢ç­‹é¢˜å§ï¼Œç‹—å®¶çš„ã€‚æ„Ÿè§‰LCå‰300é¢˜éƒ½è¿˜æŒºç»å…¸çš„ã€‚ 64. Minimum Path SumåŸºæœ¬æ€è·¯ï¼šç»å…¸é¢˜ï¼ŒäºŒç»´DP bottom-upï¼Œfollow upçš„è¯å°±æ˜¯å¦‚ä½•ä¸ç”¨extra spaceæ¥ä½œdp 91. Decode Waysï¼ˆè„¸ç‹—é¢ç­‹ï¼‰åŸºæœ¬æ€è·¯ï¼šéœ€è¦äººä¸ºç»™dp[0] and dp[1] èµ‹å€¼ï¼Œå› ä¸ºint first = s.substring(i - 1, i); int second = s.substring(i - 2, i);123456789ä¸¾ä¾‹ï¼š2294dp[0] = 1, dp[1] = 1;i = 2 int first = 2; int second = 22ï¼Œéƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œdp[2] += dp[0] + dp[1] = 2;(2,2 / 22)i = 3 int first = 9; int second = 29ï¼Œ29æ˜¯æ— æ•ˆçš„ï¼Œdp[3] += dp[2] = 2;(2,2,9 / 22, 9)i = 4 int first = 4; int second = 49ï¼Œ49æ˜¯æ— æ•ˆçš„ï¼Œdp[4] += dp[3] = 2;(2,2,9,4 / 22,9,4) 639. Decode Ways IIåŸºæœ¬æ€è·¯:å’ŒIçš„åŒºåˆ«åœ¨äºéœ€è¦å¯¹ç‰¹æ®Šç¬¦å·è¿›è¡Œä¸€ä¸ªåˆ¤æ–­å’Œå¤„ç†ï¼Œè¿™é‡Œå¯¹ç¬¬ä¸€ä¸ªCharacterå’Œç¬¬äºŒä¸ªCharacterå®šä¹‰ä¸ºc1å’Œc212345678910111213ç¬¬1ç§æƒ…å†µï¼šc1 is num and c2 is numæ­£å¸¸å¤„ç†ç¬¬2ç§æƒ…å†µï¼šc1 is num and c2 is * case1: c1 == '1', 1* = 11 ~ 19 dp[i] += 9 * dp[i - 2] dp[i] += 9 * dp[i - 1];; case2: c2 == '2', 2* = 21 ~ 26 dp[i] += 6 * dp[i - 2] dp[i] += 9 * dp[i - 1];;ç¬¬3ç§æƒ…å†µï¼šc1 is * and c2 is num case1: c2 &lt;= '6' * å˜æˆ1æˆ–è€…2éƒ½æ˜¯æœ‰æ•ˆçš„ dp[i] += 2 * dp[i - 2] case2: else * å˜æˆ1æ˜¯æœ‰æ•ˆçš„ï¼Œ2æ— æ•ˆ dp[i] += dp[i - 2]ç¬¬4ç§æƒ…å†µï¼šc1 is * and c2 is * case1: ** = 11 ~ 19 + 21 ~ 26 dp[i] += 15 * dp[i - 2] dp[i] += 9 * dp[i - 1];; 95. Unique Binary Search Trees IIåŸºæœ¬æ€è·¯ï¼š1.æ ¹æ®DPæ€è·¯å‡ºå‘ï¼Œç¡®å®šé—®é¢˜ç”¨recursionæ–¹æ³•è§£å†³ï¼Œå¯¹æ¯ä¸€ä¸ªnodeï¼Œé€’å½’çš„æ±‚å‡ºä»–çš„å·¦å³å­æ ‘ï¼Œè¿æ¥åˆ°å½“å‰nodeã€‚2.æ³¨æ„è¾¹ç•Œæ¡ä»¶ï¼Œl &gt; r æ—¶æ·»åŠ nullåˆ°å¯¹åº”çš„subä¸­ç”¨äºæ„å»ºleafçš„éƒ¨åˆ†ã€‚3.ä½¿ç”¨ä¸€ä¸ªfor loop éå†1ï½nçš„æ‰€æœ‰ç‚¹ï¼Œå¯¹äºè¯¥ç‚¹ï¼Œè·å–ä»–çš„å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œå°†å¯¹åº”çš„å­©å­èŠ‚ç‚¹è¿æ¥åˆ°nodeä¸Šã€‚4.è·‘ä¸€è¾¹testcaseæœ‰åŠ©äºç†è§£ã€‚123456789101112131415161718192021222324252627class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n == 0) return new ArrayList&lt;&gt;(); return helper(1, n); &#125; public List&lt;TreeNode&gt; helper(int l, int r) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (l &gt; r) &#123; res.add(null); return res; &#125; for (int i = l; i &lt;= r; i++) &#123; List&lt;TreeNode&gt; lSub = helper(l, i - 1); List&lt;TreeNode&gt; rSub = helper(i + 1, r); for (TreeNode lChild : lSub) &#123; for (TreeNode rChild : rSub) &#123; TreeNode cur = new TreeNode(i); cur.left = lChild; cur.right = rChild; res.add(cur); &#125; &#125; &#125; return res; &#125;&#125; 96. Unique Binary Search TreesåŸºæœ¬æ€è·¯ï¼š123456789101112situation of only 1 node f(1) = 1situation of 2 nodes f(2) = 2 2 1 / \ 1 2situation of 3 nodes f(3) = 5 3 3 3 / \ / \ / \f(0) f(2) f(1) f(1) f(2) f(0) ä»¥æ­¤ç±»æ¨ï¼Œä¸éš¾å‘ç°å…¶ä¸­çš„dpè½¬ç§»è§„å¾‹ 1234f(2) = f(1) * f (0) + f(0) * f(1);f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0);f(4) = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0);...... f(0) = 1å…¶å®å°±è¡¨ç¤ºrootçš„å·¦/å³å­æ ‘å…¨ç©ºä¹Ÿæ˜¯ä¸€ç§æƒ…å†µè®²é“ç†å§ï¼Œè¿™é¢˜æˆ‘ä¸çœ‹ç­”æ¡ˆä¸å¤ªæƒ³å¾—åˆ°ã€‚ã€‚ 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125;&#125; 174. Dungeon Game304. Range Sum Query 2D - Immutable322. Coin ChangeåŸºæœ¬æ€è·¯ï¼šç»å…¸ä¸­çš„ç»å…¸dp[amount] è¡¨ç¤ºå‡‘æˆå½“å‰æ•°é¢å…±éœ€å‡ æšç¡¬å¸ã€‚åœ¨æ¯ä¸€ä¸ªæ•°é¢ä¸‹ï¼Œå¯¹coinsä¸­çš„æ¯ä¸€æšç¡¬å¸éƒ½è¦å°è¯•ã€‚ åˆå§‹èµ‹å€¼ï¼šdp[0] = 0, dp[1] -&gt; dp[amount] = amount + 1 (ä¸€ä¸ªå¤§äºamountçš„æ•°å­—)çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šif (coin &lt;= curAmount) dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1); æ‰‹åŠ¨è¿‡ä¸€étest caseã€‚1234567891011121314151617when curAmount = 2, coin = 1, dp[2] = Math.min(amount + 1, dp[1] + 1) = 2; curAmount = 2, coin = 2, dp[2] = Math.min(2, dp[0] + 1) = 1;when curAmount = 3, coin = 1, dp[3] = Math.min(amount + 1, dp[2] + 1) = 2; curAmount = 3, coin = 2, dp[3] = Math.min(2, dp[1] + 1) = 2;when curAmount = 4, coin = 1, dp[4] = Math.min(amount + 1, dp[3] + 1) = 3; curAmount = 4, coin = 2, dp[4] = Math.min(3, dp[2] + 1) = 2;when curAmount = 5, coin = 1, dp[5] = Math.min(amount + 1, dp[4] + 1) = 3; curAmount = 5, coin = 2, dp[5] = Math.min(3, dp[3] + 1) = 3; curAmount = 5, coin = 5, dp[5] = Math.min(3, dp[0] + 1) = 1;......when curAmount = 11, coin = 1, dp[11] = Math.min(amount + 1, dp[10] + 1) = 3; curAmount = 11, coin = 2, dp[11] = Math.min(3, dp[9] + 1) = 3; curAmount = 11, coin = 5, dp[11] = Math.min(3, dp[6] + 1) = 3; ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; for (int i = 0; i &lt;= amount; i++) &#123; dp[i] = amount + 1; &#125; dp[0] = 0; for (int curAmount = 1; curAmount &lt;= amount; curAmount++) &#123; for (int coin : coins) &#123; if (coin &lt;= curAmount) &#123; dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1); &#125; &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount]; &#125;&#125; 338. Counting Bitså¯¹ä½è¿ç®—ä¸€ç›´æ²¡ä»€ä¹ˆæ„Ÿè§‰ã€‚ã€‚è¿˜æ˜¯æ‰¾è§„å¾‹å¥½äº†0-&gt;00000000 9 -&gt;000010011-&gt;00000001 10-&gt;000010102-&gt;00000010 11-&gt;000010113-&gt;00000011 12-&gt;000011004-&gt;00000100 13-&gt;000011015-&gt;00000101 14-&gt;000011106-&gt;00000110 15-&gt;000011117-&gt;00000111 16-&gt;000100008-&gt;00001000 416. Partition Equal Subset SumåŸºæœ¬æ€è·¯ï¼šä¹Ÿå¾ˆç»å…¸çš„ä¸€é“é¢˜ï¼Œåˆ¤æ–­æ•°ç»„èƒ½å¦è¢«äºŒç­‰åˆ†ã€‚å½“ç„¶backtrackingè‚¯å®šèƒ½è§£ï¼Œä¸è¿‡è¿™é‡Œè¿˜æ˜¯dpæ›´å¥½ï¼Œæ›´å¿«å…¶å®å°±æ˜¯ä¸€é“èƒŒåŒ…é—®é¢˜ï¼Œæ¯ä¸ªçŸ³å¤´æ‹¿ä¸€æ¬¡ï¼Œé—®èƒ½å¦ä»çŸ³å †ä¸­å–åˆ°åˆšå¥½å¡«æ»¡èƒŒåŒ…é‡é‡çš„çŸ³å¤´ã€‚ 1234567891011121314151617181920212223class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0; for (int i : nums) &#123; sum += i; &#125; if (sum % 2 != 0) &#123; return false; &#125; int tag = sum / 2; boolean[] dp = new boolean[tag + 1]; Arrays.fill(dp, false); dp[0] = true; for (int num : nums) &#123; for (int val = tag; val &gt;= 0; val--) &#123; // 11 10 ..... 2 1 0 if (val &gt;= num) &#123; dp[val] = dp[val] || dp[val - num]; &#125; &#125; &#125; return dp[tag]; &#125;&#125; 576. Out of Boundary Pathsï¼ˆbaiduï¼‰åŸºæœ¬æ€è·¯ï¼šå’Œ688å…¶å®æ˜¯ä¸€æ ·çš„ï¼Œä»æ£‹æ”¹æˆäº†çƒï¼Œç•™åœ¨æ£‹ç›˜æ”¹æˆäº†è¸¢å‡ºåœºå¤–ï¼Œä¸‰ç»´DPä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425class Solution &#123; private int[][] dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; private final int MOD = 1000000007; public int findPaths(int m, int n, int N, int ri, int rj) &#123; int[][][] dp = new int[N + 1][m][n]; dp[0][ri][rj] = 1; int res = 0; for (int step = 1; step &lt;= N; step++) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; 4; k++) &#123; int row = i + dirs[k][0]; int col = j + dirs[k][1]; if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n) &#123; res = (res + dp[step - 1][i][j]) % MOD; &#125;else &#123; dp[step][row][col] = (dp[step][row][col] + dp[step - 1][i][j]) % MOD; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125; 688. Knight Probability in Chessboard(ç‹—é¢ç­‹é¢˜ï¼Œéª‘å£«åœ¨æ£‹ç›˜ä¸­çš„æ¦‚ç‡)åŸºæœ¬æ€è·¯ï¼šä½¿ç”¨ä¸‰ç»´æ•°ç»„maintainåœ¨å½“å‰æ­¥æ•°ä¸‹ï¼Œæ£‹ç›˜ä¸Šæ¯ä¸€æ ¼éƒ½æœ‰å¤šå°‘ç§æƒ…å†µèƒ½å­˜æ´»ã€‚å·ä¸ªèŠ±èŠ±çš„å›¾ï¼Œå¾ˆæ¸…æ™°äº†Time Complexity: O(K * N^2), Space Complexity: O(N^3), å¯ä¼˜åŒ–åˆ°O(N^2)ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031class Solution &#123; private int[][] dirs = new int[][]&#123;&#123;1, 2&#125;, &#123;2, 1&#125;, &#123;2, -1&#125;, &#123;1, -2&#125;, &#123;-1, -2&#125;, &#123;-2, -1&#125;, &#123;-2, 1&#125;, &#123;-1, 2&#125;&#125;; public double knightProbability(int N, int K, int r, int c) &#123; double[][][] dp = new double[K + 1][N][N]; dp[0][r][c] = 1.0; for (int step = 1; step &lt;= K; step++) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; for (int k = 0; k &lt; 8; k++) &#123; int row = i + dirs[k][0]; int col = j + dirs[k][1]; if (row &lt; 0 || row &gt;= N || col &lt; 0 || col &gt;= N) &#123; continue; &#125; else &#123; dp[step][i][j] += dp[step - 1][row][col]; &#125; &#125; &#125; &#125; &#125; double res = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; res += dp[K][i][j]; &#125; &#125; return res / Math.pow(8, K); &#125;&#125; 764. Largest Plus SignåŸºæœ¬æ€è·¯ï¼šæ‰¾äºŒç»´æ•°ç»„ä¸­æœ€å¤§çš„åŠ å·ã€‚ 877. Stone Gameè¿™é¢˜æ˜¯å›½å†…æ—¥ä¼WAPçš„é¢è¯•é¢˜ä¹‹ä¸€ï¼Œç”¨DPæ²¡è¿™ä¹ˆå®¹æ˜“æƒ³ã€‚ 943. Find the Shortest SuperstringåŸºæœ¬æ€è·¯ï¼šå˜å½¢çš„TSPé—®é¢˜ã€‚]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie Tree]]></title>
    <url>%2F2018%2F08%2F18%2FTrie%2F</url>
    <content type="text"><![CDATA[åˆ·é¢˜åˆ·åˆ°è¦ç”¨trieçš„é¢˜åˆå†™ä¸å‡ºäº†ã€‚ã€‚æŠŠtrieå¥½å¥½å†™ä¸€å†™ã€‚https://leetcode.com/articles/implement-trie-prefix-tree/This explanation is so fucking amazing. LC article is so qiang! ApplicationsTrie(prefix tree)ä¼šè¢«ç”¨äºï¼š è‡ªåŠ¨è¡¥å…¨ æ‹¼å†™æ£€æŸ¥ IP routing T9 predictive textï¼ˆä¹å®«æ ¼è¾“å…¥æ³•æ–‡æœ¬é¢„æµ‹ï¼‰ why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity could deteriorate to O(n), where nn is the number of keys inserted. Trie could use less space compared to Hash Table when storing many keys with the same prefix. In this case using trie has only O(m) time complexity, where mm is the key length. Searching for a key in a balanced tree costs O(mlog n) time complexity. TrieNode structure1234567891011121314151617181920212223242526272829class TrieNode&#123; private TrieNode[] child; private final int N = 26; private boolean isWord = false; public TrieNode() &#123; child = new TrieNode(N); &#125; public boolean containsKey(char c) &#123; return child[ch - 'a'] != null; &#125; public TrieNode get(char c) &#123; return child[ch - 'a']; &#125; public void put(char c, TrieNode node) &#123; child[c - 'a'] = node; &#125; public boolean isWord() &#123; return isWord; &#125; public void setWord() &#123; isWord = true; &#125;&#125; Insertion of a key to a trie1234567891011121314151617181920class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125;&#125; Complexity Analysis Time complexity : O(m), where m is the key length.In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only mm operations. Space complexity : O(m).In the worst case newly inserted key doesnâ€™t share a prefix with the the keys already inserted in the trie. We have to add mm new nodes, which takes us O(m) space. Search for a key in a trie123456789101112131415161718192021222324class Trie &#123; ... // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125;&#125; Complexity Analysis Time complexity : O(m) In each step of the algorithm we search for the next key character. In the worst case the algorithm performs m operations. Space complexity : O(1) Search for a key prefix in a trie12345678910class Trie &#123; ... // Returns if there is any word in the trie // that starts with the given prefix. public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node != null; &#125;&#125; Complexity Analysis Time complexity : O(m) Space complexity : O(1)]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>å­—å…¸æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursion and Backtracking]]></title>
    <url>%2F2018%2F08%2F16%2FRecursion%20and%20Backtracking%2F</url>
    <content type="text"><![CDATA[ä»–ä¹¡é€¢ä¸ƒå¤•,æ—…é¦†ç›Šç¾æ„ã€‚ ä¸è§ç©¿é’ˆå¦‡,ç©ºæ€€æ•…å›½æ¥¼ã€‚ ç»ªé£åˆå‡çƒ­,æ–°æœˆå§‹ç™»ç§‹ã€‚ è°å¿çª¥æ²³æ±‰,è¿¢è¿¢é—®æ–—ç‰›ã€‚ æŠ¥ç­çš„è®²äº†é€’å½’å’Œå›æº¯ï¼Œæˆ‘è‡ªå·±ä¹Ÿæ¥æ€»ç»“ä¸€ä¸‹å§ã€‚OAä¸¤ä¸ªé¢˜å†™äº†æˆ‘å¥½ä¹…ã€‚ A general approach to backtracking questions in Java.https://leetcode.com/problems/combination-sum/discuss/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioningLC discussé‡Œè¿™ä½è€å“¥æ€»ç»“çš„å¾ˆå¥½ã€‚æˆ‘è‡ªå·±å†ç²¾ç®€ä¸‹ã€‚ Subsets I &amp; Subsets IIIå’ŒIIåªæœ‰ä¸€ä¸ªä¸åŒï¼Œæ•°ç»„ä¸­å¦‚æœæœ‰é‡å¤å…ƒç´ ï¼Œå¦‚ä½•é¿å…å‡ºç°é‡å¤çš„å­é›†ï¼Ÿ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; å…³é”®åœ¨äº æ’åº å’Œ if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; æ’åºæ˜¯ç¡®ä¿åä¸€å¥èµ·ä½œç”¨çš„å‰æã€‚ä¸¾ä¸ªä¾‹å­ å¯¹äºä¸å«é‡å¤å…ƒç´ çš„inputï¼Œæ¯”å¦‚123, ç”Ÿæˆçš„å­é›†ä¸º[], 1, 12, 13, 123, 2, 23, 3 å¯¹äºå«é‡å¤å…ƒç´ çš„inputï¼Œæ¯”å¦‚122, é‚£ç”Ÿæˆçš„å­é›†ä¸º[], 1, 12, 12, 122, 2, 22, 2 å»é‡çš„åŸç†ï¼šå½“å‰å­é›†ä¸º12æ—¶ï¼Œbacktrackingåˆ é™¤2ï¼Œå½“åŠ å…¥indexä¸º2çš„å…ƒç´ 2æ—¶ï¼Œå‘ç°é‡å¤ï¼Œå› æ­¤ä¸åŠ ã€‚ i &gt; startçš„ç›®çš„æ˜¯ä¸ºäº†ä¿è¯ç¬¬ä¸€ä¸ªå‡ºç°çš„é‡å¤çš„å€¼ä¼šè¢«åŠ å…¥subsetä¸­ã€‚ Permutationsuse boolean[], HashSet, or swap() is both ok.å¦‚æœé™åˆ¶ä¸å…è®¸ä½¿ç”¨é¢å¤–çš„ç©ºé—´æ¥check each elementæ˜¯ä¸æ˜¯è¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆswapæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚æ³¨æ„ä½¿ç”¨swapçš„è¯ï¼Œfor loopä¸­iç”±indexèµ‹å€¼ï¼Œè€Œä¸æ˜¯æ¯æ¬¡ä»0å¼€å§‹ã€‚ 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length == 0) return res; Arrays.sort(nums); bt(nums, res, new ArrayList&lt;Integer&gt;(), 0); return res; &#125; public void bt(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int index) &#123; if (index == nums.length) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = index; i &lt; nums.length; i++) &#123; list.add(nums[i]); swap(nums, index, i); bt(nums, res, list, index + 1); swap(nums, index, i); list.remove(list.size() - 1); &#125; &#125; public void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 37. Sudoku SolveråŸºæœ¬æ€è·¯ï¼šæœ€åŸºæœ¬çš„å›æº¯ã€‚å¯¹æ¯ä¸€ä¸ªç©ºæ ¼å­å…ˆåˆ¤æ–­1-9å¡«è¿™é‡Œæ˜¯ä¸æ˜¯æœ‰æ•ˆï¼Œæœ‰æ•ˆçš„è¯è¿›å…¥ä¸‹ä¸€æ­¥ï¼Œæ— æ•ˆçš„è¯å°†å¡«å…¥çš„å€¼æŠ¹æ‰å˜ä¸ºç©ºå€¼ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public void solveSudoku(char[][] board) &#123; solve(board); &#125; public boolean solve(char[][] board) &#123; int row = board.length, col = board[0].length; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (board[i][j] == '.') &#123; for (char c = '1'; c &lt;= '9'; c++) &#123; if (isValid(board, i, j, c)) &#123; board[i][j] = c; if (solve(board)) &#123; return true; &#125;else &#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int row, int col, char c) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (board[i][col] != '.' &amp;&amp; board[i][col] == c) return false; if (board[row][i] != '.' &amp;&amp; board[row][i] == c) return false; &#125; int s1 = row / 3 * 3; int s2 = col / 3 * 3; for (int i = s1; i &lt; s1 + 3; i++) &#123; for (int j = s2; j &lt; s2 + 3; j++) &#123; if (board[i][j] != '.' &amp;&amp; board[i][j] == c) return false; &#125; &#125; return true; &#125;&#125; 282. Expression Add Operators698. Partition to K Equal Sum SubsetsåŸºæœ¬æ€è·¯ï¼šå’Œ473æ˜¯å®Œå…¨ä¸€æ ·çš„é—®é¢˜ã€‚ å…ˆåˆ¤æ–­å’Œèƒ½å¦è¢«4æ•´é™¤ï¼Œtarget = sum / 4;ä¹‹åå¯¹Arrayæ’åºï¼Œå¦‚æœå­˜åœ¨element &gt; target return false;é€šè¿‡ä¸€ä¸ªwhile loopå¯»æ‰¾numsä¸­æ˜¯å¦æœ‰elementæ°å¥½ç­‰äºtargetï¼Œå¦‚æœå­˜åœ¨ï¼Œkâ€“ï¼Œç›¸å½“äºæ¡¶å˜å°‘äº†ï¼ŒåŠ å¿«æœç´¢è¿›åº¦ã€‚helper methodç›¸å½“äºæŠŠå‰©ä¸‹çš„å…ƒç´ åˆ†é…åˆ°Kä¸ªæ¡¶ä¸­ï¼Œä¿è¯æ¯æ¬¡åˆ†é…æ¡¶çš„sum + åˆ†é…è¿›æ¥çš„å€¼å°äºç­‰äºtargetã€‚å¦‚æœæ‰€æœ‰å…ƒç´ å…¨è¢«åˆ†é…äº†ï¼Œè¯´æ˜å¯ä»¥Kç­‰åˆ†ã€‚ 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; if (sum % k != 0) return false; int target = sum / k; Arrays.sort(nums); int index = nums.length - 1; if (nums[index] &gt; target) return false; while (index &gt;= 0 &amp;&amp; nums[index] == target) &#123; index--; k--; &#125; int[] sub = new int[k]; return helper(nums, sub, target, index); &#125; public boolean helper(int[] nums, int[] sub, int target, int index) &#123; if (index &lt; 0) return true; int cur = nums[index--]; for (int i = 0; i &lt; sub.length; i++) &#123; if (sub[i] + cur &lt;= target) &#123; sub[i] += cur; if (helper(nums, sub, target, index)) return true; sub[i] -= cur; &#125; if (sub[i] == 0) break; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>å›æº¯</tag>
        <tag>é€’å½’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[287. Find Duplicate]]></title>
    <url>%2F2018%2F08%2F08%2FFind%20Duplicate%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ”¶äº†å°FBå†…æ¨æ®ä¿¡ï¼Œæˆ‘å’Œkisdayéƒ½æƒ³ä¸æ˜ç™½é—®é¢˜åœ¨å“ªã€‚ã€‚æ„Ÿè§‰æ˜¯çœŸçš„è¦æŠ¥ç­äº†ã€‚ã€‚è‡³å°‘ä¿è¯æˆ‘æœ‰ä¸ªé¢è¯•å§ï¼Œä¸ç„¶é¢˜åˆ·çš„å†å¤šæœ‰ä»€ä¹ˆç”¨ http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=176498&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D192%26sortid%3D192 åœ¨åœ°é‡Œçœ‹äº†è¿™ä¸ªå¸–å­ï¼Œéš¾å—çš„ä¸€æ‰¹ã€‚éš¾å—å°±å¯¹äº†ï¼Œå¥½èµ°çš„éƒ½æ˜¯ä¸‹å¡è·¯ã€‚ ä½†æ˜¯é¢˜è¿˜æ˜¯è¦åˆ·ã€‚æ€»ç»“ä¸€ä¸‹æ‰¾é‡å¤çš„ä¸€äº›é¢˜ã€‚ 287. Find the Duplicate NumberåŸºæœ¬æ€è·¯ï¼šä¸€èˆ¬æœ‰ä¸‰ç§æ–¹æ³•ï¼šæ’åºï¼Œç”¨setï¼Œæ ¹æ®ä¸‹æ ‡å–è´Ÿã€‚ è¿™é¢˜æœ‰è¦æ±‚ï¼Œä¸èƒ½modifyåŸæ•°ç»„ï¼Œä¸èƒ½ä½¿ç”¨é¢å¤–çš„ç©ºé—´ï¼Œä¸èƒ½å¤§äºO(n) åˆ©ç”¨duplicate numè¿™ä¸ªç‰¹ç‚¹ã€‚åœ¨è¯¥æ•°ç»„ä¸­ä¸¤ä¸ªä¸åŒçš„indexä¼šæŒ‡å‘åŒä¸€ä¸ªnumã€‚å› æ­¤è€ƒè™‘åšä¸€ä¸ªnum -&gt; indexçš„è¿æ¥ï¼Œé‚£ä¹ˆè¯¥é“¾è¡¨æˆç¯ã€‚é—®é¢˜è½¬åŒ–ä¸ºå¿«æ…¢æŒ‡é’ˆé“¾è¡¨æ‰¾ç¯ã€‚ 12345678910111213141516171819public class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = 0, fast = 0; int len = nums.length; while (fast &lt; len &amp;&amp; nums[fast] &lt; len) &#123; slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) &#123; slow = 0; while (slow != fast) &#123; slow = nums[slow]; fast = nums[fast]; &#125; return slow; &#125; &#125; return -1; &#125;&#125; 652. Find Duplicate Subtrees]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sliding Window Problems]]></title>
    <url>%2F2018%2F08%2F06%2FSliding%20Window%20Problem%2F</url>
    <content type="text"><![CDATA[åˆ·é¢ç»æ—¶å€™çœ‹åˆ°ï¼Œæ­£å¥½æ€»ç»“ä¸€ä¸‹è¿™ä¸€ç±»sliding windowé—®é¢˜ï¼ˆæ»‘çª—ï¼‰ã€‚discussé‡Œçš„templateç»™çš„å¾ˆå¥½ï¼Œä¸è¿‡æˆ‘è§‰å¾—è¿˜æ˜¯è‡ªå·±æ‰‹å†™è¿‡ä¸€éæ¯”è¾ƒå¥½ã€‚ç¬¨åŠæ³•å¸®åŠ©ç†è§£ï¼Œæ¯•ç«Ÿè‡ªå·±ä¸æ˜¯èªæ˜äººã€‚ æ”¾ä¸€ä¸ªæ¯”è¾ƒå¥½çš„æ€»ç»“:https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7.md 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. æ€è·¯æ˜¯ä¸€æ ·çš„ï¼Œå³æŒ‡é’ˆå‘ç°é‡å¤çš„é‚£ä¸ªæ•°ä¹‹åï¼ˆmap.get(r) &gt; 1ï¼‰ï¼Œå·¦æŒ‡é’ˆå¼€å§‹æ‰«æï¼Œç›´åˆ°æ‰¾åˆ°å’Œå½“å‰rightæŒ‡é’ˆå¯¹åº”çš„å…ƒç´ ç›¸åŒçš„å…ƒç´ ã€‚æ­¤æ—¶å·¦æŒ‡é’ˆå·¦è¾¹çš„éƒ¨åˆ†ä¸ä¼šè¢«ç”¨äºä¹‹åçš„å¯»æ‰¾æœ€ä¼˜è§£çš„è¿‡ç¨‹ä¸­ï¼Œåœ¨mapä¸­å¯¹åº”çš„valä¹Ÿä¸º0.æˆ‘åœ¨è¿™é‡Œç”¨äº†boolean found æ¥ä½œä¸ºåˆ¤æ–­çš„æ¡ä»¶æ˜¯å¦è¿›å…¥å·¦æŒ‡é’ˆå¯»å€¼çš„while loopï¼Œå› ä¸ºä½¿ç”¨countä¼šè®©äººæœ‰ç‚¹è¿·æƒ‘ã€‚1234567891011121314151617181920212223242526class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0, right = 0, len = 0; boolean found = false; while (right &lt; s.length()) &#123; char r = s.charAt(right); map.put(r, map.getOrDefault(r, 0) + 1); if (map.get(r) &gt; 1) &#123; found = true; &#125; while (found) &#123; char l = s.charAt(left); if (map.get(l) &gt; 1) &#123; found = false; &#125; map.put(l, map.get(l) - 1); left++; &#125; //System.out.println("right is " + right + " left is " + left); len = Math.max(right - left + 1, len); right++; &#125; return len; &#125;&#125; LC76. Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot; å¼€ä¸€ä¸ªmapï¼ˆå¯ä»¥æ•°ç»„æˆ–è€…HashMapï¼‰ç”¨æ¥check Sä¸­çš„å­—æ¯æ˜¯å¦å­˜åœ¨äºTä¸­ã€‚ å‚æ•°å«ä¹‰ï¼š count ç”¨äºåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†ä¸€ç»„è§£ã€‚if (count == 0) å°±è¯´æ˜Tä¸­çš„æ‰€æœ‰å­—æ¯å·²åœ¨å½“å‰æŒ‡é’ˆæ‰«æèŒƒå›´è¢«å…¨éƒ¨coverã€‚ åˆå§‹åŒ–ä¸ºmap.size(), å› ä¸ºTä¸­å¯èƒ½æœ‰é‡å¤å…ƒç´ ï¼Œæ‰€ä»¥ç”¨map.size()ã€‚countçš„å¢åŠ å–å†³äºmapä¸­valueæ˜¯å¦ä¸º0ã€‚ left å·¦æŒ‡é’ˆ right å³æŒ‡é’ˆ head ç”¨æ¥maintainæ¯æ¬¡æ‰¾åˆ°åˆæ³•è§£åå·¦æŒ‡é’ˆçš„ä½ç½®ã€‚ min å½“å‰çš„æœ€å°é•¿åº¦ï¼Œåˆå§‹åŒ–ä¸ºInteger.MAX_VALUE æŒ‰ç…§ä»£ç æƒ³æ³•æ‰‹åŠ¨è¿‡ä¸€étest case: â€œcabwefgewcwaefgcfâ€ï¼Œâ€caeâ€ round 1: substring is cabwe right = 4, æ­¤æ—¶count == 0ï¼ŒleftæŒ‡é’ˆå¼€å§‹moveï¼Œæ­¤æ—¶left = 0, min = 6, head = 0 ä¹‹åleftå’Œrightåˆ†åˆ«è‡ªå¢ï¼Œright = 5, left = 1; round 2: å› ä¸ºcåœ¨round 1ä¸­è¢«é‡æ–°åŠ åˆ°mapä¸­ï¼Œä¸‹ä¸€æ­¥å½“rightæ‰«åˆ°cæ—¶ï¼Œcount == 0, æ‰«æä¸­è¿˜ä¼šæ‰«åˆ°ä¸€ä¸ªeï¼Œä½¿å…¶åœ¨mapä¸­çš„val - 1 substring is abwefgewc right = 9, æ­¤æ—¶count == 0ï¼ŒleftæŒ‡é’ˆå¼€å§‹moveï¼Œæ­¤æ—¶left = 1, right - left + 1 &gt; minã€‚headå’Œminä¸å˜ã€‚ ä¹‹åleftå’Œrightåˆ†åˆ«è‡ªå¢ï¼Œright = 10, left = 2; round 3: substring is efgewcwa right = 11, æ­¤æ—¶count == 0ï¼Œ leftæŒ‡é’ˆå¼€å§‹moveï¼Œæ‰«åˆ°ç¬¬ä¸€ä¸ªeï¼Œå‘ç°map.get(e) == -1, é‚val+1ï¼Œä½†map.get(e) å¹¶æ²¡æœ‰å¤§äº0ï¼Œcountä¸å˜ä»ä¸º0ã€‚æ‰€ä»¥while loopä¸­leftæŒ‡é’ˆç»§ç»­å‘å³moveï¼Œç›´åˆ°å‘ç°ç¬¬äºŒä¸ªeä¸ºæ­¢ã€‚ substring is ewcwa right = 11, count == 0, left = 7, right - left + 1 &lt; min, min = 5, head = 7; round 4: substring is cwae right = 12, count == 0, left = 9, right - left + 1 &lt; min, min = 4, head = 9; æ‰¾åˆ°æœ€ä¼˜è§£ã€‚ round 5: sunstring is aefgc right - left + 1 &gt; min, pass æ‰«æå®Œæ¯• code 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int min = Integer.MAX_VALUE; int left = 0, right = 0, count = map.size(), head = 0; while (right &lt; s.length()) &#123; char r = s.charAt(right); if (map.containsKey(r)) &#123; map.put(r, map.get(r) - 1); if (map.get(r) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; char l = s.charAt(left); if (map.containsKey(l)) &#123; map.put(l, map.get(l) + 1); if (map.get(l) &gt; 0) &#123; count++; &#125; &#125; if (right - left + 1 &lt; min) &#123; head = left; min = right - left + 1; &#125; left++; &#125; right++; &#125; return min == Integer.MAX_VALUE ? "" : s.substring(head, head + min); &#125;&#125; 239. Sliding Window Maximum (ç‹—å®¶OA)é¢˜æ„ï¼šé—®é¢˜æ˜¯ç»™å®šä¸€ä¸ªå¤§å°ä¸ºKçš„çª—å£ï¼Œåœ¨æ¯æ¬¡æ»‘åŠ¨è¿‡ç¨‹ä¸­æ‰¾åˆ°å½“å‰çª—å£ä¸­æœ€å¤§çš„é‚£ä¸ªæ•°ï¼Œreturnä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰è¿™äº›æ•°çš„æ•°ç»„ã€‚ åŸºæœ¬æ€è·¯ï¼šä¸åŒäºå­—ç¬¦ä¸²å¤„ç†çš„æ»‘çª—é—®é¢˜ï¼Œè¿™é‡Œç”¨Dequeæ¥å¯¹æ•°ç»„è¿›è¡Œå¤„ç†ã€‚ç»å…¸é¢˜ã€‚ 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p&apos;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &quot;cbaebabacd&quot; p: &quot;abc&quot; Output: [0, 6] Explanation: The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;. The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. ä¸Šä¸€é¢˜æ˜¯æ‰¾subsequenceï¼Œä½†æ˜¯é€šè¿‡check right - left + 1 == p.length()ï¼Œå°±èƒ½æŠŠä»£ç è½¬åŒ–ä¸ºæ‰¾substringã€‚ 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : p.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int left = 0, right = 0, head = 0, count = map.size(); while (right &lt; s.length()) &#123; char r = s.charAt(right); if (map.containsKey(r)) &#123; map.put(r, map.get(r) - 1); if (map.get(r) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; char l = s.charAt(left); if (map.containsKey(l)) &#123; map.put(l, map.get(l) + 1); if (map.get(l) &gt; 0) &#123; count++; &#125; &#125; if (right - left + 1 == p.length()) &#123; head = left; list.add(head); &#125; left++; &#125; right++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>åˆ·é¢˜æ€»ç»“</category>
      </categories>
      <tags>
        <tag>æ»‘åŠ¨çª—å£</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search & Sort]]></title>
    <url>%2F2018%2F07%2F29%2FSearch%20%26%20Sort%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘çœ‹åˆ°FBæœ‰äººè¢«é¢äº†Kth smallest elementï¼Œæˆ‘ä¹Ÿé‡æ–°å¤ä¹ ä¸€ä¸‹ã€‚// ç™½å¤ä¹  é¡ºä¾¿ä¹Ÿé‡æ–°ç†ä¸€ä¸‹ä¸€äº›åŸºæœ¬çš„é€‰æ‹©å’Œæ’åºç®—æ³•ã€‚ æ¯”è¾ƒæ’åºå…ˆç¡®å®šä¸¤ä¸ªæ¦‚å¿µï¼Œæ€ä¹ˆæ ·çš„æ’åºç®—æ³•æ˜¯ç¨³å®šçš„ï¼Œæ€ä¹ˆæ ·çš„æ’åºç®—æ³•æ˜¯é«˜æ•ˆçš„ã€‚ quick sortæ”¾ä¸€ä¸ªæ¨¡æ¿åœ¨è¿™é‡Œï¼Œå¿«æ’çœŸå¾—ä¸å¤ªå¥½å†™ 12 éæ¯”è¾ƒæ’åºæ‘†è„±äº†nlognçš„é­”å’’ã€‚æ’åºé€Ÿåº¦ä¸€èˆ¬ä¸ºçº¿æ€§ï¼Œä½†æ˜¯éœ€è¦é¢å¤–çš„ç©ºé—´ã€‚å› ä¸ºæ‹¿ç©ºé—´æ¢äº†æ—¶é—´ã€‚ courting sortå¾ˆæœ‰è¶£çš„æ’åºï¼ŒDoordashçš„ä¸€é“é¢ç­‹é¢˜ã€‚ä¸€èˆ¬ç”¨äºå¤„ç†ä¸€ä¸ªsmall rangeçš„æ’åºã€‚æ—¶ç©ºé—´å¤æ‚åº¦å‡ä¸ºO(n + k);næ˜¯åŸæ•°ç»„çš„é•¿åº¦ï¼ŒKä¸ºæ•°ç»„ä¸­çš„max - min + 1;ä¸‹é¢æ˜¯Javaçš„å®ç° 12345678910111213141516171819202122232425262728public int[] countingSort(int[] nums) &#123; if (nums.length &lt; 2) return nums; int min = nums[0], max = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; min = Math.min(nums[i], min); max = Math.max(nums[i], max); &#125; int[] count = new int[max - min + 1]; for (int i = 0; i &lt; nums.length; i++) &#123; int index = nums[i] - min; count[index]++; &#125; for (int i = 1; i &lt; count.length; i++) &#123; count[i] += count[i - 1]; &#125; int[] res = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; int index = count[nums[i] - min] - 1; res[index] = nums[i]; count[nums[i] - min]--; &#125; return res;&#125; bucket sortæ¡¶æ’åº binary searchJon Bentleyè¯´90%çš„ç¨‹åºå‘˜éƒ½å†™ä¸å¯¹äºŒåˆ†, æˆ‘ä¸ªäººè§‰å¾—å†™äºŒåˆ†æœ€å¥½å°±ç”¨ä¸€ä¸ªæ¨¡æ¿ã€‚å¦å¤–è¿™ä¸ªå¸–å­çœŸçš„è®²çš„éå¸¸éå¸¸å¥½ã€‚http://www.1point3acres.com/bbs/thread-432793-1-1.html å½“æœç´¢åˆ°è¾¾right - left == 1çš„æ—¶å€™ï¼Œè¿™æ—¶å€™midæ˜¯ç­‰äºleftçš„ã€‚ 1234567891011121314public int binarySearch(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; //avoid overflow if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] == target) &#123; return mid; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; //dont find&#125; 33. Search in Rotated Sorted ArraysåŸºæœ¬æ€è·¯ï¼šæœ€ç»å…¸çš„é¢˜äº†ã€‚ 34. Find First and Last Position of Element in Sorted ArrayåŸºæœ¬æ€è·¯ï¼š1.ä¸¤ä¸ªbinary searchï¼Œæ‰¾åˆ°targetåä¸€ä¸ªç»§ç»­å‘å·¦ï¼Œä¸€ä¸ªç»§ç»­å‘å³ã€‚2.åœ¨å½“å‰æœç´¢æ‰¾åˆ°targetåï¼Œè®°å½•indexåç»§ç»­å‘å·¦/å³æœç´¢ï¼Œã€‚123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[2]; res[0] = left(nums, target); res[1] = right(nums, target); return res; &#125; public int left(int[] nums, int target) &#123; //5,7,7,8,8,10 int index = -1, l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &gt;= target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; if (nums[mid] == target) index = mid; &#125; return index; &#125; public int right(int[] nums, int target) &#123; //5,7,7,8,8,10 int index = -1, l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &lt;= target) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; if (nums[mid] == target) index = mid; &#125; return index; &#125;&#125; 153. Find Minimum in Rotated Sorted Array215. Kth Largest Element in an ArrayåŸºæœ¬æ€è·¯ï¼š-è§£æ³•1:å¼€ä¸€ä¸ªPriorityQueueï¼Œtime complexity is Nlog(K).-è§£æ³•2:quick select æ€è·¯å’Œå¿«æ’ç›¸åŒï¼Œä½†åªéœ€è¦å¯¹ä¸€è¾¹è¿›è¡Œæ’åºå°±è¡Œã€‚ å› ä¸ºæ’åºåpivotåœ¨æ•´ä¸ªlistä¸­çš„indexæ˜¯ç¡®å®šçš„ï¼Œæˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒKå’Œindexï¼Œå¦‚æœK &lt; indexï¼Œé‚£ä¹ˆè¯´æ˜è¦æ‰¾çš„target numåœ¨å·¦åŠéƒ¨åˆ†ï¼Œåä¹‹äº¦ç„¶ã€‚ 230. Kth Smallest Element in a BSTåŸºæœ¬æ€è·¯ï¼šç”¨inorder éå†å½“ç„¶å¾ˆå¿«ï¼Œä¸è¿‡è¿™é¢˜æœ€å¥½çš„è§£æ³•æ˜¯ç»™äºŒåˆ†ã€‚ 540. Single Element in a Sorted ArrayåŸºæœ¬æ€è·¯ï¼šåˆ©ç”¨äº†ä¸€ä¸ªç‰¹æ€§ï¼Œå°±æ˜¯å¤šå‡ºçš„single numberä¼šå½±å“æ•°ç»„ä¸­pairå’Œindexä¹‹é—´çš„è§„å¾‹ã€‚123456789101112åŸå§‹çš„arrayï¼š1 1 3 3 4 4 8 80 1 2 3 4 5 6 7if index is odd, nums[index] == nums[index - 1]if index is even, nums[index] == nums[index + 1]æ’å…¥ä¸€ä¸ªsingle number ä¹‹åï¼š1 1 2 3 3 4 4 8 80 1 2 3 4 5 6 7 8æ­¤æ—¶2ï¼ˆsingle numberï¼‰ä¹‹å‰çš„subarrayè¿˜æ˜¯ç¬¦åˆè¿™ä¸ªè§„å¾‹ï¼Œä½†æ˜¯2ä¹‹åçš„éƒ¨åˆ†ä¸ç¬¦åˆã€‚æ‰€ä»¥å‘ç°å½“å‰indexä¸ç¬¦åˆè§„å¾‹ï¼Œåˆ™è¯´æ˜single numberåœ¨indexçš„å·¦åŒºï¼Œr = midå¦‚æœç¬¦åˆè§„å¾‹ï¼Œåˆ™single numberåœ¨indexçš„å³åŒºï¼Œl = mid + 1ä»£ç 12345678910111213141516class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int mid = l + (r - l) / 2; int n = mid % 2 == 0 ? mid + 1 : mid - 1; if (nums[mid] == nums[n]) &#123; l = mid + 1; &#125; else &#123; r = mid; &#125; //System.out.println("l is: " + l + " " + "r is: " + r); &#125; return nums[l]; &#125;&#125; 658. Find K Closest ElementsåŸºæœ¬æ€è·¯ï¼šæ‰¾å‡ºæœ€æ¥è¿‘xçš„kä¸ªå€¼ã€‚èƒŒå§ï¼Œåæ­£æˆ‘æƒ³ä¸åˆ°äºŒåˆ†è¿˜èƒ½è¿™ä¹ˆç”¨çš„ï¼Œç¥ä»™åšé¢˜ã€‚ PS: æœ€è¿‘é¢è„¸åˆçœ‹åˆ°è¿™é“é¢˜ã€‚å¾—å¥½å¥½è¿‡ä¸€éã€‚å…ˆé€šè¿‡äºŒåˆ†æ‰¾åˆ°target valueçš„indexã€‚å†æ ¹æ®indexå®šä¸¤ä¸ªåŒæŒ‡é’ˆï¼Œå·¦æŒ‡é’ˆä¸ºindex - 1, å³æŒ‡é’ˆä¸ºindexã€‚è¿™æ ·èƒ½ç¡®ä¿åœ¨ç¬¬ä¸€æ¬¡æ¯”è¾ƒçš„æ—¶å€™ï¼ŒæŠŠtarget value æˆ–è€…æœ€æ¥è¿‘target valueçš„é‚£ä¸ªå€¼æ”¾è¿›å»ã€‚ æ¥ä¸‹æ¥è·‘ä¸€étest case: [1,2,3,4,5], æ³¨æ„ the smaller elements are always preferred. step1: original index = 2 (value is 3), pointers[2, 3], åˆ¤æ–­år++step2: original index = 2 (value is 3), pointers[2, 4], åˆ¤æ–­ålâ€“step3: original index = 2 (value is 3), pointers[1, 4], åˆ¤æ–­år++step4: original index = 2 (value is 3), pointers[1, 5], åˆ¤æ–­ålâ€“, å¾—åˆ°äº†4ä¸ªelement æ­¤æ—¶å·¦æŒ‡é’ˆä¸º-1, å³æŒ‡é’ˆä¸º 4, åŒºé—´åº”è¯¥æ˜¯ [å·¦æŒ‡é’ˆ + 1, å³æŒ‡é’ˆ)12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) &#123; // should check with interviewer, it's index closest or value closest. List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (arr.length == 0) return ret; int index = binarySearch(arr, x); int l = index - 1, r = index; while (k &gt; 0) &#123; if (l &gt;= 0 &amp;&amp; r &lt; arr.length) &#123; // the smaller elements are always preferred. if (x - arr[l] &lt;= arr[r] - x) &#123; l--; &#125; else &#123; r++; &#125; &#125; else if (l &lt; 0) &#123; r++; &#125; else if (r &gt;= arr.length) &#123; l--; &#125; k--; &#125; for (int i = l + 1; i &lt; r; i++) &#123; ret.add(arr[i]); &#125; return ret; &#125; public int binarySearch(int[] nums, int target) &#123; if (nums.length == 0) return 0; int l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; return l; &#125;&#125; Sort Problems179. Largest NumberåŸºæœ¬æ€è·¯ï¼šè¿™é¢˜å¾ˆæœ‰æ„æ€ï¼Œå…ˆå°†int è½¬ä¸º Stringï¼Œä¹‹åå¼€å§‹æ’åºï¼Œé‡å†™comparator; æ’åºçš„é€»è¾‘æ˜¯ï¼ŒString A and String Bï¼Œif A+B &gt; B+A, åˆ™Aåœ¨Bçš„å‰é¢; for example: 930 &gt; 309, so [9, 30]. Stringçš„æ¯”è¾ƒå¯ä»¥ç›´æ¥ç”¨compareTo(); æœ€åæ ¹æ®æ’åºçš„String[] æ‹¼æ¥å­—ç¬¦ä¸²è¾“å‡ºå³å¯ã€‚123456789101112131415161718192021222324252627class Solution &#123; public String largestNumber(int[] nums) &#123; if (nums.length == 0) return ""; if (nums.length == 1) return String.valueOf(nums[0]); int len = nums.length; String[] strs = new String[len]; for (int i = 0; i &lt; len; i++) &#123; strs[i] = String.valueOf(nums[i]); &#125; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; public int compare(String l, String r) &#123; String s1 = l + r; String s2 = r + l; return s2.compareTo(s1); &#125; &#125;); if (strs[0].equals("0")) return "0"; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; sb.append(str); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>äºŒåˆ†æœç´¢</tag>
        <tag>æ’åº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Spanning Tree & Union found]]></title>
    <url>%2F2018%2F07%2F22%2FMinimum%20Spanning%20Tree%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©è€å§è®©æˆ‘å†™æœ€å°ç”Ÿæˆæ ‘ï¼Œæ†‹äº†åŠå¤©å†™ä¸å‡ºæ¥=ï¼Œ= æœ€éªšçš„æ˜¯kisdayå’Œæˆ‘è¯´ä»–ä¹Ÿä¸ä¼šå†™ï¼Œæˆ‘ä¼šä¿¡ï¼Ÿ ç°åœ¨è®¤çœŸå­¦ä¹ äº†ä¸€éï¼Œæ”¾ä¸ªæ€»ç»“å…å¾—ä»¥ååˆå¿˜äº†ã€‚è™½ç„¶æˆ‘éšéšè§‰å¾—äºšéº»ä¸ä¼šç»™æˆ‘è¿™ä¸ªç”¨çš„æœºä¼šã€‚// ç¡®å®æ²¡ç»™æˆ‘OAï¼Œæˆ‘å¯é€æ‚¨é©¬ã€‚ æœ€å°ç”Ÿæˆæ ‘ï¼šè¿é€šåŠ æƒæ— å‘å›¾ä¸­ä¸€æ£µæƒå€¼æœ€å°çš„ç”Ÿæˆæ ‘ã€‚A. Kruskalç®—æ³• ï¼ˆæ‘˜è‡ªç»´åŸºç™¾ç§‘ï¼‰ æ­¥éª¤ï¼š 1.æ–°å»ºå›¾Gï¼ŒGä¸­æ‹¥æœ‰åŸå›¾ä¸­ç›¸åŒçš„èŠ‚ç‚¹ï¼Œä½†æ²¡æœ‰è¾¹ 2.å°†åŸå›¾ä¸­æ‰€æœ‰çš„è¾¹æŒ‰æƒå€¼ä»å°åˆ°å¤§æ’åº 3.ä»æƒå€¼æœ€å°çš„è¾¹å¼€å§‹ï¼Œå¦‚æœè¿™æ¡è¾¹è¿æ¥çš„ä¸¤ä¸ªèŠ‚ç‚¹äºå›¾Gä¸­ä¸åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ä¸­ï¼ˆè¯´äººè¯ï¼šå¦‚æœæˆç¯å°±ä¸é€‰è¿™æ¡è¾¹ï¼‰ï¼Œåˆ™æ·»åŠ è¿™æ¡è¾¹åˆ°å›¾Gä¸­ 4.é‡å¤3ï¼Œç›´è‡³å›¾Gä¸­æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ä¸­ï¼ˆæ‰€æœ‰ç‚¹éƒ½ç”¨å®Œäº†ï¼‰ è¯æ˜ï¼š åè¯æ³•ã€‚å¦‚æœè¿™é¢—æ ‘ä¸æ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼Œé‚£ä¹ˆä¸€å®šæœ‰ä¸€æ¡ä¸åœ¨è¿™ä¸ªæ ‘ä¸­çš„è¾¹ã€‚è¿™æ¡è¾¹å¿…å®šä¼šå’Œå…¶ä¸­æŸäº›å˜æˆç¯ï¼Œä½†ç¯ä¸­åˆ«çš„è¾¹éƒ½æ˜¯æƒå€¼æœ€å°çš„ï¼Œæ‰€ä»¥å¦‚æœä½¿ç”¨è¿™æ¡è¾¹è€Œåˆ å»å…¶ä»–çš„è¾¹ï¼Œé‚£ä¹ˆæ•´é¢—æ ‘çš„æƒå€¼å°±ä¸æ˜¯minimumäº†ã€‚ æ³¨æ„ï¼š åˆ¤æ–­è¿æ¥çš„ä¸¤ç‚¹æ˜¯å¦åœ¨è”é€šåˆ†é‡ä¸­ï¼ˆä¼šä¸ä¼šæˆç¯ï¼‰éœ€è¦ä½¿ç”¨å¹¶æŸ¥é›†ã€‚ Union Findç”¨æ³•Find(x): find the root/cluster-id of x Union(x, y): merge two clusters Check whether two elements are in the same set or not in O(1). Find: O(É‘(n)) â‰ˆ O(1) Union: O(É‘(n)) â‰ˆ O(1) Space: O(n) Without optimization: Find: O(n)åŒæ—¶ä½¿ç”¨è·¯å¾„å‹ç¼©ã€æŒ‰ç§©ï¼ˆrankï¼‰åˆå¹¶ä¼˜åŒ–çš„ç¨‹åºæ¯ä¸ªæ“ä½œçš„å¹³å‡æ—¶é—´ä»…ä¸ºO(É‘(n))ï¼Œå…¶ä¸­a(n)æ˜¯n = f(x) = A(x,x)çš„åå‡½æ•°ï¼Œ A æ˜¯æ€¥é€Ÿå¢åŠ çš„é˜¿å…‹æ›¼å‡½æ•°ã€‚å› ä¸ºa(n)æ˜¯å…¶åå‡½æ•°ï¼Œæ•…a(n)åœ¨nååˆ†å·¨å¤§æ—¶è¿˜æ˜¯å°äº 5ã€‚å› æ­¤ï¼Œå¹³å‡è¿è¡Œæ—¶é—´æ˜¯ä¸€ä¸ªæå°çš„å¸¸æ•°ã€‚å®é™…ä¸Šï¼Œè¿™æ˜¯æ¸è¿‘æœ€ä¼˜ç®—æ³•. Two key optimizations: 1.Path compression: make tree flat2.Union by rank: merge low rank tree to high rank one Implementations:12345678910111213141516171819202122232425262728293031323334353637class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; // pu is the parent of u, pv is the parent of v int pu = find(u); int pv = find(v); if (pu == pv) return false;// They are in the same clusterd already if (ranks[pu] &gt; ranks[pv]) &#123;// merge low rank tree to high rank tree parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; Leetcode721. Accounts MergeåŸºæœ¬æ€è·¯: å¯¹äºæ¯ä¸€ä¸ªemailï¼Œèµ‹äºˆä¸€ä¸ªå¯¹åº”çš„IDï¼ŒIDç”¨äºåˆ¤æ–­æ¯ä¸ªemailæ˜¯ä¸æ˜¯å±äºä¸€ä¸ªcluster ç”¨ä¸¤ä¸ªmapåˆ†åˆ«å­˜ email -&gt; nameï¼Œemail -&gt; ID å› ä¸ºä¸€ä¸ªemailåªå¯¹åº”ä¸€ä¸ªIDï¼Œæ‰€ä»¥ä¸¤ä¸ªclusteråŒ…å«ç›¸åŒçš„emailä¼šè¢«mergeã€‚ æ ¹æ®cluster indexå°†æ¯ä¸ªemailæ”¾åˆ°ä¸€ä¸ªæ–°çš„HashMapä¸­ã€‚ æ‹¿å‡ºè¿™ä¸ªæ–°mapçš„values(()ï¼Œå¯¹å…¶å®çš„listè¿›è¡Œæ’åºï¼Œå¹¶ä¸”åœ¨å¤´éƒ¨æ’å…¥è¿™ä¸ªlistå¯¹åº”çš„äººåã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; UnionFind uf = new UnionFind(10001); Map&lt;String, String&gt; emailToName = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; emailToId = new HashMap&lt;&gt;(); int id = 0; for (List&lt;String&gt; account : accounts) &#123; String name = account.get(0); for (int i = 1; i &lt; account.size(); i++) &#123; String email = account.get(i); // nameå’Œemailæ˜¯ä¸€å¯¹å¤šçš„å…³ç³»ï¼Œä¸ä¼šå‡ºç°ä¸åŒçš„åå­—å´æœ‰ç›¸åŒçš„emailçš„æƒ…å†µã€‚ emailToName.put(email, name); if (!emailToId.containsKey(email)) &#123; emailToId.put(email, id++); &#125; // å¯¹æ¯ä¸ªemailè¿›è¡Œunionï¼Œå­˜åœ¨ç›¸åŒemailå°±ä¼šmerge // å«ä¹‰ä¸ºï¼šæ‹¥æœ‰ç›¸åŒemailçš„åŒåè´¦å·è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªäººï¼ˆä¸€ä¸ªäººå°±æ˜¯ä¸€ä¸ªclusterï¼‰ uf.union(emailToId.get(account.get(1)), emailToId.get(email)); &#125; &#125; Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String email : emailToName.keySet()) &#123; int index = uf.find(emailToId.get(email)); // æ ¹æ® cluster index å°†æ¯ä¸ªemailå½’ç±» if (!map.containsKey(index)) &#123; map.put(index, new ArrayList&lt;String&gt;()); &#125; map.get(index).add(email); &#125; for (List&lt;String&gt; list : map.values()) &#123; // æ’åºå æ ¹æ®email -&gt; nameçš„æ˜ å°„å°†åå­—åŠ å…¥list Collections.sort(list); list.add(0, emailToName.get(list.get(0))); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125;class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; // pu is the parent of u, pv is the parent of v int pu = find(u); int pv = find(v); if (pu == pv) return false;// They are in the same clusterd already if (ranks[pu] &gt; ranks[pv]) &#123;// merge low rank tree to high rank tree parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; 684. Redundant ConnectionåŸºæœ¬æ€è·¯ï¼šå¦‚æœä¸¤ä¸ªç‚¹æ— æ³•è¢«unionï¼Œè¯´æ˜ä»–ä»¬å·²ç»åœ¨ä¸€ä¸ªclusterä¸­ï¼Œæ­¤æ—¶è¿æ¥è¿™ä¸¤ç‚¹çš„edgeä¼šå¯¼è‡´æ ‘ä¸­æœ‰ç¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; UnionFind uf = new UnionFind(1000); for (int[] edge : edges) &#123; if (!uf.union(edge[0], edge[1])) return edge; &#125; return new int[2]; &#125;&#125;class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt; parents.length; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125;&#125; 685. Redundant Connection IIåŸºæœ¬æ€è·¯ï¼šgraphçš„è¾¹ä»æ— å‘å˜æˆäº†æœ‰å‘ã€‚ 547. Friend CirclesåŸºæœ¬æ€è·¯ï¼šå¦‚æœä½¿ç”¨å¹¶æŸ¥é›†ï¼Œåˆ™åœ¨UnionFind classåŠ ä¸€ä¸ªå‚æ•°countç”¨æ¥maintainå½“å‰clusterçš„ä¸ªæ•°ã€‚æ¯æ¬¡unionéƒ½ä¼šä½¿count - 1ã€‚ æ³¨æ„æ­¤æ—¶new UnionFind(n)æ—¶ï¼Œnå¿…é¡»åˆšå¥½æ˜¯æ‰€æœ‰éœ€è¦è®¡ç®—çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œæ­¤é¢˜ä¸­å°±æ˜¯å­¦ç”Ÿä¸ªæ•°Nã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int findCircleNum(int[][] M) &#123; int N = M.length; UnionFind u = new UnionFind(row); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (M[i][j] == 1) &#123; if (!u.union(i, j)) continue; &#125; &#125; &#125; return u.count; &#125;&#125;class UnionFind &#123; int[] parents; int[] ranks; int count; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; count = n; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; count--; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; 765. Couples Holding HandsåŸºæœ¬æ€è·¯ï¼šå…ˆæ˜ç¡®ä¸€ç‚¹ï¼Œå¦‚ä½•åˆ¤æ–­ä¸¤ä¸ªæ•°æ˜¯ä¸€å¯¹å¤«å¦» -&gt; nums[i] / 2 == nums[j] / 2ã€‚æ¯”å¦‚2ï¼Œ3å’Œ4ï¼Œ5ï¼Œé™¤2ä¹‹åä¸º1ï¼Œ1å’Œ2ï¼Œ2;è¿™æ ·åˆ¤æ–­çš„å¥½å¤„åœ¨äºä¸ç”¨è€ƒè™‘ä½ç½®ï¼Œlike 0ï¼Œ1 å’Œ1ï¼Œ0; å¹¶æŸ¥é›†ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸º N = row.length / 2;ä½¿ç”¨å¹¶æŸ¥é›†çš„è¯ï¼Œ 128. Longest Consecutive SequenceåŸºæœ¬æ€è·¯ï¼š1.ä½¿ç”¨å¹¶æŸ¥é›†ï¼Œå°†ç›¸å·®ä¸º1çš„å…ƒç´ æ”¾å…¥ä¸€ä¸ªclusterï¼Œæœ€åç»Ÿè®¡æ¯ä¸ªelementåœ¨unino findä¸­å¯¹ä¸­çš„parentçš„ä¸ªæ•°ï¼Œæœ€å¤šçš„é‚£ä¸ªå°±æ˜¯ç­”æ¡ˆ2.[100, 4, 200, 1, 3, 2] 1234æ˜¯ä¸€ä¸ªclusterï¼Œ100æ˜¯ä¸€ä¸ªï¼Œ200æ˜¯ä¸€ä¸ªã€‚1234çš„parentéƒ½æ˜¯0ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯43.ä½¿ç”¨ä¸€ä¸ªhashmapåœ¨éå†ä¸­maintain nums[i], nums[i] + 1 and nums[i] - 1çš„å…³ç³»4.æ³¨æ„ï¼unionçš„æ˜¯æ¯ä¸ªç›¸é‚»å…ƒç´ çš„indexï¼Œå…ƒç´ æœ¬èº«å¯èƒ½ä¼šæ˜¯è´Ÿæ•°ï¼Œunionçš„è¯ä¼šå‡ºé”™ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; UnionFind un = new UnionFind(nums.length + 1); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) continue; map.put(nums[i], i); if (map.containsKey(nums[i] + 1)) &#123; // union index of two elements here un.union(map.get(nums[i] + 1), i); &#125; if (map.containsKey(nums[i] - 1)) &#123; // union index of two elements here un.union(map.get(nums[i] - 1), i); &#125; &#125; // count freq of each parent id, return the max one map = new HashMap&lt;&gt;(); int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; int p = un.find(i); map.put(p, map.getOrDefault(p, 0) + 1); res = Math.max(map.get(p), res); &#125; return res; &#125;&#125;class UnionFind &#123; private int[] parents; private int[] ranks; int count; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; count = n; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; count--; return true; &#125; public int find(int u) &#123; while (u != parents[u]) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125; public int[] getParents() &#123; return parents; &#125;&#125; 399. Evaluate Division]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java lambda expressions]]></title>
    <url>%2F2018%2F07%2F15%2FJava%20lambda%20expressions%2F</url>
    <content type="text"><![CDATA[é‡å†™comparator:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Prime Number]]></title>
    <url>%2F2018%2F07%2F09%2FPrime%20Number%2F</url>
    <content type="text"></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>åˆ·é¢˜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸‡å†å’Œé±¼]]></title>
    <url>%2F2018%2F07%2F08%2F%E4%B8%87%E5%8E%86%EF%BC%8C%E5%A7%9A%E8%B4%9D%E5%A8%9C%E5%92%8C%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[çœ‹äº†åŠæœ¬ä¸‡å†åäº”å¹´ï¼ŒæŒºæœ‰æ„æ€çš„ä¸€æœ¬ä¹¦ã€‚è®²äº†ä¸€ä¸ªè¢«æ–‡å®˜å’Œå„’å®¶çš„è§„çŸ©æŸç¼šçš„å¯æ€œçš‡å¸ã€‚ æ˜¨å¤©æœ‹å‹æ·±å¤œæ‰“ç”µè¯ç»™æˆ‘ï¼Œæ¥èµ·æ¥å°±æ˜¯ä¸€é˜µå•œæ³£ã€‚ç”µè¯é‚£è¾¹ä¸€å¥æˆ‘æƒ³å›NBäº†ï¼Œè®©æˆ‘ä¹Ÿæ„Ÿè§‰é¼»å¤´ä¸€é…¸ã€‚æˆ‘å¥½æ˜ç™½è¿™ç§æ„Ÿè§‰ã€‚ æˆ‘è¯´å®åœ¨ä¸è¡Œå°±å›å®¶å§ï¼Œå…¶å®æˆ‘ä¹Ÿå¥½ç´¯ï¼Œæ‰›ä¸ä½ä¹Ÿæ­£å¸¸ã€‚ä»–å´åªæ˜¯åœ¨å¦ä¸€è¾¹è¯´ï¼Œå¯å›å»å°±æ˜¯æ‰¿è®¤è‡ªå·±å¤±è´¥äº†å‘€ã€‚ æˆ‘çªç„¶è¯´ä¸å‡ºè¯æ¥ã€‚å› ä¸ºè‡ªå·±å†…å¿ƒæ— æ³•æè¿°å‡ºæ¥çš„æ„Ÿå—è¢«äººè¯´å‡ºæ¥äº†ï¼Œè¢«ä¸€ä¸ªæœ‰åŒæ ·æ„Ÿå—çš„äººã€‚ å…¶å®ä»–åˆå¸…åˆé«˜ï¼Œæ€§æ ¼ä½“è´´ï¼Œåœ¨å¤šä¼¦å¤šä¹°äº†æˆ¿ã€‚é¥­ä¹Ÿçƒ§çš„å¥½åƒã€‚æ€ä¹ˆä¹Ÿç®—ä¸ä¸Šå¤±è´¥çš„ã€‚ åªæ˜¯è¿˜æ²¡æœ‰ä¸ªç¨³å®šçš„å·¥ä½œï¼Œå¤§æ¦‚æ˜¯è§‰å¾—æ—¢ç„¶å‡ºæ¥äº†ï¼Œæ€»å¾—æ··å‡ºç‚¹åå ‚å†å›å»å§ã€‚ æˆ‘æ‡‚ï¼Œå› ä¸ºè¿™ä¹Ÿæ˜¯æˆ‘çš„æ€é‡ã€‚ æƒ³æ˜¾å¾—ä½“é¢ä¸€äº›ï¼Œå°±ä¼šæœ‰å¾ˆå¤šé¡¾è™‘å’Œè€ƒé‡å¤¹åœ¨åœ¨ç”Ÿæ´»ä¸­ï¼Œå°±å¾ˆéš¾ç”¨è‡ªå·±è§‰å¾—èˆ’æœçš„å§¿åŠ¿è¿‡æ—¥å­äº†ã€‚ä½†ä½ å¾—è£…ä½œä½ å…¶å®è¿˜ä¸é”™ã€‚ çªç„¶å°±æ„Ÿè§‰æˆ‘ä»¬è¿™äº›äººæœ‰ç‚¹å¯æ€œï¼Œè¿˜æœ‰æ›´å¯æ€œçš„ä¸‡å†çš‡å¸ã€‚ çš‡å¸éƒ½èº«ä¸ç”±å·±ï¼Œä½•å†µæˆ‘ä»¬è¿™äº›çš„æ™®é€šäººå‘¢ã€‚ ä¸€è¾¹å¬ç€ç”µè¯ï¼Œç”µè§†é‡Œåˆšå¥½æ”¾åˆ°å§šè´å¨œåœ¨å”±é±¼ï¼Œçœ¼ç›é‡Œé—ªçƒç€éš¾ä»¥è¨€æ˜çš„å…‰å½©ï¼Œå…‰å½©é‡Œæ¶ŒåŠ¨ç€æ¸´æœ›ã€‚ æ„Ÿè§‰æˆ‘å°±åƒå¥¹æ­Œå£°é‡Œçš„é±¼ï¼Œæ€ä¹ˆé€ƒéƒ½é€ƒä¸å‡ºè¿™ä¸ªä¸–ç•Œç¼–çš„ç½‘ï¼ŒæŒ£è„±äº†ä¸€ä¸ªç½‘çœ¼è¿˜æœ‰ä¸€ä¸ªç½‘çœ¼ã€‚ ç½‘çœ¼çš„ç§ç±»è¿˜æŒºå¤šï¼šé’±ï¼Œå…³ç³»ï¼Œæˆ¿å­ï¼Œè½¦ï¼Œäººè„‰ï¼Œè¿˜æœ‰ä¹±ä¸ƒå…«ç³Ÿçš„ä¸œè¥¿ã€‚ å»ä½ å¦ˆçš„ã€‚ æˆ‘å°±æƒ³æ¯å¤©æ—±æ¶ä¿æ”¶é¥¿ä¸æ­»æ²¡äº‹æ‰“æ‰“æ¸¸æˆå¶å°”åƒé¡¿å¥½çš„ã€‚äººæ´»ç€æ€ä¹ˆå°±å¾—æœ‰è¿™ä¹ˆå¤šé€¼äº‹å„¿å‘¢ï¼Œæ€ä¹ˆå°±æœ‰è¿™ä¹ˆå¤šè¦æ±‚å‘¢ï¼Ÿ æœ€å˜æ€çš„æ˜¯æˆ‘è‡ªå·±ä¹Ÿæ˜ç™½æˆ‘å¾—å»åŠªåŠ›è¿½é€è¿™äº›ä¸œè¥¿ï¼Œä¸èƒ½å½“loserã€‚åˆ°åº•ä¸ºä»€ä¹ˆæˆ‘ä¼šæœ‰è¿™äº›è·Ÿè‡ªå·±è¿‡ä¸å»çš„æƒ³æ³•å¹¶ä¸”ç”¨æ¥è¦æ±‚è‡ªå·±ï¼Ÿ æˆ‘å°æ—¶å€™å°±ä¸€ç›´åœ¨æƒ³ï¼Œä¼šä¸ä¼šæˆ‘ä»¬çš„ä¸–ç•Œå…¶å®å°±æ˜¯ä¸€æœ¬æ•…äº‹ä¹¦ï¼Œäººç”Ÿåªæ˜¯æœ‰ä¸ªæ—ç™½åœ¨é»˜é»˜åœ°è¯»ä½ çš„æ•…äº‹ï¼Œä¸€ä¸ªä¸ªè¢«å†™å¥½çš„æ•…äº‹ã€‚ æƒ³æ¥æƒ³å»ä¹Ÿæ²¡ä»€ä¹ˆå¤´ç»ªï¼Œè¿˜æ˜¯ç»§ç»­å†™ä¼šå„¿ä»£ç å¥½äº†ã€‚ç®—æ˜¯æ˜ç™½æ–‡ç« æ†å‘½è¾¾äº†ï¼Œå¤±æ„çš„äººæ‰æœ‰é—²å¿ƒèƒ¡æ€ä¹±æƒ³ã€‚ ä¸–ç•Œé™ä¸‹æ¥äº†ï¼Œæƒ³äº†æƒ³æœ€è¿‘çœŸçš„å¥½ç´¯å•Šã€‚å…¶å®å°±æ˜¯åœ¨å‘ç‰¢éªšå§ï¼Œå› ä¸ºæƒ³é€ƒå´é€ƒä¸äº†ã€‚]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>éšä¾¿å†™å†™</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree and BST]]></title>
    <url>%2F2018%2F07%2F05%2FBinary%20Tree%20and%20BST%2F</url>
    <content type="text"><![CDATA[æ€»ç»“äº†æ ‘çš„éå†æ–¹æ³•å’ŒLCä¸­çš„ç»å…¸é¢˜ç›® æ ‘çš„éå†Preorder TraversalAlgorithm Preorder(tree) Visit the root. Traverse the left subtree, i.e., call Preorder(left-subtree) Traverse the right subtree, i.e., call Preorder(right-subtree) 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); recursion(root, list); return list; &#125; public void recursion(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; list.add(root.val); recursion(root.left, list); recursion(root.right, list); &#125; public List&lt;Integer&gt; iteration(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) return list; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(root); while (!s.isEmpty()) &#123; TreeNode cur = s.pop(); list.add(cur.val); if (cur.right != null) &#123; s.push(cur.right); &#125; if (cur.left != null) &#123; s.push(cur.left); &#125; &#125; return list; &#125;&#125; Inorder TraversalAlgorithm Inorder(tree) Traverse the left subtree, i.e., call Inorder(left-subtree) Visit the root. Traverse the right subtree, i.e., call Inorder(right-subtree) 1 Postorder TraversalAlgorithm Postorder(tree) Traverse the left subtree, i.e., call Postorder(left-subtree) Traverse the right subtree, i.e., call Postorder(right-subtree) Visit the root. 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); recursion(root, list); return list; &#125; public void recursion(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; recursion(root.left, list); recursion(root.right, list); list.add(root.val); &#125; public List&lt;Integer&gt; iteration(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) return list; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(root); while (!s.isEmpty()) &#123; TreeNode cur = s.pop(); list.add(0, cur.val); if (cur.left != null) &#123; s.push(cur.left); &#125; if (cur.right != null) &#123; s.push(cur.right); &#125; &#125; return list; &#125;&#125; ç›¸å…³é—®é¢˜Tree Isomorphism Problemhttps://www.geeksforgeeks.org/tree-isomorphism-problem/åŸºæœ¬æ€è·¯ï¼šåˆ†åˆ«å¯¹æ ‘Aï¼Œæ ‘Bçš„å·¦å·¦ï¼Œå³å³ï¼Œå·¦å³ï¼Œå³å·¦è¿›è¡Œåˆ¤æ–­æ—¶é—´å¤æ‚åº¦ï¼šè‹¥æ ‘æ˜¯ä¸€é¢—æ»¡äºŒå‰æ ‘ï¼Œæ ‘ä¸­ä¸€å…±æœ‰nä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±æœ‰n/2çš„leafï¼Œæ¯ä¸ªleaféƒ½ä¼šè¢«è®¿é—®nï¼ˆ2^lognï¼‰æ¬¡ï¼Œæ‰€ä»¥æœ€åå°±æ˜¯O(n^2)follow up:å¦‚æœæ˜¯generalçš„æ ‘æ€ä¹ˆåŠï¼Ÿä»»æ„ä¸¤ä¸ªchildéƒ½è¦åƒè¿™é‡Œçš„leftå’Œright subtreeä¸€æ ·è¿›è¡Œæ¯”è¾ƒã€‚123456789101112131415161718192021class solution&#123; public boolean isIsomorphic(Node root1, Node root2) &#123; if (root1 == null &amp;&amp; root2 == null) &#123; return true; &#125;else if (root1 == null || root2 == null) &#123; return false; &#125; if (root1.data != root2.data) return false; //check å·¦å·¦å’Œå³å³ if (isIsomorphic(root1.left, root2.left) &amp;&amp; isIsomorphic(root1.right, root2.right)) &#123; return true; &#125; // check å·¦å³å’Œå³å·¦ if (isIsomorphic(root1.left, root2.right) &amp;&amp; isIsomorphic(root1.right, root2.left)) &#123; return true; &#125; return false; &#125;&#125; 106. Construct Binary Tree from Inorder and Postorder TraversalåŸºæœ¬æ€è·¯ï¼šæ ¹æ®ä¸­åºå’Œååºæ„æ ‘. å°†ä¸­åºæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ å’Œä¸‹æ ‡éƒ½å­˜å…¥mapä¸­ ååºæ•°ç»„çš„æœ€åä¸€ä¸ªæ•°å¿…å®šæ˜¯rootï¼Œåœ¨mapä¸­æ‰¾åˆ°è¿™ä¸ªrootåœ¨inorderæ•°ç»„ä¸­å¯¹åº”çš„ä¸‹æ ‡ æ­¤æ—¶è¯¥indexçš„å·¦è¾¹æ˜¯å·¦å­æ ‘ï¼Œå³è¾¹æ˜¯æœ‰å­æ ‘ã€‚ è¿›è¡Œé€’å½’ã€‚å³å­æ ‘çš„æ–°rootä¸ºpostIndex - 1å·¦å­æ ‘çš„æ–°rootä¸ºpostIndex - (inEnd - index) - 1å› ä¸ºpostçš„é¡ºåºæ˜¯å·¦å³æ ¹ï¼Œé‚£ä¹ˆpostæ•°ç»„å€’ç€æ¥çœ‹çš„è¯å°±æ˜¯æ ¹å³å·¦ã€‚æ‰€ä»¥å½“å‰postIndex - 1å°±æ˜¯å³å­æ ‘çš„rootèŠ‚ç‚¹ã€‚ä»å½“å‰postIndexå‡å»inorderæ•°ç»„ä¸­å³å­æ ‘éƒ¨åˆ†çš„é•¿åº¦ï¼ˆinEnd - indexï¼‰ï¼Œå°±æ˜¯å·¦å­æ ‘çš„rootèŠ‚ç‚¹ ä¸¾ä¾‹ï¼š12345678910111213141516 3 / \ 9 20 / \ 15 7 inorder [9,3,15,20,7] postorder [9,15,7,20,3]start inStart inEnd postIndex index 0 4 4 1right 2 4 3left 0 0 0 = 4 - (4 - 1) - 1 ä»£ç 1234567891011121314151617181920212223class Solution &#123; public TreeNode buildTree(int[] in, int[] post) &#123; if (in == null || post == null || in.length != post.length) return null; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; in.length; i++) &#123; map.put(in[i], i); &#125; return helper(in, post, 0, in.length - 1, post.length - 1, map); &#125; public TreeNode helper(int[] in, int[] post, int inStart, int inEnd, int postIndex, HashMap&lt;Integer, Integer&gt; map) &#123; if (postIndex &lt; 0 || inStart &gt; inEnd) &#123; return null; &#125; int index = map.get(post[postIndex]); TreeNode root = new TreeNode(post[postIndex]); root.left = helper(in, post, inStart, index - 1, postIndex - (inEnd - index) - 1, map); root.right = helper(in, post, index + 1, inEnd, postIndex - 1, map); return root; &#125;&#125; Binary Treeç»å…¸é¢˜124. Binary Tree Maximum Path Sumä¾‹å­1: ä¾‹å­2: -1 -6 / \ / \ -2 -3 2 3 \ 4keep the actual maximum sum updated and separate from the running maximum sum which goes across the current root.åŸºæœ¬æ€è·¯ï¼š1.Maximum Path æ˜¯å¯ä»¥ä¸ç»è¿‡rootçš„ã€‚2.è‡ªåº•å‘ä¸Šè¿›è¡Œé€’å½’ï¼Œ éœ€è¦ä¸€ä¸ªglobal var.3.687, 543ï¼Œä½¿ç”¨äº†åŒæ ·çš„è§£é¢˜æ€è·¯ï¼Œå¯ä»¥å¸®åŠ©åŠ æ·±è®°å¿†ã€‚æ—¶ç©ºé—´å¤æ‚åº¦ä¸ºO(n) O(h) 12345678910111213141516171819class Solution &#123; int ret = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; helper(root); return ret; &#125; public int helper(TreeNode node) &#123; if (node == null) return 0; // è¿™é‡Œä½¿ç”¨maxï¼Œæ˜¯ä¸ºäº†é¿å…childä¸ºè´Ÿæ•°çš„æƒ…å†µï¼Œé€‰è´Ÿæ•°ä¸å¦‚ä¸é€‰ã€‚ä¾‹å­1 int l = Math.max(helper(node.left), 0); int r = Math.max(helper(node.right), 0); int val = l + r + node.val; // æ›´æ–°å…¨å±€æœ€ä¼˜å˜é‡ ret = Math.max(val, ret); // è·¯å¾„æ›´æ–°æ¯æ¬¡åªå–å·¦å³å…¶ä¸­ä¸€æ¡ return Math.max(l, r) + node.val; &#125;&#125; 297. Serialize and Deserialize Binary TreeåŸºæœ¬æ€è·¯ï¼šåºåˆ—åŒ–å’Œååºåˆ—åŒ–æ ‘ã€‚å°†æ ‘å˜æˆä¸€ä¸ªstringï¼Œä¹‹åDeserializeï¼Œå¯ä»¥ç”¨BFSä¹Ÿå¯ä»¥ç”¨DFS DFS12 BFS12 508. Most Frequent Subtree SumåŸºæœ¬æ€è·¯ï¼š1.ç»å¸¸ä¼šé‡åˆ°éœ€è¦å¯¹ä¸€æ£µæ ‘åšä¸€ä¸ªè‡ªåº•å‘ä¸Šçš„ç´¯åŠ è¿‡ç¨‹ï¼Œè¿™é“é¢˜çš„traverseéƒ¨åˆ†å¾ˆå¥½çš„å®ç°äº†è¿™ä¸ªæƒ³æ³•ï¼Œæœ¬è´¨å°±æ˜¯postorderã€‚2.åœ¨traverseçš„è¿‡ç¨‹ä¸­ï¼Œç”¨ä¸€ä¸ªHashMapå»maintainæ¯ä¸ªsumçš„frequencyï¼Œç”¨ä¸€ä¸ªå‚æ•°maxå»è®°å½•æœ€å¤§å€¼ã€‚3.å¯¹æ•´ä¸ªMapåšä¸€ä¸ªéå†ï¼Œæ‰¾å‡ºç¬¦åˆçš„keyå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031class Solution &#123; int freq; public int[] findFrequentTreeSum(TreeNode root) &#123; if (root == null) return new int[]&#123;&#125;; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); traverse(root, map); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) &#123; if (e.getValue() == freq) &#123; list.add(e.getKey()); &#125; &#125; int[] res = new int[list.size()]; for (int i = 0; i &lt; list.size(); i++) &#123; res[i] = list.get(i); &#125; return res; &#125; public int traverse(TreeNode root, HashMap&lt;Integer, Integer&gt; map) &#123; if (root == null) &#123; return 0; &#125; int l = traverse(root.left, map); int r = traverse(root.right, map); int sum = l + r + root.val; map.put(sum, map.getOrDefault(sum, 0) + 1); freq = Math.max(map.get(sum), freq); return sum; &#125;&#125; åˆå¹¶ä¸¤æ£µäºŒå‰æ ‘ 617. Merge Two Binary TreesåŸºæœ¬æ€è·¯ï¼šçœ‹ä»£ç å°±è¡Œäº†ã€‚ 1234567891011121314151617181920class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null &amp;&amp; t2 == null) return null; int val = 0; if (t1 != null &amp;&amp; t2 != null) &#123; val = t1.val + t2.val; &#125; else if (t1 == null &amp;&amp; t2 != null) &#123; val = t2.val; &#125; else &#123; val = t1.val; &#125; TreeNode cur = new TreeNode(val); cur.left = mergeTrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left); cur.right = mergeTrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right); return cur; &#125;&#125; 652. Find Duplicate Subtrees742. Closest Leaf in a Binary TreeåŸºæœ¬æ€è·¯ï¼š1.å…ˆå°†æ ‘è½¬åŒ–ä¸ºå›¾ï¼Œåœ¨æ„å›¾è¿‡ç¨‹ä¸­å°†target nodeä¿å­˜ä¸‹æ¥ï¼Œå†BFSä»target nodeå¼€å§‹æ‰¾æœ€çŸ­è·¯å¾„ã€‚2.å› ä¸ºæ˜¯æ ‘ï¼Œå¯¹äºæ¯ä¸€ä¸ªnodeéœ€è¦å­˜å…¥çš„é‚»å±…åŒ…æ‹¬äº†å®ƒçš„çˆ¶äº²èŠ‚ç‚¹å’Œå„¿å­èŠ‚ç‚¹3.å¦‚æœä¸€ä¸ªèŠ‚ç‚¹ä¸æ˜¯rootï¼Œå¹¶ä¸”å®ƒçš„é‚»å±…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆä»–æ˜¯ä¸€ä¸ªleafï¼ˆå¶å­ç»“ç‚¹ï¼‰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int findClosestLeaf(TreeNode root, int k) &#123; Map&lt;TreeNode, List&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); TreeNode node = null; while (!q.isEmpty()) &#123; int len = q.size(); for (int i = 0; i &lt; len; i++) &#123; TreeNode cur = q.poll(); if (!map.containsKey(cur)) &#123; map.put(cur, new ArrayList&lt;TreeNode&gt;()); &#125; if (cur.left != null) &#123; map.get(cur).add(cur.left); map.putIfAbsent(cur.left, new ArrayList&lt;TreeNode&gt;()); map.get(cur.left).add(cur); q.offer(cur.left); &#125; if (cur.right != null) &#123; map.get(cur).add(cur.right); map.putIfAbsent(cur.right, new ArrayList&lt;TreeNode&gt;()); map.get(cur.right).add(cur); q.offer(cur.right); &#125; if (k == cur.val) node = cur; &#125; &#125; q.clear(); q.offer(node); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); visited.add(node); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); System.out.println(cur.val); List&lt;TreeNode&gt; list = map.get(cur); if (list.size() == 1 &amp;&amp; cur != root) &#123; return cur.val; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (visited.contains(list.get(i))) &#123; continue; &#125; q.offer(list.get(i)); visited.add(list.get(i)); &#125; &#125; return root.val; &#125;&#125; BSTç»å…¸é¢˜235. Lowest Common Ancestor of a Binary Search TreesåŸºæœ¬æ€è·¯ï¼šæŒ‰ç…§BSTæ€§è´¨æ¥1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else &#123; return root; &#125; &#125;&#125; 450. Delete Node in a BSTåŸºæœ¬æ€è·¯ï¼šåˆ é™¤èŠ‚ç‚¹æœ‰ä¸‰ç§æƒ…å†µï¼šå‡å®šæ‰¾åˆ°çš„éœ€è¦åˆ é™¤çš„ç‚¹ä¸ºnode node.left == null -&gt; return node.right; node.right == null -&gt; return node.left; node.left != null &amp;&amp; node.right != nullæ‰¾åˆ°å³å­æ ‘ä¸­æœ€å°çš„èŠ‚ç‚¹ï¼Œæ›¿æ¢å½“å‰nodeï¼Œç„¶åé€’å½’è°ƒç”¨å‡½æ•°åˆ é™¤å³å­æ ‘ä¸­æœ€å°çš„ç‚¹ å›¾ç¤ºçš„è¯å‚è€ƒï¼šhttps://www.geeksforgeeks.org/binary-search-tree-set-2-delete/12345678910111213141516171819202122232425262728class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return null; if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125;else if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125;else &#123; if (root.left == null) &#123; return root.right; &#125;else if (root.right == null) &#123; return root.left; &#125; TreeNode cur = findMin(root.right); root.val = cur.val; root.right = deleteNode(root.right, cur.val); &#125; return root; &#125; public TreeNode findMin(TreeNode root) &#123; while (root.left != null) &#123; root = root.left; &#125; return root; &#125;&#125; 700. Search in a Binary Search TreesåŸºæœ¬æ€è·¯ï¼šæ ¹æ®BSTæ€§è´¨æ‰¾å°±æ˜¯äº†ã€‚ 12345678910111213141516171819class Solution &#123; public TreeNode iteration(TreeNode root, int val) &#123;// BST while (root != null &amp;&amp; root.val != val) &#123; root = root.val &gt; val ? root.left : root.right; &#125; return root; &#125; public TreeNode recursion(TreeNode root, int val) &#123; if (root == null) return null; if (root.val == val) &#123; //System.out.println(root.val); return root; &#125; else if (val &gt; root.val) return searchBST(root.right, val); else if (val &lt; root.val) return searchBST(root.left, val); return null; &#125;&#125; 776. Split BST]]></content>
      <categories>
        <category>ç®—æ³•å’Œæ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2F2018%2F07%2F05%2F129.%20Sum%20Root%20to%20Leaf%20Numbers%2F</url>
    <content type="text"><![CDATA[A binary tree question. The general ieda is using preorder traversal in recursion way. Iterative solution is also accepted.1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; int sum; public int sumNumbers(TreeNode root) &#123; sum = 0; dfs(root, 0); return sum; &#125; public void dfs(TreeNode node, int cur) &#123; if (node == null) return; cur = cur * 10 + node.val; if (node.left == null &amp;&amp; node.right == null) &#123; sum += cur; return; &#125; if (node.left != null) dfs(node.left, cur); if (node.right != null) dfs(node.right, cur); &#125; public int iterative(TreeNode root) &#123;// use two stacks to keep nodes and current sum if (root == null) return 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sum = new Stack&lt;&gt;(); stack.push(root); sum.push(root.val); int res = 0; while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); int cur = sum.pop(); if (node.left == null &amp;&amp; node.right == null) &#123; res += cur; &#125; if (node.right != null) &#123; stack.push(node.right); sum.push(cur * 10 + node.right.val); &#125; if (node.left != null) &#123; stack.push(node.left); sum.push(cur * 10 + node.left.val); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[863. All Nodes Distance K in Binary Tree]]></title>
    <url>%2F2018%2F07%2F01%2F863.%20All%20Nodes%20Distance%20K%20in%20Binary%20Tree%2F</url>
    <content type="text"><![CDATA[Use HashMapï¼Œå…ˆç”¨bfsæˆ–dfså°†æ ‘å˜æˆä¸€ä¸ªå›¾ï¼Œä¹‹åæ ¹æ®target nodeçš„neighborsè¿›è¡Œé€å±‚æœç´¢ï¼Œç›´åˆ°distance == Kã€‚é€šè¿‡HashSet avoid visited nodesã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; Map&lt;TreeNode, HashSet&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; buildMap(root); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(target); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); visited.add(target); boolean found = false; int dis = 0; while (!q.isEmpty()) &#123; int len = q.size(); for (int size = 0; size &lt; len; size++) &#123; TreeNode cur = q.poll(); if (dis == K) &#123; list.add(cur.val); found = true; &#125;else &#123; if (!map.get(cur).isEmpty()) &#123; for (TreeNode t : map.get(cur)) &#123; if (!visited.contains(t)) &#123; q.offer(t); visited.add(t); &#125; &#125; &#125; &#125; &#125; if (found) return list; dis++; &#125; return list; &#125; public void buildMap(TreeNode node) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(node); map.put(node, new HashSet&lt;TreeNode&gt;()); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); if (cur.left != null) &#123; map.put(cur.left, new HashSet&lt;TreeNode&gt;()); map.get(cur).add(cur.left); map.get(cur.left).add(cur); q.offer(cur.left); &#125; if (cur.right != null) &#123; map.put(cur.right, new HashSet&lt;TreeNode&gt;()); map.get(cur).add(cur.right); map.get(cur.right).add(cur); q.offer(cur.right); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[133. Clone Graph]]></title>
    <url>%2F2018%2F07%2F01%2F133.%20Clone%20Graph%2F</url>
    <content type="text"><![CDATA[This is the BFS + Queue solution, use map to keep original nodes and copied nodes.Map can also avoid loop. 1234567891011121314151617181920212223242526272829303132/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */public class Solution &#123; public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return node; UndirectedGraphNode copy = new UndirectedGraphNode(node.label); HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); Queue&lt;UndirectedGraphNode&gt; q = new LinkedList&lt;&gt;(); map.put(node, copy); q.offer(node); while (!q.isEmpty()) &#123; UndirectedGraphNode cur = q.poll(); for (UndirectedGraphNode n : cur.neighbors) &#123; if (!map.containsKey(n)) &#123; map.put(n, new UndirectedGraphNode(n.label)); q.offer(n); &#125; // add neighbors to the copied node // map.get(cur) -&gt; copied node of cur // map.get(n) -&gt; neighbors of copied node map.get(cur).neighbors.add(map.get(n)); &#125; &#125; return copy; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¬é›¨]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%90%AC%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸€æ¬¡çŸ¥é“ç«¹å±±è¯ï¼Œæ˜¯é«˜ä¸­æ—¶å€™è®¸å—ç¿”ä¸€ç¬”ç¬”å†™åœ¨é»‘æ¿ä¸Šï¼Œè¯´ä½ ä»¬ç°åœ¨ä¸æ‡‚ï¼Œè§‰å¾—è¿™è¯å¾ˆä¸€èˆ¬ï¼Œå°†æ¥å°±æ‡‚äº†ã€‚ è™ç¾äººè¿™ä¸ªè¯ç‰Œï¼Œå†æ¥æœ€æ¨å´‡ä¸è¿‡æç…œçš„â€œæ˜¥èŠ±ç§‹æœˆä½•æ—¶äº†ï¼Œå¾€äº‹çŸ¥å¤šå°‘â€ã€‚ä½†æˆ‘ç§å¿ƒé‡Œè¿˜æ˜¯æ›´å–œæ¬¢è’‹æ·çš„è¿™é¦–å¬é›¨ã€‚ æˆ‘æƒ³è®¸å—ç¿”å½“å¹´ç»™æˆ‘ä»¬ä¸Šè¯¾æ—¶ï¼Œåº”è¯¥å’Œæˆ‘ç°åœ¨æ˜¯å·®ä¸å¤šçš„å¹´çºªã€‚è¿‡äº†å¼±å† ä¹‹å¹´ï¼Œç¦»è€Œç«‹å´è¿˜æœ‰ä¸€ç‚¹è·ç¦»ï¼Œå¯¹äººç”Ÿè¿™ä¸ªäº‹åˆšåˆšæœ‰äº†ä¸€ç‚¹è‡ªå·±çš„ç†è§£ã€‚è¿™ä¸ªä¸–ç•Œçš„ä¸‡èˆ¬å¤´ç»ªé“ºå¼€åœ¨æˆ‘çš„é¢å‰ï¼Œå°‘å¹´æ„æ°”å¼€å§‹ä¸€ç‚¹ç‚¹æ¶ˆå‡ã€‚ å¼€å§‹æœ‰äº†ä¸€äº›å´é“å¤©å‡‰å¥½ä¸ªç§‹çš„æ»‹å‘³ã€‚æ™šä¸Šä¸€ä¸ªäººåœ¨bonsaiçš„å§å°åƒå†·é¥­å›¢ï¼Œä¸€è¾¹æ„Ÿå—ç€çªç„¶è€Œè‡³çš„é˜µé›¨ã€‚æ²¡æœ‰ä»€ä¹ˆæ‚²æ¬¢ç¦»åˆä¹Ÿæ— æƒ…ã€‚ åªæœ‰ç‰¹åˆ«æ·±çš„å­¤ç‹¬ã€‚ ä¸€ä¸ªäººèµ°åœ¨å›å‡ºç§Ÿæˆ¿çš„è·¯ä¸Šï¼Œç©¿è¿‡ä¸åŒé¢œè‰²çš„çš®è‚¤ï¼Œæ„Ÿå—åˆ°å¤¹å¸¦ç€é›¨ä¸çš„å†·é£ã€‚ æˆ‘çªç„¶å¼€å§‹æ€€å¿µå®¶ä¹¡é—·çƒ­çš„é›¨å­£ï¼Œé‚£æ½®æ¹¿ç»µå¯†çš„æ°´æ±½å°†æˆ‘åŒ…è£¹çš„æ„Ÿè§‰ï¼Œé‚£æ±Ÿå—æ°´ä¹¡ç‰¹æœ‰çš„å‘³é“ã€‚ é‚£å‘³é“æ˜¯å¦ˆä¸¢ç»™æˆ‘çš„æ¯›å·¾çš„é¦™å‘³ï¼Œæ˜¯çˆ¸ç«¯å‡ºçš„æ¥çš„é¥­èœçš„é¦™å‘³ï¼Œæ˜¯å®¶é‡Œæ”¾ä¹…äº†çš„å®¶å…·ï¼Œåœ¨æ¢…é›¨å­£èŠ‚æ•£å‘å‡ºæ¥çš„ä¸€ç‚¹ç‚¹éœ‰å‘³ã€‚ é›¨å£°å¤¹å¸¦ç€ç”µè§†èŠ‚ç›®çš„äººå£°ï¼Œæ··åˆç€å°åŒºå¤–è¿œè¿œä¼ æ¥çš„å‡ å¥å’’éª‚ã€‚ è€Œç°åœ¨é›¨å£°é‡Œåªå‚æ‚ç€é”®ç›˜æ•²å‡»çš„å“’å“’å£°ã€‚ åå‡ å²çš„æˆ‘ä¸æ˜ç™½é›¨æ°´æ»´è½åœ°é¢çš„å£°éŸ³æ€ä¹ˆèƒ½ç”¨å¾—ä¸Šå¬ï¼Œä½†ç°åœ¨çŸ¥é“äº†ã€‚åŸæ¥åªæœ‰ç”Ÿæ´»å¹¶ä¸ä¸€å¸†é£é¡ºçš„äººï¼Œæ‰èƒ½å¬åˆ°é›¨çš„å£°éŸ³ã€‚ æˆ‘åˆä¸Šç”µè„‘ï¼Œçœ‹ç€çª—å¤–çš„é›¨å¸˜ä¸­æ¸æ¸æ˜¾å‡ºè¿œå¤„æ–¹å°–ç¢‘çš„è½®å»“ï¼Œè‹¥éšè‹¥ç°ï¼Œå±…ç„¶åƒæäº†é¼“æ¥¼ã€‚]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>éšä¾¿å†™å†™</tag>
      </tags>
  </entry>
</search>
