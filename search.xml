<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>回头看看</title>
      <link href="/2018/12/27/%E5%9B%9E%E5%A4%B4%E7%9C%8B%E7%9C%8B/"/>
      <url>/2018/12/27/%E5%9B%9E%E5%A4%B4%E7%9C%8B%E7%9C%8B/</url>
      <content type="html"><![CDATA[<p>现在静下心来，也会思考一些别的，比如两三年后的自己又会是怎么样的。和David聊天真的给了我很大的触动，他说自己年轻的时候刚去IBM，觉得有一份薪水不错的体面工作，生活安安稳稳，但是年纪慢慢增长之后，会开始思考自己应该去做些什么，或者自己内心深处想去做些什么，面试的时候他问我，你对自己的未来有规划么？<br><a id="more"></a></p><p>我很害怕这种问题，原因是这些问题会让人去认识自己，然后很深地剖析自己。这会把我内心的空洞和茫然一下子都挖掘出来，它们不想看见我，我其实也不乐意看见它们。</p><p>我毕了业，努力找到了工作，做菜变得越来越好吃，开始存钱。空暇时间保持刷题，看书，听音乐，坚持游泳。可我不能停下来，因为一停下来空虚的感觉就会慢慢侵蚀你，很奇妙的感觉，你会觉得自己的身体似乎慢慢被溶解在了这个环境里。有时候我甚至会翻看微信的好友列表看看谁会现在有空和我聊会儿天？而当我控制住这种古怪的冲动转而打开微博知乎企图杀死这些空虚后，我得到的是一整夜的无眠和加州特别刺眼的阳光。</p><p>比起这空虚的感觉，最让我感到害怕的是，我渐渐的不爱玩游戏了。小学的我偷老妈的钱去买卡带，初中的我翘了家教去黑网吧，高中的我参加着War3的线下赛，复读的我仍在玩着涂鸦跳跃，本科的我打着lol的校赛，读研的我买了Pokemon速通了二周目。现在，我感觉自己体内感受快乐的器官好像慢慢地被一些不知名的东西分解了，然后这些不知名的东西用一些笨重的，惰性的，无性质的物质填充了我原来器官所在的位置。好像没什么不同，只是当我打爆对面水晶的时候，我觉得这个游戏变得好机械，甚至有些无聊。</p><p>我泡了一杯茶，然后挑一个舒服的姿势，眯着眼听邻居大声骂他那条每天狂吠的黑背，脑子里想着10岁的我，大声的对我妈说我活到100岁也喜欢打游戏；想着自己曾经写词，写诗，研究词牌名的样子；想着我为了那个女孩嚎啕大哭的晚上。想着想着，觉得自己像只风筝，随风懒洋洋地飘着。心底唯一的一丝丝诉求，就是比边上一起飘着的风筝们，飘的稍稍高那么一点，我便知足了。有时候也会有一些的困惑，不明白吹着风筝的风到底从哪里来。不过当风变大的时候，为了飘的稳一些，也就没精力去想那些了。</p><p>思绪飘到了海对岸，朋友们可以用舞池里的音乐，用酒精，用虚情假意，用原始的肉欲来填充自己的生活。然而每一次多巴胺的潮汐褪去，他们该怎么处理不断升高的阈值？</p><p>我把茶水喝干，慢慢咀嚼嘴里残留的茶叶。大概一辈子就和这杯茶一样，茶水总有喝完的那一刻，人都得去面临咀嚼茶根的时候。只是有的人能想办法把这杯茶多泡几次，而有的人一生却只有一次冲泡的机会。</p><p>希望三年后的自己能告诉现在的我，三年后的我是不是已经能稍稍透过这些如露如电的泡影，看到了一丝自己想追逐的东西。</p>]]></content>
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便写写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Segment Tree</title>
      <link href="/2018/11/26/Segment%20Tree/"/>
      <url>/2018/11/26/Segment%20Tree/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Palindrome</title>
      <link href="/2018/11/24/Palindrome/"/>
      <url>/2018/11/24/Palindrome/</url>
      <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      <categories>
          
          <category> 刷题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Angular学习心得</title>
      <link href="/2018/11/20/Angular/"/>
      <url>/2018/11/20/Angular/</url>
      <content type="html"><![CDATA[<p>今天过了一个电面，面我的老哥让我多准备一下Angular，面试现场要写。blog上的例子都源自官方教程。</p><p>学习的过程中，ng是一个很神奇的框架，结合了许多后端才有的东西，比如DI，比如class，比如注解（装饰器）。<br>同时ng中也使用了Typescript和Rxjs这样好用的工具，虽然很重？</p><p>这是一个很大而全的东西，当然约束也很强，整个frame的规范是统一的。在大型超大型开发中会非常棒，因为大家不会因为不同的bersion而出现分歧。而且有google的人在前面吃螃蟹。</p><p>使用一些ng自己的语法来增强对HTML和DOM的操作，比如ng if。</p><p>ng让我能看到一些前后端共通的地方，学习ng的设计理念是一件很有意思的事情。<br><a id="more"></a></p><h1 id="一些使用前需要知道的概念"><a href="#一些使用前需要知道的概念" class="headerlink" title="一些使用前需要知道的概念"></a>一些使用前需要知道的概念</h1><h2 id="What-is-SPA"><a href="#What-is-SPA" class="headerlink" title="What is SPA"></a>What is SPA</h2><p>Single Page Application（单页应用）</p><h2 id="What-is-TypeScript-and-Why-ng-use-it"><a href="#What-is-TypeScript-and-Why-ng-use-it" class="headerlink" title="What is TypeScript and Why ng use it"></a>What is TypeScript and Why ng use it</h2><p>动态类型一时爽，代码重构火葬场，笑。<br>TypeScript is a superset(超集) of JavaScript which primarily provides optional static typing, classes and interfaces. One of the big benefits is to enable IDEs to provide a richer environment for spotting common errors as you type the code.</p><h3 id="静态类型检查-Optionally-static-typing-and-type-inference"><a href="#静态类型检查-Optionally-static-typing-and-type-inference" class="headerlink" title="静态类型检查(Optionally static typing and type inference)"></a>静态类型检查(Optionally static typing and type inference)</h3><p>静态类型检查可以避免很多不必要的错误, 不用在调试的时候才发现问题<br>注意: optional static typing是有原因的，因为Typescript也可以定义对象为any类，这样会忽略所有的类型检查。<br>原因: 保留了强类型在检查上的优势，也保留了弱类型的灵活。</p><h3 id="IDE智能提示-Enhanced-IDE-support"><a href="#IDE智能提示-Enhanced-IDE-support" class="headerlink" title="IDE智能提示(Enhanced IDE support)"></a>IDE智能提示(Enhanced IDE support)</h3><p>在 TypeScript 这一类语言之前, JavaScript 的智能提示基本完全依赖 IDE 提供的猜测</p><p>Now the IDE is informed in real-time by the TypeScript compiler on its rich type information.</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>有时候的确需要修改一些变量/属性/方法名, 牵涉到属性和方法的时候, 很多改动是跨文件的, 不像普通变量可以简单定位 scope, 属性方法名的重命名对于 JS 来说异常痛苦, 一方面是修改本身就不方便, 另一方面是改了还不确定该改的是不是改了, 不该改的是不是也改了.  而 TypeScript 的静态类型系统就可以较为完美的解决这个问题 (这个地方还牵涉到一些最佳实践, 就暂不深入了).</p><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>TypeScript是JavaScript的超集，所以本质上支持JS的所有语法，此外添加了一些OOD语言的特性:class/interface/module<br>同时强类型的语言申明了所有类型，结合OOD特性，代码可读性很高</p><h3 id="什么是强，弱，动态，静态类型"><a href="#什么是强，弱，动态，静态类型" class="headerlink" title="什么是强，弱，动态，静态类型"></a>什么是强，弱，动态，静态类型</h3><p>转自知乎轮子哥：<br>强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double (Java, C#)<br>弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double (C, C++)<br>静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误 (Java, Scala)<br>动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用 (JavaScript)</p><h3 id="TypeScript-VS-ES6"><a href="#TypeScript-VS-ES6" class="headerlink" title="TypeScript VS ES6"></a>TypeScript VS ES6</h3><h4 id="什么是ES6，和JavaScript的关系"><a href="#什么是ES6，和JavaScript的关系" class="headerlink" title="什么是ES6，和JavaScript的关系"></a>什么是ES6，和JavaScript的关系</h4><h3 id="TS-VS-JS"><a href="#TS-VS-JS" class="headerlink" title="TS VS JS"></a>TS VS JS</h3><h1 id="Component-and-Template"><a href="#Component-and-Template" class="headerlink" title="Component and Template"></a>Component and Template</h1><h2 id="Showing-an-array-property-with-ngfor"><a href="#Showing-an-array-property-with-ngfor" class="headerlink" title="Showing an array property with ngfor"></a>Showing an array property with ngfor</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">"let =hero of heros"</span>&gt;</span></span><br><span class="line">      &#123;&#123; hero &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Conditional-display-with-NgIf"><a href="#Conditional-display-with-NgIf" class="headerlink" title="Conditional display with NgIf"></a>Conditional display with NgIf</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">ngIf</span>=<span class="string">"hero.length &gt; 3"</span>&gt;</span>There are many heroes!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h1><p>数据绑定是非常重要的一部分。Ng实现双向数据绑定的方法和其他的框架相比有很多不同的地方。</p><h2 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h2><p>直接在html中插入, value的变化会直接更新到html上<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;hero.name | uppercase&#125;&#125; Details<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>The easiest way to display a component property is to bind the property name through interpolation（插值表达式）. With interpolation, you put the property name in the view template, enclosed in double curly braces: .</p><p>The word uppercase in the interpolation binding, right after the pipe operator ( | ), activates the built-in UppercasePipe.</p><p>Pipes are a good way to format strings, currency amounts, dates and other display data. Angular ships with several built-in pipes and you can create your own.</p><h2 id="Property-Binding"><a href="#Property-Binding" class="headerlink" title="Property Binding"></a>Property Binding</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Input() hero: Hero;</span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> [<span class="attr">hero</span>]=<span class="string">"selectedHero"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The hero property must be an Input property, annotated with the @Input() decorator.<br>Because the external HeroesComponent will bind to it like this.<br>模板语法是[]</p><h2 id="Event-Binding"><a href="#Event-Binding" class="headerlink" title="Event Binding"></a>Event Binding</h2><p>This is an example of Angular’s event binding syntax.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">"let hero of heroes"</span> (<span class="attr">click</span>)=<span class="string">"onSelect(hero)"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>语法是()</p><h2 id="Two-way-binding-ngModel"><a href="#Two-way-binding-ngModel" class="headerlink" title="Two-way binding [(ngModel)]"></a>Two-way binding [(ngModel)]</h2><p>step1. Import the FormsModule symbol from the @angular/forms library.<br>step2. Then add FormsModule to the @NgModule metadata’s imports array, which contains a list of external modules that the app needs.<br>step3. Use [(ngModel)]=”value”<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">"hero.name"</span> <span class="attr">placeholder</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Ng实现双向绑定的原理"><a href="#Ng实现双向绑定的原理" class="headerlink" title="Ng实现双向绑定的原理"></a>Ng实现双向绑定的原理</h3><ol><li>Dirty Checking（脏检查）</li></ol><h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><p>Services are a great way to share information among classes that don’t know each other.<br>Rely on Angular dependency injection to inject it into the component constructor.</p><p>Services用到了DI-依赖注入的思想，参考Srping。</p><p>引入服务（services）的目的是为了让组件尽量的薄，让组件只处理和template相关的数据绑定。</p><p>Ideally, a component’s job is to enable the user experience and nothing more. A component should present properties and methods for data binding, in order to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model).</p><p>## </p><h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><h3 id="Why-we-use-Observable"><a href="#Why-we-use-Observable" class="headerlink" title="Why we use Observable"></a>Why we use Observable</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.heroes = this.heroService.getHeroes();</span><br></pre></td></tr></table></figure><p>HeroService.getHeroes() must have an asynchronous signature of some kind.（需要异步交互）</p><h3 id="Observable-HeroService"><a href="#Observable-HeroService" class="headerlink" title="Observable HeroService"></a>Observable HeroService</h3><h2 id="service-in-service"><a href="#service-in-service" class="headerlink" title="service-in-service"></a>service-in-service</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor(private messageService: MessageService) &#123; &#125;</span><br></pre></td></tr></table></figure><p>Inject the MessageService into the HeroService which is injected into the HeroesComponent.</p><p>Loosely-coupled communication between classes.</p><h1 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h1><p>Directives are instructions in the DOM!</p><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><h1 id="Difference-between-Angular-Vue"><a href="#Difference-between-Angular-Vue" class="headerlink" title="Difference between Angular, Vue"></a>Difference between Angular, Vue</h1><h2 id="Difference-between-Angular-and-Vue"><a href="#Difference-between-Angular-and-Vue" class="headerlink" title="Difference between Angular and Vue."></a>Difference between Angular and Vue.</h2><ol><li>Ng大而全，Vue小而精致。Ng的约束性很强，更适合团队开发</li><li>两者对于two-way data banding的实现是不同的。</li></ol><h1 id="一些轮子的整合"><a href="#一些轮子的整合" class="headerlink" title="一些轮子的整合"></a>一些轮子的整合</h1><p>因为ng使用了typescript导致一些没法直接require Js file，需要CLI的帮助。</p><h2 id="Use-bootstrap"><a href="#Use-bootstrap" class="headerlink" title="Use bootstrap"></a>Use bootstrap</h2><ol><li>cd into current folder, and npm install –save bootstrap@3. This bootstrap is local, not global.</li><li>open angular.json, import bootstrap.min.css into styles (acutally add address into styles).</li></ol><h2 id="Use-D3-js"><a href="#Use-D3-js" class="headerlink" title="Use D3.js"></a>Use D3.js</h2><h3 id="D3-和-Echarts的区别"><a href="#D3-和-Echarts的区别" class="headerlink" title="D3 和 Echarts的区别"></a>D3 和 Echarts的区别</h3><ol><li>D3基于SVG, Echarts基于Canvas。<pre><code>SVG                               Canvas</code></pre>1.不依赖分辨率(矢量图，放大缩小不影响精度)                                      1.<br>2.支持事件处理器(基于XML的绘图，能操作到每一个DOM)<br>3.最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>4.复杂度高会减慢渲染速度</li></ol><h1 id="一些面试会遇到的问题"><a href="#一些面试会遇到的问题" class="headerlink" title="一些面试会遇到的问题"></a>一些面试会遇到的问题</h1><h2 id="let-and-const-in-Angular"><a href="#let-and-const-in-Angular" class="headerlink" title="let and const in Angular"></a>let and const in Angular</h2>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>left to right/right to left problems</title>
      <link href="/2018/11/09/left%20to%20right%20&amp;%20right%20to%20left%20problems/"/>
      <url>/2018/11/09/left%20to%20right%20&amp;%20right%20to%20left%20problems/</url>
      <content type="html"><![CDATA[<p>都是一些需要从左扫一遍再从右扫一遍的题，或者是需要两个数组来maintain每个index对应的左右值。<br><a id="more"></a></p><h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53 Maximum Subarray"></a>53 Maximum Subarray</h1><h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121 Best Time to Buy and Sell Stock"></a>121 Best Time to Buy and Sell Stock</h1><h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152 Maximum Product Subarray"></a>152 Maximum Product Subarray</h1><h1 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238 Product of Array Except Self"></a>238 Product of Array Except Self</h1><p>基本思路：</p><ol><li>能用除法的话太简单了，直接进入不能的情况</li><li>先用一个res[]来存前缀积，从左往右，res[0] = 1, res[i] = res[i - 1] <em> nums[i - 1]<br>arr 1 2 3 4<br>res 1 1 2 6<br>因为4是没乘的那个数，所以此时res[3]就是4对应的值<br>引入一个变量index，此时index = 1<br>res[3] = 6 </em> index = 6,  index = 1 <em> 4<br>res[2] = 2 </em> index = 8,  index = 4 <em> 3<br>res[1] = 1 </em> index = 12, index = 12 <em> 2<br>res[0] = 1 </em> index = 24, index = 24 * 1  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;<span class="comment">//pre product</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">// 从右边再循环一次，res[n] = res[n] * the product of right numbers</span></span><br><span class="line">            res[i] = res[i] * index; </span><br><span class="line">            index = index * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739 Daily Temperatures"></a>739 Daily Temperatures</h1><h1 id="768-Max-Chunks-to-Make-Sorted-II"><a href="#768-Max-Chunks-to-Make-Sorted-II" class="headerlink" title="768 Max Chunks to Make Sorted II"></a>768 Max Chunks to Make Sorted II</h1><p>要求1：将数组分割成不同的部分，将分割的部分各自排序后再拼接，能否得到一个排序后的原数组。<br>      比如：21043，可以分割成210|43两个部分，各自排序后得到012|34。<br>要求2：满足1的前提下，要尽量多的分割这个数组</p><p>基本思路：<br>21043为例，如果我们能确保nums[index]左边的数都比它小，那么这一部分就可以被分割排序，因为他们的排序对后面的部分不影响。<br>所以需要两个数组，一个记录当前index的左边的max最大值是多少，一个记录index的右边的最小值是多少。<br>如果说leftmax &lt;= rightmin，那么就可以分割。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] l = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        l[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            l[i] = Math.max(l[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        r[len - <span class="number">1</span>] = arr[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            r[i] = Math.min(arr[i], r[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[i] &lt;= r[i + <span class="number">1</span>])</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="821-Shortest-Distance-to-a-Character"><a href="#821-Shortest-Distance-to-a-Character" class="headerlink" title="821 Shortest Distance to a Character"></a>821 Shortest Distance to a Character</h1><p>基本思路：<br>“loveleetcode” “e”<br>step1. put 0 at all position equals to e, and max at all other position<br>   we will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0]<br>step2. scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]),<br>   we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0]<br>step3. scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1])<br>   we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]<br>解释的很清楚了<br>第一遍从左到右扫描，记录当前character左边最近的字符C的距离，+1表示比之前的距离多了一格<br>第一遍从右到左扫描，记录当前character右边最近的字符C的距离<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == C) &#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i + <span class="number">1</span>] = Math.min(nums[i] + <span class="number">1</span>, nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            nums[i - <span class="number">1</span>] = Math.min(nums[i - <span class="number">1</span>], nums[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="838-Push-Dominoes"><a href="#838-Push-Dominoes" class="headerlink" title="838. Push Dominoes"></a>838. Push Dominoes</h1><p>基本思路：<br>此题关键在于，如何将这个抽象的问题转化成一个能用代码解决的问题。<br>答案是使用一个数组force，force[i]来表示当前这块多米诺牌受到的来自左边的力和右边的力的和。<br>从左往右scan时，处理的是来自右边的力，向右的力会从左向右衰减，同理从右向左处理来自左边的力</p><p>举例说明：<br>.L.R…LR..L..<br>整个String 长度为14，此时推一下，力的大小为14.<br>step1. 进行从左到右的scan，如果当前多米诺牌为R，那么它受到的力为14，它右边的牌受到的力为13，以此类推<br>       当遇到一块多米诺牌为L时，当前的力被重置为0（向左推的牌不会被来自右边的力影响）。需要注意每块牌的受力不会小于0.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时的force数组为：. L .  R  .  .  . L  R  .  . L . .</span><br><span class="line">                 <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">14</span> <span class="number">13</span> <span class="number">12</span> <span class="number">11</span> <span class="number">0</span> <span class="number">14</span> <span class="number">13</span> <span class="number">12</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><br>step2. 根据和第一步相同的原理，对每块牌处理来自左边的力。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时的force数组为：  .  L  . R   .   .   .   L  R  .    .  L  . .</span><br><span class="line">                 -<span class="number">13</span> -<span class="number">14</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">11</span> -<span class="number">12</span> -<span class="number">13</span> -<span class="number">14</span>  <span class="number">0</span> -<span class="number">12</span> -<span class="number">13</span> -<span class="number">14</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><br>step3. 相加后根据force[i]的正负性判断左右的力哪个强，得到L或R，0的话表示力持平。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pushDominoes</span><span class="params">(String dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = dominoes.length();</span><br><span class="line">        <span class="keyword">int</span>[] force = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = dominoes.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'R'</span>) &#123;</span><br><span class="line">                f = len;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                f = Math.max(f - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            force[i] = f;</span><br><span class="line">        &#125;</span><br><span class="line">        f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = dominoes.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'L'</span>) &#123;</span><br><span class="line">                f = -len;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'R'</span>) &#123;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                f = Math.min(f + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            force[i] += f;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : force) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">"R"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">"L"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="845-Longest-Mountain-in-Array"><a href="#845-Longest-Mountain-in-Array" class="headerlink" title="845 Longest Mountain in Array"></a>845 Longest Mountain in Array</h1><p>基本思路：<br>狗家面筋，找数组中的小山。基本思路就是用两个array，从左扫描找山的左半部分，存下来，从右扫描存山的右半部分，存下来。<br>最后再用一个array，一边拼接一边找出最大的山峰。一共用了三个for loop，两个array。</p><p>follow up：<br>one pass，no extra space<br>用双指针，up和down分别代表之前的数组，up和down实时更新。<br>当遇到一座山已经走完时，将up和down重置为0，新的一座山只有在前一座山走完之后才能遇到。<br>山走完有两种情况：</p><ol><li>down指针不为0且遇到开始上升的part</li><li>前后两值相等时。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span> , down = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="comment">// down指针不为0且遇到开始上升的part &amp;&amp; 前后两值相等时。</span></span><br><span class="line">            <span class="keyword">if</span> (down &gt; <span class="number">0</span> &amp;&amp; A[i] &gt; A[i - <span class="number">1</span>] || A[i] == A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = <span class="number">0</span>;</span><br><span class="line">                up = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) up++;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) down++;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; <span class="number">0</span> &amp;&amp; down &gt; <span class="number">0</span> &amp;&amp; up + down + <span class="number">1</span> &gt; res) &#123;</span><br><span class="line">                res = up + down + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeloops</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] l = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(l, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(r, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                l[i] = l[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                r[i] = r[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[i] != <span class="number">0</span> &amp;&amp; r[i] != <span class="number">0</span>)</span><br><span class="line">                res = Math.max(res, l[i] + r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span> ? res + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数学计算和一些数学问题</title>
      <link href="/2018/10/30/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98/"/>
      <url>/2018/10/30/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>总结LC中出现的包括的数学计算问题，包括实现除法，实现pow(), 实现sqrt(), 实现计算器和一些偏数学的题<br><a id="more"></a></p><h1 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h1><h2 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h2><p>这题最近狗家出过，虽然是FB tag。实现除法<br>基本思路：</p><ol><li>处理corner case:<br>除数为0，返回MAX_VALUE<br>被除数为MIN_VALUE，除数为-1，会越界，所以人工返回MAX_VALUE，除数为1则返回原值</li><li>将除数被除数转为long，避免计算过程中越界</li><li>使用 &lt;&lt; 符号，A &lt;&lt; B 表示 A * 2的B次方</li><li>使用int signal表示结果的正负号，被除数和除数都先处理为整数，用signal表示结果的正负</li><li>举例：32 / 3<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loop:  <span class="number">32</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">0</span> -&gt; <span class="number">32</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">1</span> -&gt; <span class="number">32</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">2</span> - &gt; <span class="number">32</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">3</span></span><br><span class="line">until: <span class="number">32</span> &lt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">4</span>，目前一共使用了<span class="number">2</span>^<span class="number">3</span>个 <span class="number">3</span> </span><br><span class="line"></span><br><span class="line">将被除数减去目前已经计算好的部分，即<span class="number">32</span> - <span class="number">3</span> * <span class="number">2</span>^<span class="number">3</span> = <span class="number">32</span> - <span class="number">24</span> = <span class="number">8</span>, 此时res = <span class="number">8</span></span><br><span class="line">loop:  <span class="number">8</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">0</span> -&gt; <span class="number">8</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">1</span></span><br><span class="line">until: <span class="number">8</span> &gt; <span class="number">3</span> * <span class="number">2</span>^<span class="number">2</span></span><br><span class="line"></span><br><span class="line">将被除数减去目前已经计算好的部分，即<span class="number">8</span> - <span class="number">3</span> * <span class="number">2</span>^<span class="number">1</span> = <span class="number">8</span> - <span class="number">6</span> = <span class="number">2</span>, 此时res = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">此时被除数小于除数，跳出循环。<span class="number">32</span> / <span class="number">3</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> signal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d1 = (<span class="keyword">long</span>) dividend;</span><br><span class="line">        <span class="keyword">long</span> d2 = (<span class="keyword">long</span>) divisor;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (d1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d1 = -d1;</span><br><span class="line">            signal = -signal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d2 = -d2;</span><br><span class="line">            signal = -signal;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (d1 &gt;= d2) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (d1 &gt;= d2 &lt;&lt; count) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (<span class="number">1</span> &lt;&lt; (count - <span class="number">1</span>));</span><br><span class="line">            d1 -= (d2 &lt;&lt; (count - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * signal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h2><p>基本思路:<br>实现开更号， 通过二分实现</p><ol><li><p>这题首先要避免越界。因此mid * mid &gt; x 应该写成 mid &gt; x / mid.</p></li><li><p>这时候就要避免mid = 0。<br>当right - left = 1时，mid = left（right = 1, left = 0, mid = 0）所以left不能从0开始。<br>所以搜索范围确定为1 ~ x（x的平方必定大于x）</p></li><li><p>接下来要处理的问题是，如果找不到target sqrt，该怎么返回值。<br>用7举例<br>搜索区间到达[2,3]时，mid = 2, left = mid + 1 = 3.<br>搜索区间到达[3,3]时，mid = 3, left = 3, right = 3 - 1 = 2。跳出循环。<br>可以发现mid其实是刚好平方后大于x的那个值，因此我们返回的right = mid - 1就是解。</p></li><li><p>这时候要考虑下Corner Case，比如input是0或者2147483647。逻辑走完发现没啥问题。</p></li><li><p>如果面试官要求精度，那么这题最好使用牛顿法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = x;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid == x / mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h2><p>基本思路: 实现x^n，很不喜欢这题，因为conner case太烦了。基于递归实现</p><ol><li>因为 x 的n次方 = x 的n/2次方 * x的n/2次方，所以recursion就出来了。odd就是拿一个出来再/2，很容易想到</li><li>然后是处理n &lt; 0的情况，就是进入递归前把n取反，x = 1/x</li><li>这里出现问题，if n = Inetegr.MIN_VALUE，取反就overflow，因此要做一个处理</li><li>注意处理n之后也不要忘了x;<br>因为n从-2147483648 变成了 214748364747，正负会有影响：x = x &gt; 0 ? 1.0 / x : -(1.0 / x);<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                n = -(n + <span class="number">1</span>);</span><br><span class="line">                x = x &gt; <span class="number">0</span> ? <span class="number">1.0</span> / x : -(<span class="number">1.0</span> / x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                n = -n;</span><br><span class="line">                x = <span class="number">1.0</span> / x;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x * myPow(x * x, n /<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="224-Basic-Calculator"><a href="#224-Basic-Calculator" class="headerlink" title="224. Basic Calculator"></a>224. Basic Calculator</h2><p>基本思路：<br>实现一个计算器，运算符号包括+, -, ()。</p><h1 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h1><h2 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h2><p>题意：<br>给你一个数比如158476531，让你找出一个Math.min(所有比它大的数)，这里的数只能是原数的permutation。<br>基本思路：<br>decreasing的部分是没有比它大的permutation，reverse过后能保证这段是最小的<br>这个solution的图解做的很棒，可以看看帮助加深印象。<br><a href="https://leetcode.com/problems/next-permutation/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/next-permutation/solution/</a><br>step1. 从尾道头扫描，找到第一个处于不是decreasing序列的数num，比如158476531就是4.<br>step2. 对于num，从num开始向右扫描，找到almost larger than num的数，例子中就是5<br>step3. 交换4，5的位置，得到158576431<br>step4. reverse decreasing 的那部分，得到158513467<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length, index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index1 = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[index]) &#123;</span><br><span class="line">                index1 = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, index, index1);</span><br><span class="line">        reverse(nums, index + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(nums, i ,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="238-Product-of-Array-Except-Self（脸家tag）"><a href="#238-Product-of-Array-Except-Self（脸家tag）" class="headerlink" title="238. Product of Array Except Self（脸家tag）"></a>238. Product of Array Except Self（脸家tag）</h2><p>基本思路：</p><ol><li>能用除法的话太简单了，直接进入不能的情况</li><li>先用一个res[]来存前缀积，从左往右，res[0] = 1, res[i] = res[i - 1] <em> nums[i - 1]<br>arr 1 2 3 4<br>res 1 1 2 6<br>因为4是没乘的那个数，所以此时res[3]就是4对应的值<br>引入一个变量index，此时index = 1<br>res[3] = 6 </em> index = 6,  index = 1 <em> 4<br>res[2] = 2 </em> index = 8,  index = 4 <em> 3<br>res[1] = 1 </em> index = 12, index = 12 <em> 2<br>res[0] = 1 </em> index = 24, index = 24 * 1  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;<span class="comment">//pre product</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">// 从右边再循环一次，res[n] = res[n] * the product of right numbers</span></span><br><span class="line">            res[i] = res[i] * index; </span><br><span class="line">            index = index * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h2><p>基本思路: 狗家tag下的题，值得一做，完全平方数</p><ol><li><h2 id="247-Strobogrammatic-Number-II-狗家面筋题"><a href="#247-Strobogrammatic-Number-II-狗家面筋题" class="headerlink" title="247. Strobogrammatic Number II(狗家面筋题)"></a>247. Strobogrammatic Number II(狗家面筋题)</h2><p>基本思路：<br>step1 选定一个center，然后在左右append对称的数。<br>step2 如果是偶数，则center从 “” 开始，如果是奇数，center从0, 1, 8开始。<br>step3 最后一次append时，要注意不能加0，这样是meaningless的。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(n, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line">        <span class="comment">// even</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>));</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; center = helper(n - <span class="number">2</span>, m);</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; center.size(); i++) &#123;</span><br><span class="line">            String cur = list.get(i);</span><br><span class="line">            <span class="comment">// avoid add 00 in the last step, becasue it's meaningless</span></span><br><span class="line">            <span class="keyword">if</span> (n != m) res.add(<span class="string">"0"</span> + cur + <span class="string">"0"</span>);</span><br><span class="line">            res.add(<span class="string">"1"</span> + cur + <span class="string">"1"</span>);</span><br><span class="line">            res.add(<span class="string">"6"</span> + cur + <span class="string">"9"</span>);</span><br><span class="line">            res.add(<span class="string">"8"</span> + cur + <span class="string">"8"</span>);</span><br><span class="line">            res.add(<span class="string">"9"</span> + cur + <span class="string">"6"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode中的Word,String题</title>
      <link href="/2018/10/28/LeetCode%E4%B8%AD%E7%9A%84Word%E9%A2%98/"/>
      <url>/2018/10/28/LeetCode%E4%B8%AD%E7%9A%84Word%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>很多经典题，其实不难想，但是写起来有很多要注意的东西，把思路写一下，面试时候解释起来也更顺。<br><a id="more"></a></p><h1 id="126-Word-Ladder-II"><a href="#126-Word-Ladder-II" class="headerlink" title="126. Word Ladder II"></a>126. Word Ladder II</h1><p>基本思路：<br>1.先用BFS进行构图，连接每个单词。使用两个HashMap：paths &amp; levels。<br>  paths  用来存每个word和它的children的关系，是Map&lt;String, List<string>&gt;, 用于之后DFS遍历<br>  levels 用来存每个word和当前level，或者说step的关系，是Map&lt;String, Integer&gt;</string></p><p>2.使用levels的原因：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   hit             level <span class="number">1</span></span><br><span class="line"> /     \</span><br><span class="line">hot    lit         level <span class="number">2</span></span><br><span class="line"> \     /  \</span><br><span class="line">   lot    lid      level <span class="number">3</span></span><br><span class="line">     \     /</span><br><span class="line">       lod         level <span class="number">4</span></span><br></pre></td></tr></table></figure><br>  当BFS到达hot（即queue中poll出hot）时，lot作为一个可选child已经被放入visited set<br>  但lot也是lit的可选child，而因为此时lot has been visited，lot不会被加入lit的children list。所以我们需要levels<br>  Now levels contains key lot，and level of lot is 3（在hot那一步存的）<br>  so if level of lot == level of lit + 1，那么lot就可以被加入lit的children list</p><p>3.如果已经找到end（fount == true），不要把end放到visited中，用来避免其他的路径无法添加end到自己的list中。</p><p>4.DFS遍历paths，通过backtracking输出所有的可能答案。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String begin, String end, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; paths = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; levels = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        HashSet&lt;String&gt; dic = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        q.offer(begin);</span><br><span class="line">        visited.add(begin);</span><br><span class="line">        levels.put(begin, level);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; !found) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">                String cur = q.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  cur.length(); i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] ch = cur.toCharArray();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        ch[i] = c;</span><br><span class="line">                        String temp = <span class="keyword">new</span> String(ch);</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(temp) &amp;&amp; dic.contains(temp)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (temp.equals(end)) &#123;</span><br><span class="line">                                found = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!paths.containsKey(cur)) &#123;</span><br><span class="line">                                paths.put(cur, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">                            &#125;</span><br><span class="line">                            paths.get(cur).add(temp);</span><br><span class="line">                            q.offer(temp);</span><br><span class="line">                            <span class="comment">// if we have found the shortest path, don't add end word to visited set</span></span><br><span class="line">                            <span class="comment">// Because the next word still need to use this if condition to make path</span></span><br><span class="line">                            <span class="keyword">if</span> (!found) visited.add(temp);</span><br><span class="line">                            levels.put(temp, level + <span class="number">1</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (levels.containsKey(temp))&#123;</span><br><span class="line">                            <span class="keyword">if</span> (levels.get(temp) == levels.get(cur) + <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// 之前的if中，可能没有把cur存到paths里，所以这里也要做一个判断</span></span><br><span class="line">                                <span class="keyword">if</span> (!paths.containsKey(cur)) &#123;</span><br><span class="line">                                    paths.put(cur, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">                                &#125;</span><br><span class="line">                                paths.get(cur).add(temp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(begin);</span><br><span class="line">        dfs(res, list, begin, end, paths, levels);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, String cur, String end, </span></span></span><br><span class="line"><span class="function"><span class="params">                    Map&lt;String, List&lt;String&gt;&gt; paths, Map&lt;String, Integer&gt; levels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(end)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// need check since somtimes we can't find path to reach the endWord</span></span><br><span class="line">        <span class="keyword">if</span> (!paths.containsKey(cur) || paths.get(cur).size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String next : paths.get(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (levels.get(cur) + <span class="number">1</span> == levels.get(next)) &#123;</span><br><span class="line">                list.add(next);</span><br><span class="line">                dfs(res, list, next, end, paths, levels);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swap相关的题</title>
      <link href="/2018/10/23/Swap%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98/"/>
      <url>/2018/10/23/Swap%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天和一个傻逼亚麻recruiter打电话，妈的问了三个问题直接叹了个气挂电话了。<br>明明是个白皮口音还没上次的黑哥来的清楚。我问他你觉得我讲的清楚么，他说你自己清楚就行。<br>？？？？？？？</p><p>我真是醉了。刷题了刷题了。.<br><a id="more"></a></p><h1 id="非LC的题。"><a href="#非LC的题。" class="headerlink" title="非LC的题。"></a>非LC的题。</h1><h2 id="Minimum-number-of-swaps-required-to-sort-an-array"><a href="#Minimum-number-of-swaps-required-to-sort-an-array" class="headerlink" title="Minimum number of swaps required to sort an array"></a>Minimum number of swaps required to sort an array</h2><p>基本思路：<br><a href="https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/</a><br><a href="https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_r=internal-search" target="_blank" rel="noopener">https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_r=internal-search</a><br>出现在狗家的面试中。涉及到置换群。（用LC854的思路做BFS也能解大概）但是置换群的时空间复杂度都只要On。</p><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="801-Minimum-Swaps-To-Make-Sequences-Increasing"><a href="#801-Minimum-Swaps-To-Make-Sequences-Increasing" class="headerlink" title="801. Minimum Swaps To Make Sequences Increasing"></a>801. Minimum Swaps To Make Sequences Increasing</h2><p>基本思路：<br>不看答案不会做的DP题。</p><ol><li>首先明确题目保证必定有解，那么对于数组A和B，在 i-1 和 i 的位置上只有两种情况<br>第一种：A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]<br>第二种：A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]<br>原因也很简单，如果原本的序列不是递增的，那么交换后必须递增。<br>例如：<br>3 5 4，发现4 &lt; 5， 不满足第一个condition，那么就得满足第二个condition，不然没法保证一定有答案。<br>2 3 7<br><em>注意</em>这两个条件是可以同时满足的，因此必须用两个if来判断。</li><li>使用两个数组，swap 和 keep，swap表示当前位置交换，keep表示当前位置不交换。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] swap = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] keep = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">// 这儿有个小trick，就是condition 1 不满足的情况下，swap[i]的值其实就是keep[i - 1] + 1</span></span><br><span class="line">        <span class="comment">// 所以得保证此时swap[i]是n，这样就能取到想要的值</span></span><br><span class="line">        <span class="comment">// 所以这里的赋值是很有意义的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            swap[i] = i;</span><br><span class="line">            keep[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swap[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 已经交换了下标0的两个element，既然交换了就要 +1, 这里交换不影响</span></span><br><span class="line">        keep[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 没交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里其实判断的是都换和都不换</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>] &amp;&amp; B[i] &gt; B[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// i - 1那组换了，为了保证increasing，i这组也得换，因为换了所以 + 1</span></span><br><span class="line">                swap[i] = swap[i - <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">                <span class="comment">// i - 1那组没换，所以i这组也不用换</span></span><br><span class="line">                keep[i] = keep[i - <span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; B[i - <span class="number">1</span>] &amp;&amp; B[i] &gt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 决定换，因为i-1那组和i这组都换的情况在之前已经计算过了，所以和i - 1没换，但是i换的情况比较。</span></span><br><span class="line">                swap[i] = Math.min(swap[i], keep[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 决定不换，因为i-1那组和i这组都不换的情况在之前已经计算过了，所以和i - 1换，但是不换的情况比较。</span></span><br><span class="line">                keep[i] = Math.min(swap[i - <span class="number">1</span>], keep[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(swap[len - <span class="number">1</span>], keep[len - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="854-K-Similar-Strings"><a href="#854-K-Similar-Strings" class="headerlink" title="854. K-Similar Strings"></a>854. K-Similar Strings</h2><p>基本思路：<br>对于String A，最少交换几次可以得到String B。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kSimilarity</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.equals(B)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(A);</span><br><span class="line">        HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(A);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">                String s = q.poll();</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (s.charAt(i) == B.charAt(i)) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(j) == B.charAt(j) || s.charAt(i) != B.charAt(j)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String cur = swap(s, i, j);</span><br><span class="line">                    <span class="keyword">if</span> (cur.equals(B)) <span class="keyword">return</span> step;</span><br><span class="line">                    <span class="keyword">if</span> (visited.add(cur)) &#123;</span><br><span class="line">                        q.offer(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">swap</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> temp = ch[i];</span><br><span class="line">        ch[i] = ch[j];</span><br><span class="line">        ch[j] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 刷题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Map，Hash和Map的题</title>
      <link href="/2018/09/06/Java%E4%B8%AD%E7%9A%84Map/"/>
      <url>/2018/09/06/Java%E4%B8%AD%E7%9A%84Map/</url>
      <content type="html"><![CDATA[<p>算是一个上课总结吧，复习复习一下Map，等面试的日子有点难熬的。<br><a id="more"></a><br>这个总结的比我自己到位，包括collision，double size，hash function，equals function等等<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E4%B8%80%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E4%B8%80%E6%A6%82%E8%A7%88</a></p><h1 id="常用的Map"><a href="#常用的Map" class="headerlink" title="常用的Map"></a>常用的Map</h1><p>TreeMap：基于红黑树实现。查找删除O(logN)</p><p>HashMap：基于哈希表实现。查找删除O(1)</p><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p><p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p><h1 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h1><p>HashTable 使用 synchronized 来进行同步。<br>HashMap   可以插入键为 null 的 Entry。<br>HashMap   迭代器是 fail-fast 迭代器。<br>HashMap   不能保证随着时间的推移 Map 中的元素次序是不变的。</p><h1 id="如何实现hash方法"><a href="#如何实现hash方法" class="headerlink" title="如何实现hash方法"></a>如何实现hash方法</h1><p>A long time ago, I bought a data structures book off the bargain table for $1.25. In it, the explanation for a hashing function said that it should ultimately mod by a prime number because of “the nature of math”.<br>What do you expect from a $1.25 book?<br>Anyway, I’ve had years to think about the nature of math, and still can’t figure it out.</p><p>笑尿，但是确实有很多人和我一样疑惑为什么hash时候要选择prime number，是因为数学的本质么。</p><p>the size of buckets is a power of 2, so use prime number can reduce collision. Becasue people usually compute index of each bucket based on hashcode % size.</p><p>It turns out that “because of the nature of maths”, if the constant used in the hash, and the number of buckets, are coprime, then collisions are minimised in some common cases.</p><h1 id="Leetcode的相关题目"><a href="#Leetcode的相关题目" class="headerlink" title="Leetcode的相关题目"></a>Leetcode的相关题目</h1><h2 id="187-Repeated-DNA-Sequences"><a href="#187-Repeated-DNA-Sequences" class="headerlink" title="187. Repeated DNA Sequences"></a>187. Repeated DNA Sequences</h2><h2 id="word-pattern-amp-word-pattern-II"><a href="#word-pattern-amp-word-pattern-II" class="headerlink" title="word pattern &amp; word pattern II"></a>word pattern &amp; word pattern II</h2><h2 id="560-Subarray-Sum-Equals-K"><a href="#560-Subarray-Sum-Equals-K" class="headerlink" title="560. Subarray Sum Equals K"></a>560. Subarray Sum Equals K</h2><p>基本思路：<br>用HashMap去maintain前缀和，if (map.containsKey(当前sum - k))，res加上对应的值<br>要注意存在corner case：nums[0] == target<br>此时需要现在map中放入一个(0, 1)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                res += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="791-Custom-Sort-String（狗家面筋题）"><a href="#791-Custom-Sort-String（狗家面筋题）" class="headerlink" title="791. Custom Sort String（狗家面筋题）"></a>791. Custom Sort String（狗家面筋题）</h2><p>基本思路：<br>先分类到HashMap，问题是对String A，根据String B的顺序排序。<br>step1: 用一个map或者freq[]数组把需要排序的String的each character存进去。<br>step2: 扫描String B，如果当前character不为空，则用一个while loop直接把存入的character全部append。<br>step3: 根据字母表顺序扫描一遍freq[], 如果仍有character存在，同step2.</p><p>follow up：<br>String A 特别长，如何mapreduce。<br>基本思路：<br>分段处理。得到处理完的String list。对这个list进行merge，思路和merge k sorted list相同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">customSortString</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : T.toCharArray()) &#123;</span><br><span class="line">            freq[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (freq[c - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                freq[c - <span class="string">'a'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (freq[c - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                freq[c - <span class="string">'a'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2018/08/27/Dynamic%20Programming/"/>
      <url>/2018/08/27/Dynamic%20Programming/</url>
      <content type="html"><![CDATA[<p>今天听了Casablanca，特别有触动。加上工卡也批了，还是蛮快乐的(最近最快乐的一天)。</p><p>上了课，复习一下。动态规划的核心就是状态的转移，而状态的转移通过状态转移方程和相对应的数据结构来表现。</p><p>通过题目应该更好理解。<br><a id="more"></a><br>先从LC都没兴趣放的基本题目开始（有些题居然有，很恐怖）。</p><h1 id="基本题"><a href="#基本题" class="headerlink" title="基本题"></a>基本题</h1><h2 id="LCS-Longest-Common-Subsequence"><a href="#LCS-Longest-Common-Subsequence" class="headerlink" title="LCS(Longest Common Subsequence)"></a>LCS(Longest Common Subsequence)</h2><p>LCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3.<br>LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.length();</span><br><span class="line">        <span class="keyword">int</span> n = b.length();</span><br><span class="line">        <span class="keyword">char</span>[] A = a.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] B = b.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Longest-Increasing-Subsequence-LC300"><a href="#Longest-Increasing-Subsequence-LC300" class="headerlink" title="Longest Increasing Subsequence(LC300)"></a>Longest Increasing Subsequence(LC300)</h2><p>基本思路：<br>用DP解就是n2。<br>follow up：能更快么？DP的过程中可以2分，达到nlogn。</p><h2 id="Longest-Bitonic-Subsequence"><a href="#Longest-Bitonic-Subsequence" class="headerlink" title="Longest Bitonic Subsequence"></a>Longest Bitonic Subsequence</h2><p><a href="https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/</a><br>基本思路：<br>找数组中最长的小山，这里小山不是subarray而是subsequence，所以用dp做。<br>（小山是subarray的情况放在left to right &amp;&amp; right to left那篇）<br>基本思路和LIS是一样的，只不过左右各来了一遍。</p><h2 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h2><p>基本思路：<br>旅行商问题。</p><h1 id="LC原题"><a href="#LC原题" class="headerlink" title="LC原题"></a>LC原题</h1><h2 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h2><p>基本思路：<br>也是个高频面筋题吧，狗家的。感觉LC前300题都还挺经典的。</p><h2 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. Minimum Path Sum</h2><p>基本思路：<br>经典题，二维DP bottom-up，follow up的话就是如何不用extra space来作dp</p><h2 id="91-Decode-Ways（脸狗面筋）"><a href="#91-Decode-Ways（脸狗面筋）" class="headerlink" title="91. Decode Ways（脸狗面筋）"></a>91. Decode Ways（脸狗面筋）</h2><p>基本思路：<br>需要人为给dp[0] and dp[1] 赋值，因为<br>int first = s.substring(i - 1, i); int second = s.substring(i - 2, i);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="number">2294</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">i = <span class="number">2</span>  <span class="keyword">int</span> first = <span class="number">2</span>; <span class="keyword">int</span> second = <span class="number">22</span>，都是有效的，dp[<span class="number">2</span>] += dp[<span class="number">0</span>] + dp[<span class="number">1</span>] = <span class="number">2</span>; </span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>     / <span class="number">22</span>)</span><br><span class="line">i = <span class="number">3</span>  <span class="keyword">int</span> first = <span class="number">9</span>; <span class="keyword">int</span> second = <span class="number">29</span>，<span class="number">29</span>是无效的，dp[<span class="number">3</span>] += dp[<span class="number">2</span>] = <span class="number">2</span>;         </span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">9</span>   / <span class="number">22</span>, <span class="number">9</span>)</span><br><span class="line">i = <span class="number">4</span>  <span class="keyword">int</span> first = <span class="number">4</span>; <span class="keyword">int</span> second = <span class="number">49</span>，<span class="number">49</span>是无效的，dp[<span class="number">4</span>] += dp[<span class="number">3</span>] = <span class="number">2</span>;         </span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">4</span> / <span class="number">22</span>,<span class="number">9</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><h2 id="639-Decode-Ways-II"><a href="#639-Decode-Ways-II" class="headerlink" title="639. Decode Ways II"></a>639. Decode Ways II</h2><p>基本思路:<br>和I的区别在于需要对特殊符号进行一个判断和处理，这里对第一个Character和第二个Character定义为c1和c2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>种情况：c1 is num and c2 is num</span><br><span class="line">正常处理</span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>种情况：c1 is num and c2 is *</span><br><span class="line">    case1: c1 == <span class="string">'1'</span>, <span class="number">1</span>* = <span class="number">11</span> ~ <span class="number">19</span> dp[i] += <span class="number">9</span>  * dp[i - <span class="number">2</span>] dp[i] += <span class="number">9</span> * dp[i - <span class="number">1</span>];;</span><br><span class="line">    case2: c2 == <span class="string">'2'</span>, <span class="number">2</span>* = <span class="number">21</span> ~ <span class="number">26</span> dp[i] += <span class="number">6</span>  * dp[i - <span class="number">2</span>] dp[i] += <span class="number">9</span> * dp[i - <span class="number">1</span>];;</span><br><span class="line"></span><br><span class="line">第<span class="number">3</span>种情况：c1 is * and c2 is num</span><br><span class="line">    case1: c2 &lt;= <span class="string">'6'</span>  * 变成<span class="number">1</span>或者<span class="number">2</span>都是有效的 dp[i] += <span class="number">2</span> * dp[i - <span class="number">2</span>]</span><br><span class="line">    case2: <span class="keyword">else</span>       * 变成<span class="number">1</span>是有效的，<span class="number">2</span>无效 dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">第<span class="number">4</span>种情况：c1 is * and c2 is *</span><br><span class="line">    case1: ** = <span class="number">11</span> ~ <span class="number">19</span> + <span class="number">21</span> ~ <span class="number">26</span>  dp[i] += <span class="number">15</span> * dp[i - <span class="number">2</span>] dp[i] += <span class="number">9</span> * dp[i - <span class="number">1</span>];;</span><br></pre></td></tr></table></figure></p><h2 id="95-Unique-Binary-Search-Trees-II"><a href="#95-Unique-Binary-Search-Trees-II" class="headerlink" title="95. Unique Binary Search Trees II"></a>95. Unique Binary Search Trees II</h2><p>基本思路：<br>1.根据DP思路出发，确定问题用recursion方法解决，对每一个node，递归的求出他的左右子树，连接到当前node。<br>2.注意边界条件，l &gt; r 时添加null到对应的sub中用于构建leaf的部分。<br>3.使用一个for loop 遍历1～n的所有点，对于该点，获取他的左子树和右子树，将对应的孩子节点连接到node上。<br>4.跑一边testcase有助于理解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; lSub = helper(l, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rSub = helper(i + <span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode lChild : lSub) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rChild : rSub) &#123;</span><br><span class="line">                    TreeNode cur = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    cur.left = lChild;</span><br><span class="line">                    cur.right = rChild;</span><br><span class="line">                    res.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h2><p>基本思路：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">situation of only <span class="number">1</span> <span class="function">node <span class="title">f</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">situation of <span class="number">2</span> <span class="function">nodes <span class="title">f</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">2</span></span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>    </span><br><span class="line">  /       \</span><br><span class="line"> <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"></span><br><span class="line">situation of <span class="number">3</span> <span class="function">nodes <span class="title">f</span><span class="params">(<span class="number">3</span>)</span> </span>= <span class="number">5</span></span><br><span class="line">    <span class="number">3</span>          <span class="number">3</span>          <span class="number">3</span></span><br><span class="line">  /   \      /   \      /   \</span><br><span class="line">f(<span class="number">0</span>) f(<span class="number">2</span>)  f(<span class="number">1</span>) f(<span class="number">1</span>)  f(<span class="number">2</span>)  f(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>以此类推，不难发现其中的dp转移规律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">2</span>) = f(<span class="number">1</span>) * f (<span class="number">0</span>) + f(<span class="number">0</span>) * f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">3</span>) = f(<span class="number">0</span>) * f(<span class="number">2</span>) + f(<span class="number">1</span>) * f(<span class="number">1</span>) + f(<span class="number">2</span>) * f(<span class="number">0</span>);</span><br><span class="line">f(<span class="number">4</span>) = f(<span class="number">0</span>) * f(<span class="number">3</span>) + f(<span class="number">1</span>) * f(<span class="number">2</span>) + f(<span class="number">2</span>) * f(<span class="number">1</span>) + f(<span class="number">3</span>) * f(<span class="number">0</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>f(0) = 1其实就表示root的左/右子树全空也是一种情况<br>讲道理吧，这题我不看答案不太想得到。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="174-Dungeon-Game"><a href="#174-Dungeon-Game" class="headerlink" title="174. Dungeon Game"></a>174. Dungeon Game</h2><h2 id="304-Range-Sum-Query-2D-Immutable"><a href="#304-Range-Sum-Query-2D-Immutable" class="headerlink" title="304. Range Sum Query 2D - Immutable"></a>304. Range Sum Query 2D - Immutable</h2><h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h2><p>基本思路：经典中的经典<br>dp[amount] 表示凑成当前数额共需几枚硬币。<br>在每一个数额下，对coins中的每一枚硬币都要尝试。</p><p>初始赋值：dp[0] = 0, dp[1] -&gt; dp[amount] = amount + 1 (一个大于amount的数字)<br>状态转移方程：if (coin &lt;= curAmount) dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1);</p><p>手动过一遍test case。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">when curAmount = <span class="number">2</span>, coin = <span class="number">1</span>, dp[<span class="number">2</span>] = Math.min(amount + <span class="number">1</span>, dp[<span class="number">1</span>] + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">     curAmount = <span class="number">2</span>, coin = <span class="number">2</span>, dp[<span class="number">2</span>] = Math.min(<span class="number">2</span>, dp[<span class="number">0</span>] + <span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">when curAmount = <span class="number">3</span>, coin = <span class="number">1</span>, dp[<span class="number">3</span>] = Math.min(amount + <span class="number">1</span>, dp[<span class="number">2</span>] + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">     curAmount = <span class="number">3</span>, coin = <span class="number">2</span>, dp[<span class="number">3</span>] = Math.min(<span class="number">2</span>, dp[<span class="number">1</span>] + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">when curAmount = <span class="number">4</span>, coin = <span class="number">1</span>, dp[<span class="number">4</span>] = Math.min(amount + <span class="number">1</span>, dp[<span class="number">3</span>] + <span class="number">1</span>) = <span class="number">3</span>;</span><br><span class="line">     curAmount = <span class="number">4</span>, coin = <span class="number">2</span>, dp[<span class="number">4</span>] = Math.min(<span class="number">3</span>, dp[<span class="number">2</span>] + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">when curAmount = <span class="number">5</span>, coin = <span class="number">1</span>, dp[<span class="number">5</span>] = Math.min(amount + <span class="number">1</span>, dp[<span class="number">4</span>] + <span class="number">1</span>) = <span class="number">3</span>;</span><br><span class="line">     curAmount = <span class="number">5</span>, coin = <span class="number">2</span>, dp[<span class="number">5</span>] = Math.min(<span class="number">3</span>, dp[<span class="number">3</span>] + <span class="number">1</span>) = <span class="number">3</span>;</span><br><span class="line">     curAmount = <span class="number">5</span>, coin = <span class="number">5</span>, dp[<span class="number">5</span>] = Math.min(<span class="number">3</span>, dp[<span class="number">0</span>] + <span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">when curAmount = <span class="number">11</span>, coin = <span class="number">1</span>, dp[<span class="number">11</span>] = Math.min(amount + <span class="number">1</span>, dp[<span class="number">10</span>] + <span class="number">1</span>) = <span class="number">3</span>;</span><br><span class="line">     curAmount = <span class="number">11</span>, coin = <span class="number">2</span>, dp[<span class="number">11</span>] = Math.min(<span class="number">3</span>, dp[<span class="number">9</span>] + <span class="number">1</span>) = <span class="number">3</span>;</span><br><span class="line">     curAmount = <span class="number">11</span>, coin = <span class="number">5</span>, dp[<span class="number">11</span>] = Math.min(<span class="number">3</span>, dp[<span class="number">6</span>] + <span class="number">1</span>) = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curAmount = <span class="number">1</span>; curAmount &lt;= amount; curAmount++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coin &lt;= curAmount) &#123;</span><br><span class="line">                    dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><h2 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h2><p>对位运算一直没什么感觉。。还是找规律好了<br>0-&gt;00000000   9 -&gt;00001001<br>1-&gt;00000001   10-&gt;00001010<br>2-&gt;00000010   11-&gt;00001011<br>3-&gt;00000011   12-&gt;00001100<br>4-&gt;00000100   13-&gt;00001101<br>5-&gt;00000101   14-&gt;00001110<br>6-&gt;00000110   15-&gt;00001111<br>7-&gt;00000111   16-&gt;00010000<br>8-&gt;00001000</p><h2 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h2><p>基本思路：<br>也很经典的一道题，判断数组能否被二等分。当然backtracking肯定能解，不过这里还是dp更好，更快<br>其实就是一道背包问题，每个石头拿一次，问能否从石堆中取到刚好填满背包重量的石头。</p><h2 id="576-Out-of-Boundary-Paths（baidu）"><a href="#576-Out-of-Boundary-Paths（baidu）" class="headerlink" title="576. Out of Boundary Paths（baidu）"></a>576. Out of Boundary Paths（baidu）</h2><p>基本思路：<br>和688其实是一样的，从棋改成了球，留在棋盘改成了踢出场外，三维DP<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> ri, <span class="keyword">int</span> rj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][m][n];</span><br><span class="line">        dp[<span class="number">0</span>][ri][rj] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= N; step++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> row = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> col = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n) &#123;</span><br><span class="line">                            res = (res + dp[step - <span class="number">1</span>][i][j]) % MOD;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[step][row][col] = (dp[step][row][col] + dp[step - <span class="number">1</span>][i][j]) % MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="688-Knight-Probability-in-Chessboard-狗面筋题，骑士在棋盘中的概率"><a href="#688-Knight-Probability-in-Chessboard-狗面筋题，骑士在棋盘中的概率" class="headerlink" title="688. Knight Probability in Chessboard(狗面筋题，骑士在棋盘中的概率)"></a>688. Knight Probability in Chessboard(狗面筋题，骑士在棋盘中的概率)</h2><p>基本思路：<br>使用三维数组maintain在当前步数下，棋盘上每一格都有多少种情况能存活。<br><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/10/688-ep79.png" alt=""><br>偷个花花的图，很清晰了<br>Time Complexity: O(K * N^2), Space Complexity: O(N^3), 可优化到O(N^2)<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, -<span class="number">1</span>&#125;, </span><br><span class="line">                                       &#123;<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;-<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + <span class="number">1</span>][N][N];</span><br><span class="line">        dp[<span class="number">0</span>][r][c] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= K; step++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> row = i + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> col = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= N || col &lt; <span class="number">0</span> || col &gt;= N) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[step][i][j] += dp[step - <span class="number">1</span>][row][col];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                res += dp[K][i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res / Math.pow(<span class="number">8</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="764-Largest-Plus-Sign"><a href="#764-Largest-Plus-Sign" class="headerlink" title="764. Largest Plus Sign"></a>764. Largest Plus Sign</h2><p>基本思路：找二维数组中最大的加号。</p><h2 id="877-Stone-Game"><a href="#877-Stone-Game" class="headerlink" title="877. Stone Game"></a>877. Stone Game</h2><p>这题是国内日企WAP的面试题之一，用DP没这么容易想。</p><h2 id="943-Find-the-Shortest-Superstring"><a href="#943-Find-the-Shortest-Superstring" class="headerlink" title="943. Find the Shortest Superstring"></a>943. Find the Shortest Superstring</h2><p>基本思路：<br>变形的TSP问题。</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Trie Tree</title>
      <link href="/2018/08/18/Trie/"/>
      <url>/2018/08/18/Trie/</url>
      <content type="html"><![CDATA[<p>刷题刷到要用trie的题又写不出了。。把trie好好写一写。<br><a href="https://leetcode.com/articles/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode.com/articles/implement-trie-prefix-tree/</a><br><a id="more"></a><br>This explanation is so fucking amazing. LC article is so qiang!</p><h1 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h1><p>Trie(prefix tree)会被用于：</p><ol><li>自动补全</li><li>拼写检查</li><li>IP routing</li><li>T9 predictive text（九宫格输入法文本预测）</li></ol><p>why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity could deteriorate to O(n), where nn is the number of keys inserted. Trie could use less space compared to Hash Table when storing many keys with the same prefix. In this case using trie has only O(m) time complexity, where mm is the key length. Searching for a key in a balanced tree costs O(mlog n) time complexity.</p><h1 id="TrieNode-structure"><a href="#TrieNode-structure" class="headerlink" title="TrieNode structure"></a>TrieNode structure</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode[] child;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isWord = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        child = <span class="keyword">new</span> TrieNode(N);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> child[ch - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> child[ch - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> c, TrieNode node)</span> </span>&#123;</span><br><span class="line">        child[c - <span class="string">'a'</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Insertion-of-a-key-to-a-trie"><a href="#Insertion-of-a-key-to-a-trie" class="headerlink" title="Insertion of a key to a trie"></a>Insertion of a key to a trie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(currentChar)) &#123;</span><br><span class="line">                node.put(currentChar, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity Analysis</p><p>Time complexity : O(m), where m is the key length.<br>In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only mm operations.</p><p>Space complexity : O(m).<br>In the worst case newly inserted key doesn’t share a prefix with the the keys already inserted in the trie. We have to add mm new nodes, which takes us O(m) space.</p><h1 id="Search-for-a-key-in-a-trie"><a href="#Search-for-a-key-in-a-trie" class="headerlink" title="Search for a key in a trie"></a>Search for a key in a trie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search a prefix or whole key in trie and</span></span><br><span class="line">    <span class="comment">// returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (node.containsKey(curLetter)) &#123;</span><br><span class="line">               node = node.get(curLetter);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">       TrieNode node = searchPrefix(word);</span><br><span class="line">       <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity Analysis</p><p>Time complexity : O(m) In each step of the algorithm we search for the next key character. In the worst case the algorithm performs m operations.</p><p>Space complexity : O(1)</p><h1 id="Search-for-a-key-prefix-in-a-trie"><a href="#Search-for-a-key-prefix-in-a-trie" class="headerlink" title="Search for a key prefix in a trie"></a>Search for a key prefix in a trie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity Analysis</p><p>Time complexity : O(m)</p><p>Space complexity : O(1)</p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Recursion and Backtracking</title>
      <link href="/2018/08/16/Recursion%20and%20Backtracking/"/>
      <url>/2018/08/16/Recursion%20and%20Backtracking/</url>
      <content type="html"><![CDATA[<p>他乡逢七夕,旅馆益羁愁。</p><p>不见穿针妇,空怀故国楼。</p><p>绪风初减热,新月始登秋。</p><p>谁忍窥河汉,迢迢问斗牛。<br><a id="more"></a></p><p>报班的讲了递归和回溯，我自己也来总结一下吧。OA两个题写了我好久。</p><p>A general approach to backtracking questions in Java.<br><a href="https://leetcode.com/problems/combination-sum/discuss/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/discuss/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning</a><br>LC discuss里这位老哥总结的很好。我自己再精简下。</p><h1 id="Subsets-I-amp-Subsets-II"><a href="#Subsets-I-amp-Subsets-II" class="headerlink" title="Subsets I &amp; Subsets II"></a>Subsets I &amp; Subsets II</h1><p>I和II只有一个不同，数组中如果有重复元素，如何避免出现重复的子集？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>关键在于 排序 和 if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue;</p><p>排序是确保后一句起作用的前提。举个例子</p><p>对于不含重复元素的input，比如123, 生成的子集为[], 1, 12, 13, 123, 2, 23, 3</p><p>对于含重复元素的input，比如122, 那生成的子集为[], 1, 12, 12, 122, 2, 22, 2</p><p>去重的原理：当前子集为12时，backtracking删除2，当加入index为2的元素2时，发现重复，因此不加。</p><p>i &gt; start的目的是为了保证第一个出现的重复的值会被加入subset中。</p><h1 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h1><p>use boolean[], HashSet, or swap() is both ok.<br>如果限制不允许使用额外的空间来check each element是不是被使用，那么swap是一个很好的选择。<br>注意使用swap的话，for loop中i由index赋值，而不是每次从0开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        bt(nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bt</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            swap(nums, index, i);</span><br><span class="line">            bt(nums, res, list, index + <span class="number">1</span>);</span><br><span class="line">            swap(nums, index, i);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h1><p>基本思路：<br>最基本的回溯。<br>对每一个空格子先判断1-9填这里是不是有效，有效的话进入下一步，无效的话将填入的值抹掉变为空值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.length, col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isValid(board, i, j, c)) &#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span> (solve(board)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col] == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i] == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s1 = row / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = col / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s1; i &lt; s1 + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = s2; j &lt; s2 + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] == c)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="282-Expression-Add-Operators"><a href="#282-Expression-Add-Operators" class="headerlink" title="282. Expression Add Operators"></a>282. Expression Add Operators</h1><h1 id="698-Partition-to-K-Equal-Sum-Subsets"><a href="#698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="698. Partition to K Equal Sum Subsets"></a>698. Partition to K Equal Sum Subsets</h1><p>基本思路：和473是完全一样的问题。</p><p>先判断和能否被4整除，target = sum / 4;<br>之后对Array排序，如果存在element &gt; target return false;<br>通过一个while loop寻找nums中是否有element恰好等于target，如果存在，k–，相当于桶变少了，加快搜索进度。<br>helper method相当于把剩下的元素分配到K个桶中，保证每次分配桶的sum + 分配进来的值小于等于target。<br>如果所有元素全被分配了，说明可以K等分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &gt; target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; nums[index] == target) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] sub = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">return</span> helper(nums, sub, target, index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] sub, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[index--];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sub.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sub[i] + cur &lt;= target) &#123;</span><br><span class="line">                sub[i] += cur;</span><br><span class="line">                <span class="keyword">if</span> (helper(nums, sub, target, index)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                sub[i] -= cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sub[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>287. Find Duplicate</title>
      <link href="/2018/08/08/Find%20Duplicate/"/>
      <url>/2018/08/08/Find%20Duplicate/</url>
      <content type="html"><![CDATA[<p>今天收了封FB内推据信，我和kisday都想不明白问题在哪。。感觉是真的要报班了。。至少保证我有个面试吧，不然题刷的再多有什么用</p><p><a href="http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=176498&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D192%26sortid%3D192" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=176498&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D192%26sortid%3D192</a></p><p>在地里看了这个帖子，难受的一批。难受就对了，好走的都是下坡路。</p><p>但是题还是要刷。总结一下找重复的一些题。<br><a id="more"></a></p><h1 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h1><p>基本思路：<br>一般有三种方法：排序，用set，根据下标取负。</p><p>这题有要求，不能modify原数组，不能使用额外的空间，不能大于O(n)</p><p>利用duplicate num这个特点。在该数组中两个不同的index会指向同一个num。<br>因此考虑做一个num -&gt; index的连接，那么该链表成环。问题转化为快慢指针链表找环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; len &amp;&amp; nums[fast] &lt; len) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                slow = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="652-Find-Duplicate-Subtrees"><a href="#652-Find-Duplicate-Subtrees" class="headerlink" title="652. Find Duplicate Subtrees"></a>652. Find Duplicate Subtrees</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Sliding Window Problems</title>
      <link href="/2018/08/06/Sliding%20Window%20Problem/"/>
      <url>/2018/08/06/Sliding%20Window%20Problem/</url>
      <content type="html"><![CDATA[<p>刷面经时候看到，正好总结一下这一类sliding window问题（滑窗）。<br>discuss里的template给的很好，不过我觉得还是自己手写过一遍比较好。笨办法帮助理解，毕竟自己不是聪明人。<br><a id="more"></a></p><h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><pre><code>Given a string, find the length of the longest substring without repeating characters.Examples:Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre><p>思路是一样的，右指针发现重复的那个数之后（map.get(r) &gt; 1），左指针开始扫描，直到找到和当前right指针对应的元素相同的元素。<br>此时左指针左边的部分不会被用于之后的寻找最优解的过程中，在map中对应的val也为0.<br>我在这里用了boolean found 来作为判断的条件是否进入左指针寻值的while loop，因为使用count会让人有点迷惑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            map.put(r, map.getOrDefault(r, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(r) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (found) &#123;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (map.get(l) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    found = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(l, map.get(l) - <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println("right is " + right + " left is " + left);</span></span><br><span class="line">            len = Math.max(right - left + <span class="number">1</span>, len);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="LC76-Minimum-Window-Substring"><a href="#LC76-Minimum-Window-Substring" class="headerlink" title="LC76. Minimum Window Substring"></a>LC76. Minimum Window Substring</h1><pre><code>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).Example:Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;</code></pre><ol><li><p>开一个map（可以数组或者HashMap）用来check S中的字母是否存在于T中。</p></li><li><p>参数含义：</p><pre><code>count 用于判断是否找到了一组解。if (count == 0) 就说明T中的所有字母已在当前指针扫描范围被全部cover。      初始化为map.size(), 因为T中可能有重复元素，所以用map.size()。count的增加取决于map中value是否为0。left  左指针 right 右指针head  用来maintain每次找到合法解后左指针的位置。min   当前的最小长度，初始化为Integer.MAX_VALUE</code></pre></li><li><p>按照代码想法手动过一遍test case: “cabwefgewcwaefgcf”，”cae”</p><pre><code>round 1:substring is cabweright = 4, 此时count == 0，left指针开始move，此时left = 0, min = 6, head = 0之后left和right分别自增，right = 5, left = 1;round 2:因为c在round 1中被重新加到map中，下一步当right扫到c时，count == 0, 扫描中还会扫到一个e，使其在map中的val - 1substring is abwefgewcright = 9, 此时count == 0，left指针开始move，此时left = 1, right - left + 1 &gt; min。head和min不变。之后left和right分别自增，right = 10, left = 2;round 3:substring is efgewcwaright = 11, 此时count == 0， left指针开始move，扫到第一个e，发现map.get(e) == -1, 遂val+1，但map.get(e) 并没有大于0，count不变仍为0。所以while loop中left指针继续向右move，直到发现第二个e为止。substring is ewcwaright = 11, count == 0, left = 7, right - left + 1 &lt; min, min = 5, head = 7;round 4:substring is cwaeright = 12, count == 0, left = 9, right - left + 1 &lt; min, min = 4, head = 9;找到最优解。round 5:sunstring is aefgcright - left + 1 &gt; min, pass扫描完毕</code></pre></li><li><p>code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = map.size(), head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(r)) &#123;</span><br><span class="line">                map.put(r, map.get(r) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(r) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(l)) &#123;</span><br><span class="line">                    map.put(l, map.get(l) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(l) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; min) &#123;</span><br><span class="line">                    head = left;</span><br><span class="line">                    min = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(head, head + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="239-Sliding-Window-Maximum-狗家OA"><a href="#239-Sliding-Window-Maximum-狗家OA" class="headerlink" title="239. Sliding Window Maximum (狗家OA)"></a>239. Sliding Window Maximum (狗家OA)</h1><p>题意：<br>问题是给定一个大小为K的窗口，在每次滑动过程中找到当前窗口中最大的那个数，return一个包含了所有这些数的数组。</p></li></ol><p>基本思路：<br>不同于字符串处理的滑窗问题，这里用Deque来对数组进行处理。经典题。</p><h1 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a>438. Find All Anagrams in a String</h1><pre><code>Given a string s and a non-empty string p, find all the start indices of p&apos;s anagrams in s.Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.The order of output does not matter.Example 1:Input:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;Output:[0, 6]Explanation:The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</code></pre><p>上一题是找subsequence，但是通过check right - left + 1 == p.length()，就能把代码转化为找substring。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, head = <span class="number">0</span>, count = map.size();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(r)) &#123;</span><br><span class="line">                map.put(r, map.get(r) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(r) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(l)) &#123;</span><br><span class="line">                    map.put(l, map.get(l) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(l) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">                    head = left;</span><br><span class="line">                    list.add(head);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 刷题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Search &amp; Sort</title>
      <link href="/2018/07/29/Search%20&amp;%20Sort/"/>
      <url>/2018/07/29/Search%20&amp;%20Sort/</url>
      <content type="html"><![CDATA[<p>最近看到FB有人被面了Kth smallest element，我也重新复习一下。// 白复习</p><p>顺便也重新理一下一些基本的选择和排序算法。<br><a id="more"></a></p><h1 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h1><p>先确定两个概念，怎么样的排序算法是稳定的，怎么样的排序算法是高效的。</p><h2 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h2><h1 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h1><p>摆脱了nlogn的魔咒。排序速度一般为线性，但是需要额外的空间。因为拿空间换了时间。</p><h2 id="courting-sort"><a href="#courting-sort" class="headerlink" title="courting sort"></a>courting sort</h2><p>很有趣的排序，Doordash的一道面筋题。一般用于处理一个small range的排序。时空间复杂度均为O(n + k);<br>n是原数组的长度，K为数组中的max - min + 1;<br>下面是Java的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        min = Math.min(nums[i], min);</span><br><span class="line">        max = Math.max(nums[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = nums[i] - min;</span><br><span class="line">        count[index]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = count[nums[i] - min] - <span class="number">1</span>;</span><br><span class="line">        res[index] = nums[i];</span><br><span class="line">        count[nums[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="bucket-sort"><a href="#bucket-sort" class="headerlink" title="bucket sort"></a>bucket sort</h2><p>桶排序</p><h3 id="Sort-an-array-according-to-count-of-set-bits"><a href="#Sort-an-array-according-to-count-of-set-bits" class="headerlink" title="Sort an array according to count of set bits"></a>Sort an array according to count of set bits</h3><h1 id="binary-search"><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h1><p>Jon Bentley说90%的程序员都写不对二分, 我个人觉得写二分最好就用一个模板。<br>另外这个帖子真的讲的非常非常好。<a href="http://www.1point3acres.com/bbs/thread-432793-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-432793-1-1.html</a></p><p>当搜索到达right - left == 1的时候，这时候mid是等于left的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//avoid overflow</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//dont find</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-Search-in-Rotated-Sorted-Arrays"><a href="#33-Search-in-Rotated-Sorted-Arrays" class="headerlink" title="33. Search in Rotated Sorted Arrays"></a>33. Search in Rotated Sorted Arrays</h2><p>基本思路：<br>最经典的题了。</p><h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h2><p>基本思路：<br>1.两个binary search，找到target后一个继续向左，一个继续向右。<br>2.在当前搜索找到target后，记录index后继续向左/右搜索，。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = left(nums, target);</span><br><span class="line">        res[<span class="number">1</span>] = right(nums, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; <span class="comment">//5,7,7,8,8,10</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>, l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) index = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; <span class="comment">//5,7,7,8,8,10</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>, l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) index = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h2><h2 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h2><p>基本思路：<br>-解法1:<br>开一个PriorityQueue，time complexity is Nlog(K).<br>-解法2:<br>quick select</p><p>思路和快排相同，但只需要对一边进行排序就行。</p><p>因为排序后pivot在整个list中的index是确定的，我们只需要比较K和index，如果K &lt; index，那么说明要找的target num在左半部分，反之亦然。</p><h2 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h2><p>基本思路：<br>用inorder 遍历当然很快，不过这题最好的解法是给二分。</p><h2 id="540-Single-Element-in-a-Sorted-Array"><a href="#540-Single-Element-in-a-Sorted-Array" class="headerlink" title="540. Single Element in a Sorted Array"></a>540. Single Element in a Sorted Array</h2><p>基本思路：<br>利用了一个特性，就是多出的single number会影响数组中pair和index之间的规律。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原始的array：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> index is odd,  nums[index] == nums[index - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> index is even, nums[index] == nums[index + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">插入一个single number 之后：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line">此时<span class="number">2</span>（single number）之前的subarray还是符合这个规律，但是<span class="number">2</span>之后的部分不符合。</span><br><span class="line">所以发现当前index不符合规律，则说明single number在index的左区，r = mid</span><br><span class="line">如果符合规律，则single number在index的右区，l = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure><br>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> n = mid % <span class="number">2</span> == <span class="number">0</span> ? mid + <span class="number">1</span> : mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[n]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println("l is: " + l + " " + "r is: " + r);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="658-Find-K-Closest-Elements"><a href="#658-Find-K-Closest-Elements" class="headerlink" title="658. Find K Closest Elements"></a>658. Find K Closest Elements</h2><p>基本思路：<br>找出最接近x的k个值。背吧，反正我想不到二分还能这么用的，神仙做题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="Sort-Problems"><a href="#Sort-Problems" class="headerlink" title="Sort Problems"></a>Sort Problems</h1><h2 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179. Largest Number"></a>179. Largest Number</h2><p>基本思路：<br>这题很有意思，先将int 转为 String，之后开始排序，重写comparator;</p><p>排序的逻辑是，String A and String B，if A+B &gt; B+A, 则A在B的前面;</p><p>for example: 930 &gt; 309, so [9, 30]. String的比较可以直接用compareTo();</p><p>最后根据排序的String[] 拼接字符串输出即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> String.valueOf(nums[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String l, String r)</span> </span>&#123;</span><br><span class="line">                String s1 = l + r;</span><br><span class="line">                String s2 = r + l;</span><br><span class="line">                <span class="keyword">return</span> s2.compareTo(s1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (strs[<span class="number">0</span>].equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minimum Spanning Tree &amp; Union found</title>
      <link href="/2018/07/22/Minimum%20Spanning%20Tree/"/>
      <url>/2018/07/22/Minimum%20Spanning%20Tree/</url>
      <content type="html"><![CDATA[<p>今天老姐让我写最小生成树，憋了半天写不出来=，= 最骚的是kisday和我说他也不会写，我会信？</p><p>现在认真学习了一遍，放个总结免得以后又忘了。虽然我隐隐觉得亚麻不会给我这个用的机会。// 确实没给我OA，我可透您马。<br><a id="more"></a></p><h1 id="最小生成树：连通加权无向图中一棵权值最小的生成树。"><a href="#最小生成树：连通加权无向图中一棵权值最小的生成树。" class="headerlink" title="最小生成树：连通加权无向图中一棵权值最小的生成树。"></a>最小生成树：连通加权无向图中一棵权值最小的生成树。</h1><h2 id="A-Kruskal算法-（摘自维基百科）"><a href="#A-Kruskal算法-（摘自维基百科）" class="headerlink" title="A. Kruskal算法 （摘自维基百科）"></a>A. Kruskal算法 （摘自维基百科）</h2><p>   步骤：<br>   1.新建图G，G中拥有原图中相同的节点，但没有边<br>   2.将原图中所有的边按权值从小到大排序<br>   3.从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中（说人话：如果成环就不选这条边），则添加这条边到图G中<br>   4.重复3，直至图G中所有的节点都在同一个连通分量中（所有点都用完了）</p><p>   证明：<br>   反证法。如果这颗树不是最小生成树，那么一定有一条不在这个树中的边。这条边必定会和其中某些变成环，但环中别的边都是权值最小的，所以如果使用这条边而删去其他的边，那么整颗树的权值就不是minimum了。</p><p>   注意：<br>   判断连接的两点是否在联通分量中（会不会成环）需要使用并查集。</p><h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Find(x): find the root/cluster-id of x</p><p>Union(x, y): merge two clusters</p><p>Check whether two elements are in the same set or not in O(1).</p><p>Find: O(ɑ(n)) ≈ O(1)</p><p>Union: O(ɑ(n)) ≈ O(1)</p><p>Space: O(n)</p><p>Without optimization: Find: O(n)<br>同时使用路径压缩、按秩（rank）合并优化的程序每个操作的平均时间仅为O(ɑ(n))，其中a(n)是n = f(x) = A(x,x)的反函数， A 是急速增加的阿克曼函数。因为a(n)是其反函数，故a(n)在n十分巨大时还是小于 5。因此，平均运行时间是一个极小的常数。实际上，这是渐近最优算法.</p><p>Two key optimizations:</p><p>1.Path compression: make tree flat<br><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/11/sp1-2.png" alt=""><br>2.Union by rank: merge low rank tree to high rank one<br><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2017/11/sp1-3.png" alt=""></p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations:"></a>Implementations:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">parents = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">ranks = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">parents[i] = i;</span><br><span class="line">ranks[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">// pu is the parent of u, pv is the parent of v</span></span><br><span class="line"><span class="keyword">int</span> pu = find(u);</span><br><span class="line"><span class="keyword">int</span> pv = find(v);</span><br><span class="line"><span class="keyword">if</span> (pu == pv) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// They are in the same clusterd already</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ranks[pu] &gt; ranks[pv]) &#123;<span class="comment">// merge low rank tree to high rank tree</span></span><br><span class="line">parents[pv] = pu;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[pv] &gt; ranks[pu]) &#123;</span><br><span class="line">parents[pu] = pv;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parents[pv] = pu;</span><br><span class="line">ranks[pu]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parents[u] != u) &#123;</span><br><span class="line">parents[u] = parents[parents[u]];</span><br><span class="line">u = parents[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><h3 id="721-Accounts-Merge"><a href="#721-Accounts-Merge" class="headerlink" title="721. Accounts Merge"></a>721. Accounts Merge</h3><p>基本思路:</p><ol><li>对于每一个email，赋予一个对应的ID，ID用于判断每个email是不是属于一个cluster</li><li>用两个map分别存 email -&gt; name，email -&gt; ID</li><li>因为一个email只对应一个ID，所以两个cluster包含相同的email会被merge。</li><li>根据cluster index将每个email放到一个新的HashMap中。</li><li>拿出这个新map的values(()，对其实的list进行排序，并且在头部插入这个list对应的人名。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(<span class="number">10001</span>);</span><br><span class="line">        Map&lt;String, String&gt; emailToName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">            String name = account.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">                String email = account.get(i);</span><br><span class="line">                <span class="comment">// name和email是一对多的关系，不会出现不同的名字却有相同的email的情况。</span></span><br><span class="line">                emailToName.put(email, name);</span><br><span class="line">                <span class="keyword">if</span> (!emailToId.containsKey(email)) &#123;</span><br><span class="line">                    emailToId.put(email, id++);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对每个email进行union，存在相同email就会merge</span></span><br><span class="line">                <span class="comment">// 含义为：拥有相同email的同名账号被认为是一个人（一个人就是一个cluster）</span></span><br><span class="line">                uf.union(emailToId.get(account.get(<span class="number">1</span>)), emailToId.get(email));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String email : emailToName.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = uf.find(emailToId.get(email));</span><br><span class="line">            <span class="comment">// 根据 cluster index 将每个email归类</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(index)) &#123;</span><br><span class="line">                map.put(index, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(index).add(email);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : map.values()) &#123;</span><br><span class="line">        <span class="comment">// 排序后 根据email -&gt; name的映射将名字加入list</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            list.add(<span class="number">0</span>, emailToName.get(list.get(<span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">parents = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">ranks = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">parents[i] = i;</span><br><span class="line">ranks[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">// pu is the parent of u, pv is the parent of v</span></span><br><span class="line"><span class="keyword">int</span> pu = find(u);</span><br><span class="line"><span class="keyword">int</span> pv = find(v);</span><br><span class="line"><span class="keyword">if</span> (pu == pv) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// They are in the same clusterd already</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ranks[pu] &gt; ranks[pv]) &#123;<span class="comment">// merge low rank tree to high rank tree</span></span><br><span class="line">parents[pv] = pu;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[pv] &gt; ranks[pu]) &#123;</span><br><span class="line">parents[pu] = pv;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parents[pv] = pu;</span><br><span class="line">ranks[pu]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parents[u] != u) &#123;</span><br><span class="line">parents[u] = parents[parents[u]];</span><br><span class="line">u = parents[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="684-Redundant-Connection"><a href="#684-Redundant-Connection" class="headerlink" title="684. Redundant Connection"></a>684. Redundant Connection</h3><p>基本思路：<br>如果两个点无法被union，说明他们已经在一个cluster中，此时连接这两点的edge会导致树中有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!uf.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ranks = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            ranks[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[u] != u) &#123;</span><br><span class="line">            parents[u] = parents[parents[u]];</span><br><span class="line">            u = parents[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u);</span><br><span class="line">        <span class="keyword">int</span> pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ranks[pu] &gt; ranks[pv]) &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[pv] &gt; ranks[pu]) &#123;</span><br><span class="line">            parents[pu] = pv;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">            ranks[pu]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="685-Redundant-Connection-II"><a href="#685-Redundant-Connection-II" class="headerlink" title="685. Redundant Connection II"></a>685. Redundant Connection II</h3><p>基本思路：<br>graph的边从无向变成了有向。</p><h3 id="547-Friend-Circles"><a href="#547-Friend-Circles" class="headerlink" title="547. Friend Circles"></a>547. Friend Circles</h3><p>基本思路：<br>如果使用并查集，则在UnionFind class加一个参数count用来maintain当前cluster的个数。<br>每次union都会使count - 1。</p><p>注意此时new UnionFind(n)时，n必须刚好是所有需要计算的元素的个数，此题中就是学生个数N。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = M.length;</span><br><span class="line">        UnionFind u = <span class="keyword">new</span> UnionFind(row);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!u.union(i, j)) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">int</span>[] ranks;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ranks = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            ranks[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u);</span><br><span class="line">        <span class="keyword">int</span> pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ranks[pu] &gt; ranks[pv]) &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[pv] &gt; ranks[pu]) &#123;</span><br><span class="line">            parents[pu] = pv;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">            ranks[pu]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[u] != u) &#123;</span><br><span class="line">            parents[u] = parents[parents[u]];</span><br><span class="line">            u = parents[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="765-Couples-Holding-Hands"><a href="#765-Couples-Holding-Hands" class="headerlink" title="765. Couples Holding Hands"></a>765. Couples Holding Hands</h3><p>基本思路：<br>先明确一点，如何判断两个数是一对夫妻 -&gt; nums[i] / 2 == nums[j] / 2。比如2，3和4，5，除2之后为1，1和2，2;<br>这样判断的好处在于不用考虑位置，like 0，1 和1，0;</p><p>并查集中的元素个数为 N = row.length / 2;<br>使用并查集的话，</p><h3 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h3><p>基本思路：<br>1.使用并查集，将相差为1的元素放入一个cluster，最后统计每个element在unino find中对中的parent的个数，最多的那个就是答案<br>2.[100, 4, 200, 1, 3, 2] 1234是一个cluster，100是一个，200是一个。1234的parent都是0，所以答案是4<br>3.使用一个hashmap在遍历中maintain nums[i], nums[i] + 1 and nums[i] - 1的关系<br>4.注意！union的是每个相邻元素的index，元素本身可能会是负数，union的话会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        UnionFind un = <span class="keyword">new</span> UnionFind(nums.length + <span class="number">1</span>);</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// union index of two elements here</span></span><br><span class="line">                un.union(map.get(nums[i] + <span class="number">1</span>), i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// union index of two elements here</span></span><br><span class="line">                un.union(map.get(nums[i] - <span class="number">1</span>), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// count freq of each parent id, return the max one</span></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = un.find(i);</span><br><span class="line">            map.put(p, map.getOrDefault(p, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            res = Math.max(map.get(p), res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        ranks = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            ranks[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u);</span><br><span class="line">        <span class="keyword">int</span> pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ranks[pu] &gt; ranks[pv]) &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[pv] &gt; ranks[pu]) &#123;</span><br><span class="line">            parents[pu] = pv;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[pv] = pu;</span><br><span class="line">            ranks[pu]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (u != parents[u]) &#123;</span><br><span class="line">            parents[u] = parents[parents[u]];</span><br><span class="line">            u = parents[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getParents() &#123;</span><br><span class="line">        <span class="keyword">return</span> parents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="399-Evaluate-Division"><a href="#399-Evaluate-Division" class="headerlink" title="399. Evaluate Division"></a>399. Evaluate Division</h3>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java lambda expressions</title>
      <link href="/2018/07/15/Java%20lambda%20expressions/"/>
      <url>/2018/07/15/Java%20lambda%20expressions/</url>
      <content type="html"><![CDATA[<ol><li>重写comparator: </li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Prime Number</title>
      <link href="/2018/07/09/Prime%20Number/"/>
      <url>/2018/07/09/Prime%20Number/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>万历和鱼</title>
      <link href="/2018/07/08/%E4%B8%87%E5%8E%86%EF%BC%8C%E5%A7%9A%E8%B4%9D%E5%A8%9C%E5%92%8C%E9%B1%BC/"/>
      <url>/2018/07/08/%E4%B8%87%E5%8E%86%EF%BC%8C%E5%A7%9A%E8%B4%9D%E5%A8%9C%E5%92%8C%E9%B1%BC/</url>
      <content type="html"><![CDATA[<p>看了半本万历十五年，挺有意思的一本书。讲了一个被文官和儒家的规矩束缚的可怜皇帝。</p><p>昨天朋友深夜打电话给我，接起来就是一阵啜泣。电话那边一句我想回NB了，让我也感觉鼻头一酸。我好明白这种感觉。</p><p>我说实在不行就回家吧，其实我也好累，扛不住也正常。他却只是在另一边说，可回去就是承认自己失败了呀。</p><p>我突然说不出话来。因为自己内心无法描述出来的感受被人说出来了，被一个有同样感受的人。</p><p>其实他又帅又高，性格体贴，在多伦多买了房。饭也烧的好吃。怎么也算不上失败的。</p><p>只是还没有个稳定的工作，大概是觉得既然出来了，总得混出点名堂再回去吧。</p><p>我懂，因为这也是我的思量。</p><p>想显得体面一些，就会有很多顾虑和考量夹在在生活中，就很难用自己觉得舒服的姿势过日子了。但你得装作你其实还不错。</p><p>突然就感觉我们这些人有点可怜，还有更可怜的万历皇帝。</p><p>皇帝都身不由己，何况我们这些的普通人呢。</p><p>一边听着电话，电视里刚好放到姚贝娜在唱鱼，眼睛里闪烁着难以言明的光彩，光彩里涌动着渴望。</p><p>感觉我就像她歌声里的鱼，怎么逃都逃不出这个世界编的网，挣脱了一个网眼还有一个网眼。</p><p>网眼的种类还挺多：钱，关系，房子，车，人脉，还有乱七八糟的东西。</p><p>去你妈的。</p><p>我就想每天旱涝保收饿不死没事打打游戏偶尔吃顿好的。人活着怎么就得有这么多逼事儿呢，怎么就有这么多要求呢？</p><p>最变态的是我自己也明白我得去努力追逐这些东西，不能当loser。到底为什么我会有这些跟自己过不去的想法并且用来要求自己？</p><p>我小时候就一直在想，会不会我们的世界其实就是一本故事书，人生只是有个旁白在默默地读你的故事，一个个被写好的故事。</p><p>想来想去也没什么头绪，还是继续写会儿代码好了。算是明白文章憎命达了，失意的人才有闲心胡思乱想。</p><p>世界静下来了，想了想最近真的好累啊。其实就是在发牢骚吧，因为想逃却逃不了。</p>]]></content>
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便写写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binary Tree and BST</title>
      <link href="/2018/07/05/Binary%20Tree%20and%20BST/"/>
      <url>/2018/07/05/Binary%20Tree%20and%20BST/</url>
      <content type="html"><![CDATA[<p>总结了树的遍历方法和LC中的经典题目<br><a id="more"></a></p><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="Preorder-Traversal"><a href="#Preorder-Traversal" class="headerlink" title="Preorder Traversal"></a>Preorder Traversal</h2><p>Algorithm Preorder(tree)</p><ol><li>Visit the root.</li><li>Traverse the left subtree, i.e., call Preorder(left-subtree)</li><li>Traverse the right subtree, i.e., call Preorder(right-subtree) </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        recursion(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        recursion(root.left, list);</span><br><span class="line">        recursion(root.right, list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">iteration</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = s.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inorder-Traversal"><a href="#Inorder-Traversal" class="headerlink" title="Inorder Traversal"></a>Inorder Traversal</h2><p>Algorithm Inorder(tree)</p><ol><li>Traverse the left subtree, i.e., call Inorder(left-subtree)</li><li>Visit the root.</li><li>Traverse the right subtree, i.e., call Inorder(right-subtree)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Postorder-Traversal"><a href="#Postorder-Traversal" class="headerlink" title="Postorder Traversal"></a>Postorder Traversal</h2><p>Algorithm Postorder(tree)</p><ol><li>Traverse the left subtree, i.e., call Postorder(left-subtree)</li><li>Traverse the right subtree, i.e., call Postorder(right-subtree)</li><li>Visit the root.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        recursion(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recursion(root.left, list);</span><br><span class="line">        recursion(root.right, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">iteration</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = s.pop();</span><br><span class="line">            list.add(<span class="number">0</span>, cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="Tree-Isomorphism-Problem"><a href="#Tree-Isomorphism-Problem" class="headerlink" title="Tree Isomorphism Problem"></a>Tree Isomorphism Problem</h3><p><a href="https://www.geeksforgeeks.org/tree-isomorphism-problem/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/tree-isomorphism-problem/</a><br>基本思路：<br>分别对树A，树B的左左，右右，左右，右左进行判断<br>时间复杂度：<br>若树是一颗满二叉树，树中一共有n个节点，那么就有n/2的leaf，每个leaf都会被访问n（2^logn）次，所以最坏就是O(n^2)<br>follow up:<br>如果是general的树怎么办？<br>任意两个child都要像这里的left和right subtree一样进行比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(Node root1, Node root2)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">if</span> (root1.data != root2.data) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">           <span class="comment">//check 左左和右右</span></span><br><span class="line">           <span class="keyword">if</span> (isIsomorphic(root1.left, root2.left)  &amp;&amp; isIsomorphic(root1.right, root2.right)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// check 左右和右左</span></span><br><span class="line">           <span class="keyword">if</span> (isIsomorphic(root1.left, root2.right) &amp;&amp; isIsomorphic(root1.right, root2.left)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h3><p>基本思路：<br>根据中序和后序构树.</p><ol><li>将中序数组的每一个元素和下标都存入map中</li><li>后序数组的最后一个数必定是root，在map中找到这个root在inorder数组中对应的下标</li><li>此时该index的左边是左子树，右边是有子树。</li><li>进行递归。<br>右子树的新root为postIndex - 1<br>左子树的新root为postIndex - (inEnd - index) - 1<br>因为post的顺序是左右根，那么post数组倒着来看的话就是根右左。<br>所以当前postIndex - 1就是右子树的root节点。<br>从当前postIndex减去inorder数组中右子树部分的长度（inEnd - index），就是左子树的root节点</li><li>举例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="number">3</span></span><br><span class="line">                   / \</span><br><span class="line">                  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">                    /  \</span><br><span class="line">                   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">         inorder   [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">         postorder [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">start  inStart   inEnd    postIndex   index</span><br><span class="line">          <span class="number">0</span>        <span class="number">4</span>         <span class="number">4</span>          <span class="number">1</span></span><br><span class="line"></span><br><span class="line">right     <span class="number">2</span>        <span class="number">4</span>         <span class="number">3</span></span><br><span class="line"></span><br><span class="line">left      <span class="number">0</span>        <span class="number">0</span>         <span class="number">0</span> = <span class="number">4</span> - (<span class="number">4</span> - <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] in, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span> || post == <span class="keyword">null</span> || in.length != post.length) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            map.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(in, post, <span class="number">0</span>, in.length - <span class="number">1</span>, post.length - <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] in, <span class="keyword">int</span>[] post, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> postIndex, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postIndex &lt; <span class="number">0</span> || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = map.get(post[postIndex]);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(post[postIndex]);</span><br><span class="line">        root.left = helper(in, post, inStart, index - <span class="number">1</span>, postIndex - (inEnd - index) - <span class="number">1</span>, map);</span><br><span class="line">        root.right = helper(in, post, index + <span class="number">1</span>, inEnd, postIndex - <span class="number">1</span>, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Binary-Tree经典题"><a href="#Binary-Tree经典题" class="headerlink" title="Binary Tree经典题"></a>Binary Tree经典题</h1><h2 id="508-Most-Frequent-Subtree-Sum"><a href="#508-Most-Frequent-Subtree-Sum" class="headerlink" title="508. Most Frequent Subtree Sum"></a>508. Most Frequent Subtree Sum</h2><p>基本思路：<br>1.经常会遇到需要对一棵树做一个自底向上的累加过程，这道题的traverse部分很好的实现了这个想法，本质就是postorder。<br>2.在traverse的过程中，用一个HashMap去maintain每个sum的frequency，用一个参数max去记录最大值。<br>3.对整个Map做一个遍历，找出符合的key即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        traverse(root, map);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getValue() == freq) &#123;</span><br><span class="line">                list.add(e.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">traverse</span><span class="params">(TreeNode root, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = traverse(root.left,  map);</span><br><span class="line">        <span class="keyword">int</span> r = traverse(root.right, map);</span><br><span class="line">        <span class="keyword">int</span> sum = l + r + root.val;</span><br><span class="line">        map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        freq = Math.max(map.get(sum), freq);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并两棵二叉树-617-Merge-Two-Binary-Trees"><a href="#合并两棵二叉树-617-Merge-Two-Binary-Trees" class="headerlink" title="合并两棵二叉树 617. Merge Two Binary Trees"></a>合并两棵二叉树 617. Merge Two Binary Trees</h2><p>基本思路：<br>看代码就行了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 != <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            val = t1.val + t2.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            val = t2.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = t1.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        </span><br><span class="line">        cur.left = mergeTrees(t1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : t1.left, t2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : t2.left);</span><br><span class="line">        cur.right = mergeTrees(t1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : t1.right, t2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : t2.right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="652-Find-Duplicate-Subtrees"><a href="#652-Find-Duplicate-Subtrees" class="headerlink" title="652. Find Duplicate Subtrees"></a>652. Find Duplicate Subtrees</h2><h2 id="742-Closest-Leaf-in-a-Binary-Tree"><a href="#742-Closest-Leaf-in-a-Binary-Tree" class="headerlink" title="742. Closest Leaf in a Binary Tree"></a>742. Closest Leaf in a Binary Tree</h2><p>基本思路：<br>1.先将树转化为图，在构图过程中将target node保存下来，再BFS从target node开始找最短路径。<br>2.因为是树，对于每一个node需要存入的邻居包括了它的父亲节点和儿子节点<br>3.如果一个节点不是root，并且它的邻居只有一个节点，那么他是一个leaf（叶子结点）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;TreeNode, List&lt;TreeNode&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(cur)) &#123;</span><br><span class="line">                    map.put(cur, <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map.get(cur).add(cur.left);</span><br><span class="line">                    map.putIfAbsent(cur.left, <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                    map.get(cur.left).add(cur);</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map.get(cur).add(cur.right);</span><br><span class="line">                    map.putIfAbsent(cur.right, <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                    map.get(cur.right).add(cur);</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (k == cur.val) node = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q.clear();</span><br><span class="line">        q.offer(node);</span><br><span class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            List&lt;TreeNode&gt; list = map.get(cur);</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">1</span> &amp;&amp; cur != root) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(list.get(i))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.offer(list.get(i));</span><br><span class="line">                visited.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="BST经典题"><a href="#BST经典题" class="headerlink" title="BST经典题"></a>BST经典题</h1><h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Trees"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Trees" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Trees"></a>235. Lowest Common Ancestor of a Binary Search Trees</h2><p>基本思路：<br>按照BST性质来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a>450. Delete Node in a BST</h2><p>基本思路：<br>删除节点有三种情况：假定找到的需要删除的点为node</p><ol><li>node.left  == null -&gt; return node.right;</li><li>node.right == null -&gt; return node.left;</li><li>node.left  != null &amp;&amp; node.right != null<br>找到右子树中最小的节点，替换当前node，然后递归调用函数删除右子树中最小的点</li></ol><p>图示的话参考：<a href="https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root.val) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; root.val) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            TreeNode cur = findMin(root.right);</span><br><span class="line">            root.val = cur.val;</span><br><span class="line">            root.right = deleteNode(root.right, cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findMin</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="700-Search-in-a-Binary-Search-Trees"><a href="#700-Search-in-a-Binary-Search-Trees" class="headerlink" title="700. Search in a Binary Search Trees"></a>700. Search in a Binary Search Trees</h2><p>基本思路：<br>根据BST性质找就是了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">iteration</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;<span class="comment">// BST</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> &amp;&amp; root.val != val) &#123;</span><br><span class="line">            root = root.val &gt; val ? root.left : root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recursion</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(root.val);</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="776-Split-BST"><a href="#776-Split-BST" class="headerlink" title="776. Split BST"></a>776. Split BST</h2>]]></content>
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>129. Sum Root to Leaf Numbers</title>
      <link href="/2018/07/05/129.%20Sum%20Root%20to%20Leaf%20Numbers/"/>
      <url>/2018/07/05/129.%20Sum%20Root%20to%20Leaf%20Numbers/</url>
      <content type="html"><![CDATA[<p>A binary tree question.</p><p>The general ieda is using preorder traversal in recursion way. Iterative solution is also accepted.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        cur = cur * <span class="number">10</span> + node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += cur;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) dfs(node.left, cur);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) dfs(node.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">iterative</span><span class="params">(TreeNode root)</span> </span>&#123;<span class="comment">// use two stacks to keep nodes and current sum</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; sum = <span class="keyword">new</span> Stack&lt;&gt;(); </span><br><span class="line">        stack.push(root);</span><br><span class="line">        sum.push(root.val);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = sum.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                res += cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">                sum.push(cur * <span class="number">10</span> + node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">                sum.push(cur * <span class="number">10</span> + node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>863. All Nodes Distance K in Binary Tree</title>
      <link href="/2018/07/01/863.%20All%20Nodes%20Distance%20K%20in%20Binary%20Tree/"/>
      <url>/2018/07/01/863.%20All%20Nodes%20Distance%20K%20in%20Binary%20Tree/</url>
      <content type="html"><![CDATA[<p>Use HashMap，先用bfs或dfs将树变成一个图，之后根据target node的neighbors进行逐层搜索，直到distance == K。<br>通过HashSet avoid visited nodes。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, HashSet&lt;TreeNode&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        buildMap(root);</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(target);</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">0</span>; size &lt; len; size++) &#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (dis == K) &#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!map.get(cur).isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (TreeNode t : map.get(cur)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!visited.contains(t)) &#123;</span><br><span class="line">                                q.offer(t);</span><br><span class="line">                                visited.add(t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">return</span> list;</span><br><span class="line">            dis++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMap</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(node);</span><br><span class="line">        map.put(node, <span class="keyword">new</span> HashSet&lt;TreeNode&gt;());</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(cur.left, <span class="keyword">new</span> HashSet&lt;TreeNode&gt;());</span><br><span class="line">                map.get(cur).add(cur.left);</span><br><span class="line">                map.get(cur.left).add(cur);</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(cur.right, <span class="keyword">new</span> HashSet&lt;TreeNode&gt;());</span><br><span class="line">                map.get(cur).add(cur.right);</span><br><span class="line">                map.get(cur.right).add(cur);</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>133. Clone Graph</title>
      <link href="/2018/07/01/133.%20Clone%20Graph/"/>
      <url>/2018/07/01/133.%20Clone%20Graph/</url>
      <content type="html"><![CDATA[<p>This is the BFS + Queue solution, use map to keep original nodes and copied nodes.<br>Map can also avoid loop.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * class UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        UndirectedGraphNode copy = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        map.put(node, copy);</span><br><span class="line">        q.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode cur = q.poll();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode n : cur.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(n)) &#123;</span><br><span class="line">                    map.put(n, <span class="keyword">new</span> UndirectedGraphNode(n.label));</span><br><span class="line">                    q.offer(n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// add neighbors to the copied node</span></span><br><span class="line">                <span class="comment">// map.get(cur) -&gt; copied node of cur</span></span><br><span class="line">                <span class="comment">// map.get(n) -&gt; neighbors of copied node </span></span><br><span class="line">                map.get(cur).neighbors.add(map.get(n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>听雨</title>
      <link href="/2018/07/01/%E5%90%AC%E9%9B%A8/"/>
      <url>/2018/07/01/%E5%90%AC%E9%9B%A8/</url>
      <content type="html"><![CDATA[<p>第一次知道竹山词，是高中时候许南翔一笔笔写在黑板上，说你们现在不懂，觉得这词很一般，将来就懂了。</p><p>虞美人这个词牌，历来最推崇不过李煜的“春花秋月何时了，往事知多少”。但我私心里还是更喜欢蒋捷的这首听雨。</p><p>我想许南翔当年给我们上课时，应该和我现在是差不多的年纪。过了弱冠之年，离而立却还有一点距离，对人生这个事刚刚有了一点自己的理解。这个世界的万般头绪铺开在我的面前，少年意气开始一点点消减。</p><p>开始有了一些却道天凉好个秋的滋味。<br><a id="more"></a><br>晚上一个人在bonsai的吧台吃冷饭团，一边感受着突然而至的阵雨。没有什么悲欢离合也无情。</p><p>只有特别深的孤独。</p><p>一个人走在回出租房的路上，穿过不同颜色的皮肤，感受到夹带着雨丝的冷风。</p><p>我突然开始怀念家乡闷热的雨季，那潮湿绵密的水汽将我包裹的感觉，那江南水乡特有的味道。</p><p>那味道是妈丢给我的毛巾的香味，是爸端出的来的饭菜的香味，是家里放久了的家具，在梅雨季节散发出来的一点点霉味。</p><p>雨声夹带着电视节目的人声，混合着小区外远远传来的几句咒骂。</p><p>而现在雨声里只参杂着键盘敲击的哒哒声。</p><p>十几岁的我不明白雨水滴落地面的声音怎么能用得上听，但现在知道了。原来只有生活并不一帆风顺的人，才能听到雨的声音。</p><p>我合上电脑，看着窗外的雨帘中渐渐显出远处方尖碑的轮廓，若隐若现，居然像极了鼓楼。</p>]]></content>
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便写写 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
