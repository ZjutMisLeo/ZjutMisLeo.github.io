<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode中的Word题]]></title>
    <url>%2F2018%2F10%2F28%2FLeetCode%E4%B8%AD%E7%9A%84Word%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多经典题，其实不难想，但是写起来有很多要注意的东西，把思路写一下，面试时候解释起来也更顺。 126. Word Ladder II基本思路：1.先用BFS进行构图，连接每个单词。使用两个HashMap：paths &amp; levels。 paths 用来存每个word和它的children的关系，是Map&lt;String, List&gt;, 用于之后DFS遍历 levels 用来存每个word和当前level，或者说step的关系，是Map&lt;String, Integer&gt; 2.使用levels的原因：1234567 hit level 1 / \hot lit level 2 \ / \ lot lid level 3 \ / lod level 4 当BFS到达hot（即queue中poll出hot）时，lot作为一个可选child已经被放入visited set 但lot也是lit的可选child，而因为此时lot has been visited，lot不会被加入lit的children list。所以我们需要levels Now levels contains key lot，and level of lot is 3（在hot那一步存的） so if level of lot == level of lit + 1，那么lot就可以被加入lit的children list 3.如果已经找到end（fount == true），不要把end放到visited中，用来避免其他的路径无法添加end到自己的list中。 4.DFS遍历paths，通过backtracking输出所有的可能答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String begin, String end, List&lt;String&gt; wordList) &#123; Map&lt;String, List&lt;String&gt;&gt; paths = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; levels = new HashMap&lt;&gt;(); HashSet&lt;String&gt; dic = new HashSet&lt;&gt;(wordList); HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); int level = 1; boolean found = false; q.offer(begin); visited.add(begin); levels.put(begin, level); while (!q.isEmpty() &amp;&amp; !found) &#123; int size = q.size(); for (int index = 0; index &lt; size; index++) &#123; String cur = q.poll(); for (int i = 0; i &lt; cur.length(); i++) &#123; char[] ch = cur.toCharArray(); for (char c = 'a'; c &lt;= 'z'; c++) &#123; ch[i] = c; String temp = new String(ch); if (!visited.contains(temp) &amp;&amp; dic.contains(temp)) &#123; if (temp.equals(end)) &#123; found = true; &#125; if (!paths.containsKey(cur)) &#123; paths.put(cur, new ArrayList&lt;String&gt;()); &#125; paths.get(cur).add(temp); q.offer(temp); // if we have found the shortest path, don't add end word to visited set // Because the next word still need to use this if condition to make path if (!found) visited.add(temp); levels.put(temp, level + 1); &#125;else if (levels.containsKey(temp))&#123; if (levels.get(temp) == levels.get(cur) + 1) &#123; // 之前的if中，可能没有把cur存到paths里，所以这里也要做一个判断 if (!paths.containsKey(cur)) &#123; paths.put(cur, new ArrayList&lt;String&gt;()); &#125; paths.get(cur).add(temp); &#125; &#125; &#125; &#125; &#125; level++; &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(begin); dfs(res, list, begin, end, paths, levels); return res; &#125; public void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, String cur, String end, Map&lt;String, List&lt;String&gt;&gt; paths, Map&lt;String, Integer&gt; levels) &#123; if (cur.equals(end)) &#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; // need check since somtimes we can't find path to reach the endWord if (!paths.containsKey(cur) || paths.get(cur).size() == 0) &#123; return; &#125; for (String next : paths.get(cur)) &#123; if (levels.get(cur) + 1 == levels.get(next)) &#123; list.add(next); dfs(res, list, next, end, paths, levels); list.remove(list.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swap相关的题]]></title>
    <url>%2F2018%2F10%2F23%2FSwap%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天和一个傻逼亚麻recruiter打电话，妈的问了三个问题直接叹了个气挂电话了。明明是个白皮口音还没上次的黑哥来的清楚。我问他你觉得我讲的清楚么，他说你自己清楚就行。？？？？？？？ 我真是醉了。刷题了刷题了。. 非LC的高频题。Leetcode801. Minimum Swaps To Make Sequences Increasing基本思路：不看答案不会做的DP题。 首先明确题目保证必定有解，那么对于数组A和B，在 i-1 和 i 的位置上只有两种情况第一种：A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]第二种：A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]原因也很简单，如果原本的序列不是递增的，那么交换后必须递增。例如：3 5 4，发现4 &lt; 5， 不满足第一个condition，那么就得满足第二个condition，不然没法保证一定有答案。2 3 7注意这两个条件是可以同时满足的，因此必须用两个if来判断。 使用两个数组，swap 和 keep，swap表示当前位置交换，keep表示当前位置不交换。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int minSwap(int[] A, int[] B) &#123; int len = A.length; int[] swap = new int[len]; int[] keep = new int[len]; // 这儿有个小trick，就是condition 1 不满足的情况下，swap[i]的值其实就是keep[i - 1] + 1 // 所以得保证此时swap[i]是n，这样就能取到想要的值 // 所以这里的赋值是很有意义的 for (int i = 0; i &lt; len; i++) &#123; swap[i] = i; keep[i] = i; &#125; swap[0] = 1; // 已经交换了下标0的两个element，既然交换了就要 +1, 这里交换不影响 keep[0] = 0; // 没交换 for (int i = 1; i &lt; len; i++) &#123; // 这里其实判断的是都换和都不换 if (A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]) &#123; // i - 1那组换了，为了保证increasing，i这组也得换，因为换了所以 + 1 swap[i] = swap[i - 1] + 1; // i - 1那组没换，所以i这组也不用换 keep[i] = keep[i - 1]; &#125; if (A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]) &#123; // 决定换，因为i-1那组和i这组都换的情况在之前已经计算过了，所以和i - 1没换，但是i换的情况比较。 swap[i] = Math.min(swap[i], keep[i - 1] + 1); // 决定不换，因为i-1那组和i这组都不换的情况在之前已经计算过了，所以和i - 1换，但是不换的情况比较。 keep[i] = Math.min(swap[i - 1], keep[i]); &#125; &#125; return Math.min(swap[len - 1], keep[len - 1]); &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map，Hash和Map的题]]></title>
    <url>%2F2018%2F09%2F06%2FJava%E4%B8%AD%E7%9A%84Map%2F</url>
    <content type="text"><![CDATA[算是一个上课总结吧，复习复习一下Map，等面试的日子有点难熬的。这个总结的比我自己到位，包括collision，double size，hash function，equals function等等https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#%E4%B8%80%E6%A6%82%E8%A7%88 常用的MapTreeMap：基于红黑树实现。查找删除O(logN) HashMap：基于哈希表实现。查找删除O(1) HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 HashMap和HashTable的区别HashTable 使用 synchronized 来进行同步。HashMap 可以插入键为 null 的 Entry。HashMap 的迭代器是 fail-fast 迭代器。HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 如何实现hash方法A long time ago, I bought a data structures book off the bargain table for $1.25. In it, the explanation for a hashing function said that it should ultimately mod by a prime number because of “the nature of math”.What do you expect from a $1.25 book?Anyway, I’ve had years to think about the nature of math, and still can’t figure it out. 笑尿，但是确实有很多人和我一样疑惑为什么hash时候要选择prime number，是因为数学的本质么。 the size of buckets is a power of 2, so use prime number can reduce collision. Becasue people usually compute index of each bucket based on hashcode % size. It turns out that “because of the nature of maths”, if the constant used in the hash, and the number of buckets, are coprime, then collisions are minimised in some common cases. Leetcodeword pattern &amp; word pattern II]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2018%2F08%2F27%2FDynamic%20Programming%2F</url>
    <content type="text"><![CDATA[今天听了Casablanca，特别有触动。加上工卡也批了，还是蛮快乐的(最近最快乐的一天)。 上了课，复习一下。动态规划的核心就是状态的转移，而状态的转移通过状态转移方程和相对应的数据结构来表现。 通过题目应该更好理解。先从LC都没兴趣放的基本题目开始。 基本题LCS(Longest Common Subsequence)LCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3.LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4. LIS(Longest Increasing Subsequence)LC原题322. Coin Change基本思路：经典中的经典dp[amount] 表示凑成当前数额共需几枚硬币。在每一个数额下，对coins中的每一枚硬币都要尝试。 初始赋值：dp[0] = 0, dp[1] -&gt; dp[amount] = amount + 1 (一个大于amount的数字)状态转移方程：if (coin &lt;= curAmount) dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1); 手动过一遍test case。1234567891011121314151617when curAmount = 2, coin = 1, dp[2] = Math.min(amount + 1, dp[1] + 1) = 2; curAmount = 2, coin = 2, dp[2] = Math.min(2, dp[0] + 1) = 1;when curAmount = 3, coin = 1, dp[3] = Math.min(amount + 1, dp[2] + 1) = 2; curAmount = 3, coin = 2, dp[3] = Math.min(2, dp[1] + 1) = 2;when curAmount = 4, coin = 1, dp[4] = Math.min(amount + 1, dp[3] + 1) = 3; curAmount = 4, coin = 2, dp[4] = Math.min(3, dp[2] + 1) = 2;when curAmount = 5, coin = 1, dp[5] = Math.min(amount + 1, dp[4] + 1) = 3; curAmount = 5, coin = 2, dp[5] = Math.min(3, dp[3] + 1) = 3; curAmount = 5, coin = 5, dp[5] = Math.min(3, dp[0] + 1) = 1;......when curAmount = 11, coin = 1, dp[11] = Math.min(amount + 1, dp[10] + 1) = 3; curAmount = 11, coin = 2, dp[11] = Math.min(3, dp[9] + 1) = 3; curAmount = 11, coin = 5, dp[11] = Math.min(3, dp[6] + 1) = 3;代码如下：1234567891011121314151617class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; for (int i = 0; i &lt;= amount; i++) &#123; dp[i] = amount + 1; &#125; dp[0] = 0; for (int curAmount = 1; curAmount &lt;= amount; curAmount++) &#123; for (int coin : coins) &#123; if (coin &lt;= curAmount) &#123; dp[curAmount] = Math.min(dp[curAmount], dp[curAmount - coin] + 1); &#125; &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount]; &#125;&#125; 416. Partition Equal Subset Sum基本思路：也很经典的一道题，判断数组能否被二等分。当然backtracking肯定能解，不过这里还是dp更好，更快其实就是一道背包问题，每个石头拿一次，问能否从石堆中取到刚好填满背包重量的石头。 338. Counting Bits对位运算一直没什么感觉。。还是找规律好了0-&gt;00000000 9 -&gt;000010011-&gt;00000001 10-&gt;000010102-&gt;00000010 11-&gt;000010113-&gt;00000011 12-&gt;000011004-&gt;00000100 13-&gt;000011015-&gt;00000101 14-&gt;000011106-&gt;00000110 15-&gt;000011117-&gt;00000111 16-&gt;000100008-&gt;00001000 877. Stone Game这题是国内日企WAP的面试题之一，用DP没这么容易想。 96. Unique Binary Search Trees基本思路：123456789101112situation of only 1 node f(1) = 1situation of 2 nodes f(2) = 2 2 1 / \ 1 2situation of 3 nodes f(3) = 5 1 2 3 / \ / \ / \f(0) f(2) f(1) f(1) f(2) f(0) 以此类推，不难发现其中的dp转移规律 1234f(2) = f(1) * f (0) + f(0) * f(1);f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0);f(4) = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0);...... f(0) = 1其实就表示root的左/右子树全空也是一种情况讲道理吧，这题我不看答案不太想得到。。 12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125;&#125; 95. Unique Binary Search Trees II基本思路：还是从之前的分析出发，通过一个helper method, divide and conquer看代码的话很容易明白思路，但是go through test case不是很容易。背吧T T 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); if (n == 0) return list; return helper(1, n); &#125; public List&lt;TreeNode&gt; helper(int i, int j) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if (i &gt; j) &#123; // 这一段if不能少，lsub和rsub在这部分被return res.add(null); return res; &#125; for (int k = i; k &lt;= j; k++) &#123; List&lt;TreeNode&gt; lsub = helper(i, k - 1); List&lt;TreeNode&gt; rsub = helper(k + 1, j); // 等于dp中的相乘 for (TreeNode l : lsub) &#123; for (TreeNode r : rsub) &#123; TreeNode cur = new TreeNode(k); cur.left = l; cur.right = r; res.add(cur); &#125; &#125; &#125; return res; &#125;&#125; 10. Regular Expression Matching基本思路：也是个高频面筋题吧，狗家的。感觉LC前300题都还挺经典的。]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie Tree]]></title>
    <url>%2F2018%2F08%2F18%2FTrie%2F</url>
    <content type="text"><![CDATA[刷题刷到要用trie的题又写不出了。。把trie好好写一写。https://leetcode.com/articles/implement-trie-prefix-tree/This explanation is so fucking amazing. LC article is so qiang! ApplicationsTrie(prefix tree)会被用于： 自动补全 拼写检查 IP routing T9 predictive text（九宫格输入法文本预测） why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity could deteriorate to O(n), where nn is the number of keys inserted. Trie could use less space compared to Hash Table when storing many keys with the same prefix. In this case using trie has only O(m) time complexity, where mm is the key length. Searching for a key in a balanced tree costs O(mlog n) time complexity. TrieNode structure1234567891011121314151617181920212223242526272829class TrieNode&#123; private TrieNode[] child; private final int N = 26; private boolean isWord = false; public TrieNode() &#123; child = new TrieNode(N); &#125; public boolean containsKey(char c) &#123; return child[ch - 'a'] != null; &#125; public TrieNode get(char c) &#123; return child[ch - 'a']; &#125; public void put(char c, TrieNode node) &#123; child[c - 'a'] = node; &#125; public boolean isWord() &#123; return isWord; &#125; public void setWord() &#123; isWord = true; &#125;&#125; Insertion of a key to a trie1234567891011121314151617181920class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125;&#125; Complexity Analysis Time complexity : O(m), where m is the key length.In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only mm operations. Space complexity : O(m).In the worst case newly inserted key doesn’t share a prefix with the the keys already inserted in the trie. We have to add mm new nodes, which takes us O(m) space. Search for a key in a trie123456789101112131415161718192021222324class Trie &#123; ... // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125;&#125; Complexity Analysis Time complexity : O(m) In each step of the algorithm we search for the next key character. In the worst case the algorithm performs m operations. Space complexity : O(1) Search for a key prefix in a trie12345678910class Trie &#123; ... // Returns if there is any word in the trie // that starts with the given prefix. public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node != null; &#125;&#125; Complexity Analysis Time complexity : O(m) Space complexity : O(1)]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Back Tracking]]></title>
    <url>%2F2018%2F08%2F16%2FBack%20Tracking%2F</url>
    <content type="text"><![CDATA[他乡逢七夕,旅馆益羁愁。 不见穿针妇,空怀故国楼。 绪风初减热,新月始登秋。 谁忍窥河汉,迢迢问斗牛。 报班的讲了递归和回溯，我自己也来总结一下吧。OA两个题写了我好久。 A general approach to backtracking questions in Java.https://leetcode.com/problems/combination-sum/discuss/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioningLC discuss里这位老哥总结的很好。我自己再精简下。 Subsets I &amp; Subsets III和II只有一个不同，数组中如果有重复元素，如何避免出现重复的子集？ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 关键在于 排序 和 if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; 排序是确保后一句起作用的前提。举个例子 对于不含重复元素的input，比如123, 生成的子集为[], 1, 12, 13, 123, 2, 23, 3 对于含重复元素的input，比如122, 那生成的子集为[], 1, 12, 12, 122, 2, 22, 2 去重的原理：当前子集为12时，backtracking删除2，当加入index为2的元素2时，发现重复，因此不加。 i &gt; start的目的是为了保证第一个出现的重复的值会被加入subset中。 Permutationsuse boolean[], HashSet, or swap() is both ok.如果限制不允许使用额外的空间来check each element是不是被使用，那么swap是一个很好的选择。注意使用swap的话，for loop中i由index赋值，而不是每次从0开始。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length == 0) return res; Arrays.sort(nums); bt(nums, res, new ArrayList&lt;Integer&gt;(), 0); return res; &#125; public void bt(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, int index) &#123; if (index == nums.length) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = index; i &lt; nums.length; i++) &#123; list.add(nums[i]); swap(nums, index, i); bt(nums, res, list, index + 1); swap(nums, index, i); list.remove(list.size() - 1); &#125; &#125; public void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 698. Partition to K Equal Sum Subsets基本思路：和473是完全一样的问题。 先判断和能否被4整除，target = sum / 4;之后对Array排序，如果存在element &gt; target return false;通过一个while loop寻找nums中是否有element恰好等于target，如果存在，k–，相当于桶变少了，加快搜索进度。helper method相当于把剩下的元素分配到K个桶中，保证每次分配桶的sum + 分配进来的值小于等于target。如果所有元素全被分配了，说明可以K等分。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; if (sum % k != 0) return false; int target = sum / k; Arrays.sort(nums); int index = nums.length - 1; if (nums[index] &gt; target) return false; while (index &gt;= 0 &amp;&amp; nums[index] == target) &#123; index--; k--; &#125; int[] sub = new int[k]; return helper(nums, sub, target, index); &#125; public boolean helper(int[] nums, int[] sub, int target, int index) &#123; if (index &lt; 0) return true; int cur = nums[index--]; for (int i = 0; i &lt; sub.length; i++) &#123; if (sub[i] + cur &lt;= target) &#123; sub[i] += cur; if (helper(nums, sub, target, index)) return true; sub[i] -= cur; &#125; if (sub[i] == 0) break; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[287. Find the Duplicate Number]]></title>
    <url>%2F2018%2F08%2F08%2F287.%20Find%20the%20Duplicate%20Number%2F</url>
    <content type="text"><![CDATA[今天收了封FB内推据信，我和kisday都想不明白问题在哪。。感觉是真的要报班了。。至少保证我有个面试吧，不然题刷的再多有什么用 http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=176498&amp;extra=page%3D1%26filter%3Dsortid%26sortid%3D192%26sortid%3D192 在地里看了这个帖子，难受的一批。难受就对了，好走的都是下坡路。 但是题还是要刷。这题有要求，不能modify原数组，因此不能像442题那样根据下标取负。要利用duplicate num这个特点。在该数组中两个不同的index会指向同一个num。因此考虑做一个num -&gt; index的连接，那么该链表成环。问题转化为快慢指针链表找环。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Substring Search Problem]]></title>
    <url>%2F2018%2F08%2F06%2FSubstring%20Search%20Problem%2F</url>
    <content type="text"><![CDATA[刷面经时候看到，正好总结一下这一类substring search问题（其实本质逻辑是滑窗），discuss里的template给的很好，不过我觉得还是自己手写过一遍比较好。笨办法帮助理解，毕竟自己不是聪明人。 LC76. Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot; 开一个map（可以数组或者HashMap）用来check S中的字母是否存在于T中。 参数含义： count 用于判断是否找到了一组解。if (count == 0) 就说明T中的所有字母已在当前指针扫描范围被全部cover。 初始化为map.size(), 因为T中可能有重复元素，所以用map.size()。count的增加取决于map中value是否为0。 left 左指针 right 右指针 head 用来maintain每次找到合法解后左指针的位置。 min 当前的最小长度，初始化为Integer.MAX_VALUE 按照代码想法手动过一遍test case: “cabwefgewcwaefgcf”，”cae” round 1: substring is cabwe right = 4, 此时count == 0，left指针开始move，此时left = 0, min = 6, head = 0 之后left和right分别自增，right = 5, left = 1; round 2: 因为c在round 1中被重新加到map中，下一步当right扫到c时，count == 0, 扫描中还会扫到一个e，使其在map中的val - 1 substring is abwefgewc right = 9, 此时count == 0，left指针开始move，此时left = 1, right - left + 1 &gt; min。head和min不变。 之后left和right分别自增，right = 10, left = 2; round 3: substring is efgewcwa right = 11, 此时count == 0， left指针开始move，扫到第一个e，发现map.get(e) == -1, 遂val+1，但map.get(e) 并没有大于0，count不变仍为0。所以while loop中left指针继续向右move，直到发现第二个e为止。 substring is ewcwa right = 11, count == 0, left = 7, right - left + 1 &lt; min, min = 5, head = 7; round 4: substring is cwae right = 12, count == 0, left = 9, right - left + 1 &lt; min, min = 4, head = 9; 找到最优解。 round 5: sunstring is aefgc right - left + 1 &gt; min, pass 扫描完毕 code 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int min = Integer.MAX_VALUE; int left = 0, right = 0, count = map.size(), head = 0; while (right &lt; s.length()) &#123; char r = s.charAt(right); if (map.containsKey(r)) &#123; map.put(r, map.get(r) - 1); if (map.get(r) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; char l = s.charAt(left); if (map.containsKey(l)) &#123; map.put(l, map.get(l) + 1); if (map.get(l) &gt; 0) &#123; count++; &#125; &#125; if (right - left + 1 &lt; min) &#123; head = left; min = right - left + 1; &#125; left++; &#125; right++; &#125; return min == Integer.MAX_VALUE ? "" : s.substring(head, head + min); &#125;&#125; 438. Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p&apos;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &quot;cbaebabacd&quot; p: &quot;abc&quot; Output: [0, 6] Explanation: The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;. The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. 上一题是找subsequence，但是通过check right - left + 1 == p.length()，就能把代码转化为找substring。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : p.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int left = 0, right = 0, head = 0, count = map.size(); while (right &lt; s.length()) &#123; char r = s.charAt(right); if (map.containsKey(r)) &#123; map.put(r, map.get(r) - 1); if (map.get(r) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; char l = s.charAt(left); if (map.containsKey(l)) &#123; map.put(l, map.get(l) + 1); if (map.get(l) &gt; 0) &#123; count++; &#125; &#125; if (right - left + 1 == p.length()) &#123; head = left; list.add(head); &#125; left++; &#125; right++; &#125; return list; &#125;&#125; 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 思路是一样的，右指针发现重复的那个数之后（map.get(r) &gt; 1），左指针开始扫描，直到找到和当前right指针对应的元素相同的元素。此时左指针左边的部分不会被用于之后的寻找最优解的过程中，在map中对应的val也为0.我在这里用了boolean found 来作为判断的条件是否进入左指针寻值的while loop，因为使用count会让人有点迷惑。1234567891011121314151617181920212223242526class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0, right = 0, len = 0; boolean found = false; while (right &lt; s.length()) &#123; char r = s.charAt(right); map.put(r, map.getOrDefault(r, 0) + 1); if (map.get(r) &gt; 1) &#123; found = true; &#125; while (found) &#123; char l = s.charAt(left); if (map.get(l) &gt; 1) &#123; found = false; &#125; map.put(l, map.get(l) - 1); left++; &#125; //System.out.println("right is " + right + " left is " + left); len = Math.max(right - left + 1, len); right++; &#125; return len; &#125;&#125;]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search & Sort]]></title>
    <url>%2F2018%2F07%2F29%2FSearch%20%26%20Sort%2F</url>
    <content type="text"><![CDATA[最近看到FB有人被面了Kth smallest element，我也重新复习一下。// 白复习解法1: 开一个PriorityQueue，time complexity is Nlog(K). 解法2: quick select 思路和快排相同，但只需要对一边进行排序就行。 因为排序后pivot在整个list中的index是确定的，我们只需要比较K和index，如果K &lt; index，那么说明要找的target num在左半部分，反之亦然。 顺便也重新理一下一些基本的选择和排序算法。 高效的排序quick sortbinary searchJon Bentley说90%的程序员都写不对二分, 我个人觉得写二分最好就用一个模板。另外这个帖子真的讲的非常非常好。http://www.1point3acres.com/bbs/thread-432793-1-1.html 当搜索到达right - left == 1的时候，这时候mid是等于left的。 1234567891011121314public int binarySearch(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; //avoid overflow if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] == target) &#123; return mid; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; //dont find&#125; 69. Sqrt(x)Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1 Input: 4 Output: 2 Example 2 Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 这题首先要避免越界。因此mid * mid &gt; x 应该写成 mid &gt; x / mid.这时候就要避免mid = 0。当right - left = 1时，mid = left（right = 1, left = 0, mid = 0）所以left不能从0开始。所以搜索范围确定为1 ~ x（x的平方必定大于x） 接下来要处理的问题是，如果找不到target sqrt，该怎么返回值。用7举例搜索区间到达[2,3]时，mid = 2, left = mid + 1 = 3.搜索区间到达[3,3]时，mid = 3, left = 3, right = 3 - 1 = 2。跳出循环。可以发现mid其实是刚好平方后大于x的那个值，因此我们返回的right = mid - 1就是解。 这时候要考虑下Corner Case，比如input是0或者2147483647。逻辑走完发现没啥问题。12345678910111213141516class Solution &#123; public int mySqrt(int x) &#123;// 1 9 int l = 1, r = x; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (mid &gt; x / mid) &#123; r = mid - 1; &#125; else if (mid == x / mid) &#123; return mid; &#125; else&#123; l = mid + 1; &#125; &#125; return r; &#125;&#125; 50. Pow(x, n)Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.0000 Example 2: Input: 2.10000, 3 Output: 9.2610 Example 3: Input: 2.00000, -4 Output: 0.2500 Explanation: 2-2 = 1/22 = 1/4 = 0.25 很不喜欢这题，因为conner case太烦了。虽然不是binary seach但是还是用上了二分的想法，所以也放进来了。general idea is loop，蛤无疑问（混入了奇怪的东西）TLE。因为 x的n次方 = x的n/2次方 * x的n/2次方，所以recursion就出来了。odd就是拿一个出来再/2，很容易想到 然后是处理n &lt; 0的情况，就是进入递归前把n取反，x = 1/x。 这里出现问题，if n = Inetegr.MIN_VALUE，取反就overflow，因此要做一个处理。注意处理n之后也不要忘了x，因为n从-2147483648 变成了 214748364747，正负会有影响：x = x &gt; 0 ? 1.0 / x : -(1.0 / x);12345678910111213141516171819202122class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1.0; if (n == 1) return x; if (n &lt; 0) &#123; if (n == Integer.MIN_VALUE) &#123; n = -(n + 1); x = x &gt; 0 ? 1.0 / x : -(1.0 / x); &#125; else &#123; n = -n; x = 1.0 / x; &#125; &#125; if (n % 2 == 0) &#123; return myPow(x * x, n / 2); &#125; else &#123; return x * myPow(x * x, n /2); &#125; &#125;&#125; 34. Find First and Last Position of Element in Sorted Array基本思路：1.两个binary search，找到target后一个继续向左，一个继续向右。2.在当前搜索找到target后，记录index后继续向左/右搜索，。123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[2]; res[0] = left(nums, target); res[1] = right(nums, target); return res; &#125; public int left(int[] nums, int target) &#123; //5,7,7,8,8,10 int index = -1, l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &gt;= target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; if (nums[mid] == target) index = mid; &#125; return index; &#125; public int right(int[] nums, int target) &#123; //5,7,7,8,8,10 int index = -1, l = 0, r = nums.length - 1; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] &lt;= target) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; if (nums[mid] == target) index = mid; &#125; return index; &#125;&#125; 153. Find Minimum in Rotated Sorted ArraySort Problems179. Largest Number基本思路：这题很有意思，先将int 转为 String，之后开始排序，重写comparator; 排序的逻辑是，String A and String B，if A+B &gt; B+A, 则A在B的前面; for example: 930 &gt; 309, so [9, 30]. String的比较可以直接用compareTo(); 最后根据排序的String[] 拼接字符串输出即可。123456789101112131415161718192021222324252627class Solution &#123; public String largestNumber(int[] nums) &#123; if (nums.length == 0) return ""; if (nums.length == 1) return String.valueOf(nums[0]); int len = nums.length; String[] strs = new String[len]; for (int i = 0; i &lt; len; i++) &#123; strs[i] = String.valueOf(nums[i]); &#125; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; public int compare(String l, String r) &#123; String s1 = l + r; String s2 = r + l; return s2.compareTo(s1); &#125; &#125;); if (strs[0].equals("0")) return "0"; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; sb.append(str); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Spanning Tree & Union found]]></title>
    <url>%2F2018%2F07%2F22%2FMinimum%20Spanning%20Tree%2F</url>
    <content type="text"><![CDATA[今天老姐让我写最小生成树，憋了半天写不出来=，= 最骚的是kisday和我说他也不会写，我会信？ 现在认真学习了一遍，放个总结免得以后又忘了。虽然我隐隐觉得亚麻不会给我这个用的机会。// 确实没给我OA，我可透您马。 最小生成树：连通加权无向图中一棵权值最小的生成树。A. Kruskal算法 （摘自维基百科） 步骤： 1.新建图G，G中拥有原图中相同的节点，但没有边 2.将原图中所有的边按权值从小到大排序 3.从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中（说人话：如果成环就不选这条边），则添加这条边到图G中 4.重复3，直至图G中所有的节点都在同一个连通分量中（所有点都用完了） 证明： 反证法。如果这颗树不是最小生成树，那么一定有一条不在这个树中的边。这条边必定会和其中某些变成环，但环中别的边都是权值最小的，所以如果使用这条边而删去其他的边，那么整颗树的权值就不是minimum了。 注意： 判断连接的两点是否在联通分量中（会不会成环）需要使用并查集。 Union Find用法Find(x): find the root/cluster-id of x Union(x, y): merge two clusters Check whether two elements are in the same set or not in O(1). Find: O(ɑ(n)) ≈ O(1) Union: O(ɑ(n)) ≈ O(1) Space: O(n) Without optimization: Find: O(n)同时使用路径压缩、按秩（rank）合并优化的程序每个操作的平均时间仅为O(ɑ(n))，其中a(n)是n = f(x) = A(x,x)的反函数， A 是急速增加的阿克曼函数。因为a(n)是其反函数，故a(n)在n十分巨大时还是小于 5。因此，平均运行时间是一个极小的常数。实际上，这是渐近最优算法. Two key optimizations: 1.Path compression: make tree flat2.Union by rank: merge low rank tree to high rank one Implementations:12345678910111213141516171819202122232425262728293031323334353637class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; // pu is the parent of u, pv is the parent of v int pu = find(u); int pv = find(v); if (pu == pv) return false;// They are in the same clusterd already if (ranks[pu] &gt; ranks[pv]) &#123;// merge low rank tree to high rank tree parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; Leetcode721. Accounts Merge基本思路:做一个 email -&gt; name 映射做一个 email -&gt; ID 映射一个email只对应一个ID，这样在并查集中如果两个cluster包含相同的email会被merge。根据cluster index将每个email放到HashMap中。对email list进行排序，并且插入email -&gt; name映射中对应的name。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; UnionFind uf = new UnionFind(10001); Map&lt;String, String&gt; emailToName = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; emailToId = new HashMap&lt;&gt;(); int id = 0; for (List&lt;String&gt; account : accounts) &#123; String name = account.get(0); for (int i = 1; i &lt; account.size(); i++) &#123; String email = account.get(i); // name和email是一对多的关系，不会出现不同的名字却有相同的email的情况。 emailToName.put(email, name); if (!emailToId.containsKey(email)) &#123; emailToId.put(email, id++); &#125; // 对每个account进行union，存在连通分量则两个account被merge uf.union(emailToId.get(account.get(1)), emailToId.get(email)); &#125; &#125; Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String email : emailToName.keySet()) &#123; int index = uf.find(emailToId.get(email)); // 根据 cluster index 将每个email归类 if (!map.containsKey(index)) &#123; map.put(index, new ArrayList&lt;String&gt;()); &#125; map.get(index).add(email); &#125; for (List&lt;String&gt; list : map.values()) &#123; // 排序后 根据email -&gt; name的映射将名字加入list Collections.sort(list); list.add(0, emailToName.get(list.get(0))); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125;class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; // pu is the parent of u, pv is the parent of v int pu = find(u); int pv = find(v); if (pu == pv) return false;// They are in the same clusterd already if (ranks[pu] &gt; ranks[pv]) &#123;// merge low rank tree to high rank tree parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; 684. Redundant Connection基本思路：如果两个点无法被union，说明他们已经在一个cluster中，此时连接这两点的edge会导致树中有环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; UnionFind uf = new UnionFind(1000); for (int[] edge : edges) &#123; if (!uf.union(edge[0], edge[1])) return edge; &#125; return new int[2]; &#125;&#125;class UnionFind&#123; private int[] parents; private int[] ranks; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; for (int i = 0; i &lt; parents.length; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; return true; &#125;&#125; 547. Friend Circles基本思路：如果使用并查集，则在UnionFind class加一个参数count用来maintain当前cluster的个数。每次union都会使count - 1。 注意此时new UnionFind(n)时，n必须刚好是所有需要计算的元素的个数，此题中就是学生个数N。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int findCircleNum(int[][] M) &#123; int N = M.length; UnionFind u = new UnionFind(row); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; if (M[i][j] == 1) &#123; if (!u.union(i, j)) continue; &#125; &#125; &#125; return u.count; &#125;&#125;class UnionFind &#123; int[] parents; int[] ranks; int count; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; count = n; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; count--; return true; &#125; public int find(int u) &#123; while (parents[u] != u) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125;&#125; 765. Couples Holding Hands基本思路：先明确一点，如何判断两个数是一对夫妻 -&gt; nums[i] / 2 == nums[j] / 2。比如2，3和4，5，除2之后为1，1和2，2;这样判断的好处在于不用考虑位置，like 0，1 和1，0; 并查集中的元素个数为 N = row.length / 2;使用并查集的话， 128. Longest Consecutive Sequence基本思路：使用并查集，将相差为1的元素放入一个cluster，最后统计每个element在unino find中对中的parent的个数，最多的那个就是答案 [100, 4, 200, 1, 3, 2] 1234是一个cluster，100是一个，200是一个。1234的parent都是0，所以答案是4 使用一个hashmap在遍历中maintain nums[i], nums[i] + 1 and nums[i] - 1的关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public int longestConsecutive(int[] nums) &#123; UnionFind un = new UnionFind(nums.length); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) continue; map.put(nums[i], i); if (map.containsKey(nums[i] + 1)) &#123; un.union(map.get(nums[i] + 1), i); &#125; if (map.containsKey(nums[i] - 1)) &#123; un.union(map.get(nums[i] - 1), i); &#125; &#125; int[] parents = un.getParents(); int[] count = new int[nums.length + 1]; int res = 0; for (int i = 0; i &lt; nums.length; i++)&#123; count[un.find(i)]++; res = Math.max(res, count[un.find(i)]); &#125; return res; &#125;&#125;class UnionFind &#123; private int[] parents; private int[] ranks; int count; public UnionFind(int n) &#123; parents = new int[n + 1]; ranks = new int[n + 1]; count = n; for (int i = 0; i &lt;= n; i++) &#123; parents[i] = i; ranks[i] = 1; &#125; &#125; public boolean union(int u, int v) &#123; int pu = find(u); int pv = find(v); if (pu == pv) return false; if (ranks[pu] &gt; ranks[pv]) &#123; parents[pv] = pu; &#125; else if (ranks[pv] &gt; ranks[pu]) &#123; parents[pu] = pv; &#125; else &#123; parents[pv] = pu; ranks[pu]++; &#125; count--; return true; &#125; public int find(int u) &#123; while (u != parents[u]) &#123; parents[u] = parents[parents[u]]; u = parents[u]; &#125; return u; &#125; public int[] getParents()&#123; return parents; &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java lambda expressions]]></title>
    <url>%2F2018%2F07%2F15%2FJava%20lambda%20expressions%2F</url>
    <content type="text"><![CDATA[重写comparator:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Prime Number]]></title>
    <url>%2F2018%2F07%2F09%2FPrime%20Number%2F</url>
    <content type="text"></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万历和鱼]]></title>
    <url>%2F2018%2F07%2F08%2F%E4%B8%87%E5%8E%86%EF%BC%8C%E5%A7%9A%E8%B4%9D%E5%A8%9C%E5%92%8C%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[看了半本万历十五年，挺有意思的一本书。讲了一个被文官和儒家的规矩束缚的可怜皇帝。 昨天朋友深夜打电话给我，接起来就是一阵啜泣。电话那边一句我想回NB了，让我也感觉鼻头一酸。我好明白这种感觉。 我说实在不行就回家吧，其实我也好累，扛不住也正常。他却只是在另一边说，可回去就是承认自己失败了呀。 我突然说不出话来。因为自己内心无法描述出来的感受被人说出来了，被一个有同样感受的人。 其实他又帅又高，性格体贴，在多伦多买了房。饭也烧的好吃。怎么也算不上失败的。 只是还没有个稳定的工作，大概是觉得既然出来了，总得混出点名堂再回去吧。 我懂，因为这也是我的思量。 想显得体面一些，就会有很多顾虑和考量夹在在生活中，就很难用自己觉得舒服的姿势过日子了。但你得装作你其实还不错。 突然就感觉我们这些人有点可怜，还有更可怜的万历皇帝。 皇帝都身不由己，何况我们这些的普通人呢。 一边听着电话，电视里刚好放到姚贝娜在唱鱼，眼睛里闪烁着难以言明的光彩，光彩里涌动着渴望。 感觉我就像她歌声里的鱼，怎么逃都逃不出这个世界编的网，挣脱了一个网眼还有一个网眼。 网眼的种类还挺多：钱，关系，房子，车，人脉，还有乱七八糟的东西。 去你妈的。 我就想每天旱涝保收饿不死没事打打游戏偶尔吃顿好的。人活着怎么就得有这么多逼事儿呢，怎么就有这么多要求呢？ 最变态的是我自己也明白我得去努力追逐这些东西，不能当loser。到底为什么我会有这些跟自己过不去的想法并且用来要求自己？ 我小时候就一直在想，会不会我们的世界其实就是一本故事书，人生只是有个旁白在默默地读你的故事，一个个被写好的故事。 想来想去也没什么头绪，还是继续写会儿代码好了。算是明白文章憎命达了，失意的人才有闲心胡思乱想。 世界静下来了，想了想最近真的好累啊。其实就是在发牢骚吧，因为想逃却逃不了。]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree Traversals]]></title>
    <url>%2F2018%2F07%2F05%2FTree%20Traversals%2F</url>
    <content type="text"><![CDATA[Preorder Traversalroot，left，right。 Inorder TraversalPostorder Traversal树相关问题 合并两棵二叉树 617. Merge Two Binary Trees基本思路：看代码就行了。12345678910111213141516171819class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null &amp;&amp; t2 == null) return null; int val = 0; if (t1 != null &amp;&amp; t2 != null) &#123; val = t1.val + t2.val; &#125; else if (t1 == null &amp;&amp; t2 != null) &#123; val = t2.val; &#125; else &#123; val = t1.val; &#125; TreeNode cur = new TreeNode(val); cur.left = mergeTrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left); cur.right = mergeTrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right); return cur; &#125;&#125; BST中寻值 700. Search in a Binary Search Trees基本思路：根据BST性质找就是了。 12345678910111213141516171819class Solution &#123; public TreeNode iteration(TreeNode root, int val) &#123;// BST while (root != null &amp;&amp; root.val != val) &#123; root = root.val &gt; val ? root.left : root.right; &#125; return root; &#125; public TreeNode recursion(TreeNode root, int val) &#123; if (root == null) return null; if (root.val == val) &#123; //System.out.println(root.val); return root; &#125; else if (val &gt; root.val) return searchBST(root.right, val); else if (val &lt; root.val) return searchBST(root.left, val); return null; &#125;&#125; 235. Lowest Common Ancestor of a Binary Search Trees基本思路：按照BST性质来1234567891011class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else &#123; return root; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2F2018%2F07%2F05%2F129.%20Sum%20Root%20to%20Leaf%20Numbers%2F</url>
    <content type="text"><![CDATA[A binary tree question. The general ieda is using preorder traversal in recursion way. Iterative solution is also accepted.1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; int sum; public int sumNumbers(TreeNode root) &#123; sum = 0; dfs(root, 0); return sum; &#125; public void dfs(TreeNode node, int cur) &#123; if (node == null) return; cur = cur * 10 + node.val; if (node.left == null &amp;&amp; node.right == null) &#123; sum += cur; return; &#125; if (node.left != null) dfs(node.left, cur); if (node.right != null) dfs(node.right, cur); &#125; public int iterative(TreeNode root) &#123;// use two stacks to keep nodes and current sum if (root == null) return 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; sum = new Stack&lt;&gt;(); stack.push(root); sum.push(root.val); int res = 0; while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); int cur = sum.pop(); if (node.left == null &amp;&amp; node.right == null) &#123; res += cur; &#125; if (node.right != null) &#123; stack.push(node.right); sum.push(cur * 10 + node.right.val); &#125; if (node.left != null) &#123; stack.push(node.left); sum.push(cur * 10 + node.left.val); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[863. All Nodes Distance K in Binary Tree]]></title>
    <url>%2F2018%2F07%2F01%2F863.%20All%20Nodes%20Distance%20K%20in%20Binary%20Tree%2F</url>
    <content type="text"><![CDATA[Use HashMap，先用bfs或dfs将树变成一个图，之后根据target node的neighbors进行逐层搜索，直到distance == K。通过HashSet avoid visited nodes。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; Map&lt;TreeNode, HashSet&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; buildMap(root); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(target); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); visited.add(target); boolean found = false; int dis = 0; while (!q.isEmpty()) &#123; int len = q.size(); for (int size = 0; size &lt; len; size++) &#123; TreeNode cur = q.poll(); if (dis == K) &#123; list.add(cur.val); found = true; &#125;else &#123; if (!map.get(cur).isEmpty()) &#123; for (TreeNode t : map.get(cur)) &#123; if (!visited.contains(t)) &#123; q.offer(t); visited.add(t); &#125; &#125; &#125; &#125; &#125; if (found) return list; dis++; &#125; return list; &#125; public void buildMap(TreeNode node) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(node); map.put(node, new HashSet&lt;TreeNode&gt;()); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); if (cur.left != null) &#123; map.put(cur.left, new HashSet&lt;TreeNode&gt;()); map.get(cur).add(cur.left); map.get(cur.left).add(cur); q.offer(cur.left); &#125; if (cur.right != null) &#123; map.put(cur.right, new HashSet&lt;TreeNode&gt;()); map.get(cur).add(cur.right); map.get(cur.right).add(cur); q.offer(cur.right); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[133. Clone Graph]]></title>
    <url>%2F2018%2F07%2F01%2F133.%20Clone%20Graph%2F</url>
    <content type="text"><![CDATA[This is the BFS + Queue solution, use map to keep original nodes and copied nodes.Map can also avoid loop. 1234567891011121314151617181920212223242526272829303132/** * Definition for undirected graph. * class UndirectedGraphNode &#123; * int label; * List&lt;UndirectedGraphNode&gt; neighbors; * UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125; * &#125;; */public class Solution &#123; public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) return node; UndirectedGraphNode copy = new UndirectedGraphNode(node.label); HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); Queue&lt;UndirectedGraphNode&gt; q = new LinkedList&lt;&gt;(); map.put(node, copy); q.offer(node); while (!q.isEmpty()) &#123; UndirectedGraphNode cur = q.poll(); for (UndirectedGraphNode n : cur.neighbors) &#123; if (!map.containsKey(n)) &#123; map.put(n, new UndirectedGraphNode(n.label)); q.offer(n); &#125; // add neighbors to the copied node // map.get(cur) -&gt; copied node of cur // map.get(n) -&gt; neighbors of copied node map.get(cur).neighbors.add(map.get(n)); &#125; &#125; return copy; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听雨]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%90%AC%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[第一次知道竹山词，是高中时候许南翔一笔笔写在黑板上，说你们现在不懂，觉得这词很一般，将来就懂了。 虞美人这个词牌，历来最推崇不过李煜的“春花秋月何时了，往事知多少”。但我私心里还是更喜欢蒋捷的这首听雨。 我想许南翔当年给我们上课时，应该和我现在是差不多的年纪。过了弱冠之年，离而立却还有一点距离，对人生这个事刚刚有了一点自己的理解。这个世界的万般头绪铺开在我的面前，少年意气开始一点点消减。 开始有了一些却道天凉好个秋的滋味。 晚上一个人在bonsai的吧台吃冷饭团，一边感受着突然而至的阵雨。没有什么悲欢离合也无情。 只有特别深的孤独。 一个人走在回出租房的路上，穿过不同颜色的皮肤，感受到夹带着雨丝的冷风。 我突然开始怀念家乡闷热的雨季，那潮湿绵密的水汽将我包裹的感觉，那江南水乡特有的味道。 那味道是妈丢给我的毛巾的香味，是爸端出的来的饭菜的香味，是家里放久了的家具，在梅雨季节散发出来的一点点霉味。 雨声夹带着电视节目的人声，混合着小区外远远传来的几句咒骂。 而现在雨声里只参杂着键盘敲击的哒哒声。 十几岁的我不明白雨水滴落地面的声音怎么能用得上听，但现在知道了。原来只有生活并不一帆风顺的人，才能听到雨的声音。 我合上电脑，看着窗外的雨帘中渐渐显出远处方尖碑的轮廓，若隐若现，居然像极了鼓楼。]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
</search>
